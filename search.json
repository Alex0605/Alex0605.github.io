[{"title":"Git命令速查手册","url":"/2018/01/29/Git命令速查手册/","content":"\n### 1、初始化仓库\n\n```java\ngit init\n```\n\n\n\n### 2、将文件添加到仓库\n\n```java\ngit add 文件名 # 将工作区的某个文件添加到暂存区   \n\ngit add -u # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，不处理untracked的文件\n\ngit add -A # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，包括untracked的文件\n\ngit add . # 将当前工作区的所有文件都加入暂存区\n\ngit add -i # 进入交互界面模式，按需添加文件到缓存区\n```\n\n\n\n### 3、将暂存区文件提交到本地仓库\n\n```\ngit commit -m \"提交说明\" # 将暂存区内容提交到本地仓库\n\ngit commit -a -m \"提交说明\" # 跳过缓存区操作，直接把工作区内容提交到本地仓库\n```\n\n\n\n### 4、查看仓库当前状态\n\n```\ngit status\n```\n\n\n\n### 5、比较文件异同\n\n```\ngit diff # 工作区与暂存区的差异\n\ngit diff 分支名 #工作区与某分支的差异，远程分支这样写：remotes/origin/分支名\n\ngit diff HEAD  # 工作区与HEAD指针指向的内容差异\n\ngit diff 提交id 文件路径 # 工作区某文件当前版本与历史版本的差异\n\ngit diff --stage # 工作区文件与上次提交的差异(1.6 版本前用 --cached)\n\ngit diff 版本TAG # 查看从某个版本后都改动内容\n\ngit diff 分支A 分支B # 比较从分支A和分支B的差异(也支持比较两个TAG)\n\ngit diff 分支A...分支B # 比较两分支在分开后各自的改动\n\n\\# 另外：如果只想统计哪些文件被改动，多少行被改动，可以添加 --stat 参数\n```\n\n\n\n### 6、查看历史记录\n\n```\ngit log # 查看所有commit记录(SHA-A校验和，作者名称，邮箱，提交时间，提交说明)\n\ngit log -p -次数 # 查看最近多少次的提交记录\n\ngit log --stat # 简略显示每次提交的内容更改\n\ngit log --name-only # 仅显示已修改的文件清单\n\ngit log --name-status # 显示新增，修改，删除的文件清单\n\ngit log --oneline # 让提交记录以精简的一行输出\n\ngit log –graph –all --online # 图形展示分支的合并历史\n\ngit log --author=作者  # 查询作者的提交记录(和grep同时使用要加一个--all--match参数)\n\ngit log --grep=过滤信息 # 列出提交信息中包含过滤信息的提交记录\n\ngit log -S查询内容 # 和--grep类似，S和查询内容间没有空格\n\ngit log fileName # 查看某文件的修改记录，找背锅专用\n```\n\n\n\n### 7、代码回滚\n\n```\ngit reset HEAD^ # 恢复成上次提交的版本\n\ngit reset HEAD^^ # 恢复成上上次提交的版本，就是多个^，以此类推或用~次数\n\ngit reflog\n\ngit reset --hard 版本号\n\n--soft：只是改变HEAD指针指向，缓存区和工作区不变；\n\n--mixed：修改HEAD指针指向，暂存区内容丢失，工作区不变；\n\n--hard：修改HEAD指针指向，暂存区内容丢失，工作区恢复以前状态；\n```\n\n\n\n### 8、同步远程仓库\n\n```\ngit push -u origin master\n```\n\n\n\n### 9、删除版本库文件\n\n```\ngit rm 文件名\n```\n\n\n\n### 10、版本库里的版本替换工作区的版本\n\n```\ngit checkout -- test.txt\n```\n\n\n\n### 11、本地仓库内容推送到远程仓库\n\n```\ngit remote add origin git@github.com:帐号名/仓库名.git\n```\n\n\n\n### 12、从远程仓库克隆项目到本地\n\n```\ngit clone git@github.com:git帐号名/仓库名.git\n```\n\n\n\n### 13、创建分支\n\n```\ngit checkout -b dev\n\n-b表示创建并切换分支\n\n上面一条命令相当于下面的二条：\n\ngit branch dev //创建分支\n\ngit checkout dev //切换分支\n```\n\n\n\n### 14、查看分支\n\n```\ngit branch\n```\n\n\n\n### 15、合并分支\n\n```\ngit merge dev\n\n//用于合并指定分支到当前分支\n\ngit merge --no-ff -m \"merge with no-ff\" dev\n\n//加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并\n```\n\n\n\n### 16、删除分支\n\n```\ngit branch -d dev\n```\n\n\n\n### 17、查看分支合并图\n\n```\ngit log --graph --pretty=oneline --abbrev-commit\n```\n\n\n\n### 18、查看远程库信息\n\n```\ngit remote\n\n// -v 显示更详细的信息\n```\n\n\n\n### 19、git相关配置\n\n\\\n\n```\n# 安装完Git后第一件要做的事，设置用户信息(global可换成local在单独项目生效)：\n\ngit config --global user.name \"用户名\" # 设置用户名\n\ngit config --global user.email \"用户邮箱\"   #设置邮箱\n\ngit config --global user.name   # 查看用户名是否配置成功\n\ngit config --global user.email   # 查看邮箱是否配置\n\n\\# 其他查看配置相关\n\ngit config --global --list  # 查看全局设置相关参数列表\n\ngit config --local --list # 查看本地设置相关参数列表\n\ngit config --system --list # 查看系统配置参数列表\n\ngit config --list  # 查看所有Git的配置(全局+本地+系统)\n\ngit config --global color.ui true //显示git相关颜色\n```\n\n\n\n### 20、撤消某次提交\n\n```\ngit revert HEAD # 撤销最近的一个提交\n\ngit revert 版本号 # 撤销某次commit\n```\n\n\n\n### 21、拉取远程分支到本地仓库\n\n```\ngit checkout -b 本地分支 远程分支 # 会在本地新建分支，并自动切换到该分支\n\ngit fetch origin 远程分支:本地分支 # 会在本地新建分支，但不会自动切换，还需checkout\n\ngit branch --set-upstream 本地分支 远程分支 # 建立本地分支与远程分支的链接\n```\n\n\n\n### 22、标签命令\n\n```\ngit tag 标签 //打标签命令，默认为HEAD\n\ngit tag //显示所有标签\n\ngit tag 标签 版本号 //给某个commit版本添加标签\n\ngit show 标签 //显示某个标签的详细信息\n```\n\n\n\n### 23、同步远程仓库更新\n\n```\ngit fetch  origin master\n\n//从远程获取最新的到本地，首先从远程的origin的master主分支下载最新的版本到origin/master分支上，然后比较本地的master分支和origin/master分支的差别，最后进行合并。\n\ngit fetch比git pull更加安全\n```\n\n","tags":["Git"]},{"title":"机器学习入门（一）","url":"/2018/01/25/机器学习入门（一）/","content":"\n\n\n# 机器学习入门\n\n## 一、定义\n\n使用算法解析数据，从中学习，然后对世界上的某件事情做出决定或预测\n\n机器学习是人工智能的一个分支。人工智能致力于创造出比人类更能完成复杂任务的机器。这些任务通常涉及判断、策略和认知推理，这些技能最初被认为是机器的“禁区”。虽然这听起来很简单，但这些技能的范围非常大——语言处理、图像识别、规划等等。\n\n## 二、分类\n\n1、监督学习\n\n监督学习涉及一组标记数据。计算机可以使用特定的模式来识别每种标记类型的新样本。监督学习的两种主要类型是分类和回归。在分类中，机器被训练成将一个组划分为特定的类。分类的一个简单例子是电子邮件帐户上的垃圾邮件过滤器。过滤器分析你以前标记为垃圾邮件的电子邮件，并将它们与新邮件进行比较。如果它们匹配一定的百分比，这些新邮件将被标记为垃圾邮件并发送到适当的文件夹。那些比较不相似的电子邮件被归类为正常邮件并发送到你的邮箱。\n      第二种监督学习是回归。在回归中，机器使用先前的(标记的)数据来预测未来。天气应用是回归的好例子。使用气象事件的历史数据(即平均气温、湿度和降水量)，你的手机天气应用程序可以查看当前天气，并在未来的时间内对天气进行预测。\n\n2、非监督学习\n      \n\n在无监督学习中，数据是无标签的。由于大多数真实世界的数据都没有标签，这些算法特别有用。无监督学习分为聚类和降维。聚类用于根据属性和行为对象进行分组。这与分类不同，因为这些组不是你提供的。聚类的一个例子是将一个组划分成不同的子组(例如，基于年龄和婚姻状况)，然后应用到有针对性的营销方案中。降维通过找到共同点来减少数据集的变量。大多数大数据可视化使用降维来识别趋势和规则。\n\n3、强化学习\n      \n\n强化学习使用机器的个人历史和经验来做出决定。强化学习的经典应用是玩游戏。与监督和非监督学习不同，强化学习不涉及提供“正确的”答案或输出。相反，它只关注性能。这反映了人类是如何根据积极和消极的结果学习的。很快就学会了不要重复这一动作。同样的道理，一台下棋的电脑可以学会不把它的国王移到对手的棋子可以进入的空间。然后，国际象棋的这一基本教训就可以被扩展和推断出来，直到机器能够打(并最终击败)人类顶级玩家为止。","tags":["人工智能","机器学习"]},{"title":"Android Studio Gradle详解","url":"/2018/01/18/Android-Studio-Gradle详解/","content":"\n## 1、AppExtension类及其属性\n### 1.1 基础介绍\n&emsp; &emsp;可能大部分人看到AppExtension类会感觉到非常的陌生，其实我们在app中的build.gradle中填写配置信息的时候，经常看到它，它是什么呢？\n&emsp; &emsp;如果你按ctrl+鼠标左键对着android{},点击进去就知道了，其实android{…}表示的就是AppExtension这个类。\n下图是AppExtension 继承关系\n![app](https://github.com/Alex0605/Alex0605.github.io/blob/master/img/gradle_lib.png)\n&emsp; &emsp;除了AppExtension之外还有2个类与之相似，LibraryExtension和TestExtension\n&emsp; &emsp;如果是module项目作为lib使用，那么lib下的build.gradle中的android对应的是LibraryExtension\n\n### 1.2 AppExtension的属性\n* aaptOptions：aapt是一个可以将资源文件编译成二进制文件的工具。aaptOptions表示  aapt工具设置的可选项参数。 \n* adbExecutable：adb从编译sdk时执行\n*  adbOptions：adb的可选项参数 \n*  applicationVariants：应用变体列表 \n*  buildToolsVersion：构建工具版本(必要的) \n*  buildTypes：构建类型(一般是release和debug，还可以自定义) \n*  compileOptions：编译可选项参数 \n*  compileSdkVersion：编译sdk版本(必要的) \n*  dataBinding：Data Binding可选项参数(关于DataBinding的使用) \n*  defualtConfig：默认配置，对于所有的打包项目 \n*  defualtPublishConfig：默认是release。\n*   dexOptions：Dex可选项参数。 \n*  externalNativeBuild：native编译支持。\n*  flavorDimensionList：\n*  generatePureSplits：是否拆成多个APK \n*  jacoco：JaCoCo可选项参数 \n*  lintOptions：Lint工具可选项参数\n*   ndkDirectory：ndk目录(一般在local.properties中) \n*  packagingOptions：packaging的可选参数 \n*  productFlavors：项目所有flavor \n*  publishNonDefualt：不仅仅使用默认的publish artifacts。可参defualtPublishConfig。              \n*  resourcePrefix：创建新资源时使用的前缀。 \n*  sdkDirectory：sdk目录(一般在local.properties中) \n*  signingConfigs：签名文件的可选项参数 \n*  sourceSets：资源文件目录指定(Android中有自己的AndroidSourceSets，这个一般用于assets，jin等目录) splits：splits类型。\n*   testBuildType：测试构建类型\n*   testOptions：测试可选项参数 \n*  testVariants：测试变体 \n*  unitTestVariants：单元测试变体 \n*  variantFilter：变体过滤器,加粗的表示DSL语言的闭包,如：\n```\nbuildTypes { }\n```\n\n\n### 1.3 AppExtension的闭包\n&emsp; &emsp;与app中build.gradle中android{}一样，代码中由AppExtension类表示。其他的配置闭包也一样。\n1、aaptOptions{}代码由AaptOptions类表示。\n\n```\nAaptOptions的属性：\nadditionalParameters:额外参数，List类型。\ncruncherEnabled：如果PNG图片是否可以大量快速的处理，boolean类型。 true表示可以。\ncruncherProcesses:快速处理，可能需要更多的内存和CPU。int类型。默认0，值越大处理越快，需要的内存和CPU也越大。\nfailOnMissingConfigEntry:如果没有找到一个配置，就返回一个错误。Boolean值，默认false。\nignoreAssetsPattern：忽略Assets模块。\nmoCompress：拓展文件不会打包进apk中。\n \n用法(详细用法可能需要去看看文档了)：\naaptOptions{\n    cruncherEnabled true//快速处理PNG图片\n}\n```\n\n2、adbOption{}\n```\nadbOptions{}对应的是AdbOptions\nAdbOptions的属性：\ninstallOptions：apk安装的可选参数。\ntimeOutInMs：使用adb的超时时间。\n```\n3、buildTypes{}\n```\nbuildTypes{}对应的是BuildType类\n \nbuildTypes的属性：\n \napplicationIdSuffix：应用id后缀(给Applica)\nconsumerProguardFiles：混淆文件包含在arr包中。\ndebuggable：是否生成一个debug的apk\nembedMicroApp：可穿戴设备app是否可以使用这个编译类型\njavaCompileOption：Java编译配置参数\njniDebuggable：这个编译类型的配置是否可以与debuggable的native代码生成一个apk\nmanifestPlaceholders：清单占位符\nminifyEnabled：是否缩小\nmultiDexEnabled：是否拆成多个Dex\nmultiDexKeepFile：指定文本文件编译进主Dex文件中\nmultiDexKeepProguard：指定混淆文件编译进主Dex文件中\nname：build type的名字\nproguardFiles：混淆文件\npseudoLocalesEnabled：是否生成伪现场apk(如果没有提供混淆规则文件，则设置默认的混淆规则文件（SDK/tools/proguard/proguard-android.txt）)\nrenderscriptDebuggable：使用RenderScript编译器的优化级别。\nshrinkResources：是否去除未利用的资源，默认false，表示不去除。\nsigningConfig：签名配置\ntestCoverageEnabled：测试覆盖率是否被激活。\nuseJack：过时\nversionNameSuffix：版本名称后缀\n zipAlignEnable：是否使用zipalign工具压缩。\n \n------------------------------------------------------\n \nbuildType的方法：\n \nbuildConfigField(type,name,value)：添加一个变量生成BuildConfig类。\nconsumeProguardFile(proguardFile)：添加一个混淆文件进arr包。\nconsumeProguardFile(proguardFiles)：添加混淆文件进arr包。\nexternalNativeBuild(action)：配置本地的build选项。\ninitWith：复制这个build类型的所有属性。\nproguardFile(proguardFile)：添加一个新的混淆配置文件。\nproguradFiles(files):添加新的混淆文件\nresValue(type,name,value)：添加一个新的生成资源\nsetProguardFiles(proguardFileIterable):设置一个混淆配置文件。\n------------------------------------------------------------\nbuildType用法：\n \n  buildTypes {\n        release {\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            shrinkResources true\n            zipAlignEnabled true\n            debuggable false\n            //...\n        }\n \n        debug{\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            shrinkResources true\n            zipAlignEnabled true\n            debuggable true\n            //...\n        }\n    }\n```\n\n\n4、compileOptions{}\n```\ncompileOptions{}对应的是CompileOptions\n\nCompileOptions的属性：\nencoding：Java源文件的编码格式\nincremental：是否应该使用Java编写的Gradle新的增量模型\nsourceCompatibility：指定编译编译.java文件的jdk版本\ntargetCompatibility：确保class文件与targetCompatibility指定版本，或者更新的java虚拟机兼容\n```\n5、dataBinding{}\n```\ndataBinding{}对应的是DataBindingOptions\n \n \nDataBindingOptions的属性：\n \naddDefualtAdapters：是否添加一个默认的data binding适配器。默认true。\nenabled：是否使用data binding\nversion：data binding使用版本\n \n \ndataBinding的使用：\n \ndataBinding{\n    enabled true\n}\n```\n\n\n6、defualtConfig{}\n```\ndefaultConfig{}是所有flavor都共有的配置。\n \n英文解释：The default configuration, inherited by all product flavors (if any are defined).\n \n \ndefaultConfig的使用：\n \n defaultConfig {\n        applicationId \"com.example.zhang.demo\"\n        minSdkVersion 15\n        targetSdkVersion 25\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n}\n```\n7、dexOptions{}\n```\ndexOptions{}对应的是DexOptions\n \nDexOptions属性:\n \nadditionalParameters：给dx添加一系列附加的参数\njavaMaxHeapSize：当调用dx时指定-Xmx值。\njumboMode：使用jumbo(庞大的)模式\nkeepRuntimeAnnotatedClasses：保持所有类中的运行时的注解在主Dex中。\nmaxProcessCount：可以使用Dex的最大并发进程数。默认为4。\noptimize：运行在dx编译器是否有optimize标记。\npreDexLibraries：是否预先dex库，它可以改善增量的生成，但是在clear build可能会变慢\nthreadCount：当dx运行时使用的线程的数量。默认4个。\n \n \ndexOptions{}的用法：\n \ndexOptions {\n    preDexLibraries  false\n    javaMaxHeapSize \"4g\"\n}\n```\n\n8、externalNativeBuild{}\n```\nexternalNativeBuild{}对应的是ExternalNativeBuild\n \nExternalNativeBuild的属性：\n \ncmake：CMake工具编译选项。\nndkBuild：ndk-build选项。\n \n \n在externalNativeBuild{}中有2个模块，cmake{}和ndkBuild{}模块\n \n------------------------------------------------\ncmake{}对应的是CmakeOptions\n \nCmakeOption的属性：\npath：你的CmakeLists.txt编译脚本的相对路径。\n \n--------------------------------------------------\nndkBuild{}对应的是NdkBuildOptions\n \nNdkBuildOptions的属性：\npath:你的Android.mk文件的相对路径。\n \n--------------------------------------------------\n \n \nexternalNativeBuild{}的用法：\n \nexternalNativeBuild{\n    ndkBuild{\n        path file(\"src\\\\main\\\\jni\\\\Android.mk\")\n    }\n \n    cmake {\n        path \"src/main/cpp/CMakeLists.txt\"\n    }\n}\n```\n\n9、jacoco{}\n```\njacoco{}对应于JacocoOptions\n \nJacocoOptions的属性：\n1.version：过时\n \n英文原文：\nnote: this property is deprecated and will be removed in a future version of the plugin.\n\n```\n10、lintOptions{}\n```\nlintOptions{}对应于LintOptions\n \n \nLintOptions的属性：\nabortOnError：如果发现错误，lint工具是否应该退出这个程序。true表示退出。\nabsolutePaths：是否在输出错误的时候，lint应该展示出全路径。默认是相对路径，也就是默认false。\ncheck：精确的检查(搜集)问题的集合，默认情况下，任何问题都可以通过LintOptions.getEnable()启用，没有问题可以通过LintOptions.getDisable()使之无效。\ncheckAllWarnings：是否检查所有警告，包括那些默认关闭。\ndisable：通过id's来压制这个问题，允许修改\nenable：通过id's来处理这个问题，循序修改，他会将添加id，并返回一个集合。\nexplainIssues：返回lint是否包含错误问题的解释(注意：HTML和XML报告会无条件的去做，忽略这个设置)。\nhtmlOutput：html输出方式。\nhtmlReport：我们应该是否写一个HTML报告，默认true， 这个使用场景由LintOptions.getHtmlOutput()控制。\nignoreWarings：lint仅仅检查错误，忽略警告。\nlintConfig：默认配置文件作为备份。\nnoLines：lint在输出错误日志的时候，是否包含行数。默认true。\nquiet：lint是否应该quiet(安静)。如：报告文件写入路径，不写消息。\nseverityOverrides：An optional map of severity overrides. The map maps from issue id's to the corresponding severity to use, which must be \"fatal\", \"error\", \"warning\", or \"ignore\".\nshowAll：lint是否包含所有的输出。\ntextOutput：文本输出方式。\ntextReport：是否是文本报告写入，默认false。\nwarningAsErrors：lint是否把警告当做错误来处理。\nxmlOutput：XML输出方式。\nxmlReport：XML格式写入报告，默认true。\n \n------------------------------------------------\n \nLintOptions的方法：\n \ncheck(id)：检查这个id的问题的集合\ncheck(ids)：\ndisable(id)：将id添加到不用启动的问题集\ndisable(ids)：\nenable(id)：将id添加到启动的问题集\nenable(ids)\nerror(id)：将id添加到错误的问题集\nerror(ids)\nfatal(id)：将id添加到fatal级别的问题集\nfatal(ids)\nignore(id)：将id添加到ignore级别的问题集\nignore(ids)\nwaring(id)：将id添加到waring级别的问题集\nwaring(ids)\n \n------------------------------------------------\n \nlintOptions{}的一般用法：\n \nlintOptions {\n    abortOnError false\n}\n```\n\n\n11、packagingOptions{}\n```\npackagingOptions{}对应的是PackagingOptions\nPackaging options有三组路径：first-picks，merges和excludes:\npackagingOptions{}的用法：\npackagingOptions {\n    pickFirsts = [] // Not really needed because the default is empty.\n    merges = []     // Not really needed because the default is empty.\n    excludes = []\n}\n```\n\n\n12、productFlavors{}\n```\nproductFlavors{}对应的是ProductFlavors\n \nProductFlavors的属性：\n \napplicationId：应用程序ID。\napplicationIdSuffix：应用程序ID后缀。\nconsumerProguardFiles：混淆规则文件被包含在aar包中。\ndimension：flavor名称的尺寸。\nexternalNativeBuild：详情见externalNativeBuild{}\nflavorDeminsion：过时\ngeneratedDensities：过时\njackOption：jack配置可选项。\njavaCompileOptions：Java编译配置参数\nmanifestPlaceholders：manifest占位符\nmultiDexEnabled：是否进行dex拆分\nmultiDexKeepFile：文本文件编译进主dex文件中。\nmultiDexKeepProgroud：文本文件作为混淆规则编译进主dex文件中\nndk：ndk配置\nproguardFiles:混淆文件\nsigningConfig：这个flavor的签名配置信息\ntestApplicationId：测试应用ID\ntestFunctionalTest：\ntestHandleProfiling：\ntestInstrumentationRunner：\ntestInstrumentionRunnerArguments：\nuseJack：过时\nverctorDrawables：生成矢量图支持\nversionCode：版本号\nversionName:版本名\nversionNameSuffix：版本名后缀\nwearAppUnbundled：是否对嵌入式穿戴app进行拆分模式。如果true，那么这个app将在应用市场被分发为穿戴设备的app。\n \nproductFlavor{}的用法：\nproductFlavors {\n \n        googlePlay {\n        }\n \n        xiaomi {\n        }\n}\n//所有打包配置（批量处理打包渠道--> manifestPlaceholders：设置打包渠道）\nproductFlavors.all {\n    //平台id\n    flavor -> flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]\n}\n```\n\n13、signingConfig{}\n\n```\nsigningConfig{}对应的是SigningConfig\n \nSigningConfig的属性：\n \nkeyAlias：签名使用key的别名\nKeyPassword：签名使用的key的密码\nstoreFile：store签名文件\nstorePassword：store签名密码\nstoreType：store签名类型\nSigningEnabled：是否使用jar签名(又名v1签名)。\nv2SigningEnabled：是否使用apk签名(又名v2签名)。\n \n \nsigningConfig{}的用法：\n \nsigningConfigs {\n    config {\n        keyAlias '...'\n        keyPassword '...'\n        storeFile file('C:/../Key.jks')\n        storePassword '...'\n    }\n}\n```\n14、sourceSets{}\n```\nsourceSets{}对应的AndroidSourceSet\n \nAndroidSourceSet的属性：\n \naidl：aidl目录\nassets：assets目录\ncompileConfiguraName：编译配置资源目录。\njava：java代码目录（需要编译成.class文件）\njni：jni资源目录\njniLibs：jni库目录\nmanifest：AndroidManifest.xml资源文件\nname：source set名称。\npackageConfigurationName：运行时配置的资源集。\nprovidedConfigurationName：仅仅编译时配置的资源集。\nrenderscript：RenderScript脚本资源目录\nres：Android资源目录\nresource：java资源被复制到输出到javaresource目录\n \nAndroidSourceSet的方法：\n1.setRoot(path)：资源集的根目录，所有的资源都在这个跟目录下。\n \nsourceSets{}的使用：\nsourceSets {\n    //在main目录中\n    main {\n        //assets目录设置\n        assets.srcDirs = ['assets']\n        //jni目录设置\n        jni.srcDirs 'src/main/jni'\n        //jni库设置\n        jniLibs.srcDir 'src/main/jniLibs'\n    }\n}\n```\n15、splits{}\n```\nsplits{}对应的是Splites\n \nSplits的属性：\n \nabi：ABI设置\nabiFilters：用于多个apk的ABI筛选列表\ndensity：密度设置\ndensityFilters：用于多个apk的密度筛选列表\nlanguage：语言设置。\nlanguageFilters：用于多个apk的语言筛选列表\n \n-----------------------------------------------------\n \n \nSpiltes对应有三个模块，abi{},density{},language{}\n \n \nabi{}对应的是AbiSplitOptions\n \nAbiSplitsOptions的属性：\napplicableFilters：返回此范围的所有适用筛选器的列表。\nenable：是否在这个范围分裂\nuniversalApk：是否创建所有可用的ABIs一个APK。\n \n \nAbiSplitesOptions的方法：\nexclude(excludes)：排除一些值。\ninclude(include)：包含一些值。\nreset()：重新设置split配置。\n \n----------------------------------------------------------\n \ndensity{}对应的是DensitySplitOptions\n \nDensitySplitOptions的属性：\napplicableFilters：返回此范围的所有适用筛选器的列表。\nauto：编译系统是否确定分割“language-*”文件夹中的资源。\ncompatibleScreen：兼容屏幕列表\nenable：是否拆分\n \n \nDensitySplitOptions的方法：\n1.exclude(exclude):排除一些值\n2.include(include):包含一些值\n3.reset()：重新设置split配置。\n \n \n-------------------------------------------------------\n \nlanguage{}对应的是LanguageSplitOptions\n \nLanguageSplitOptions的属性：\n1.enable：如果true，就是拆分language\n \n \nLanguageSplitOptions的方法：\n1.include(include)：包含一个模型。\n \n \n---------------------------------------------------------\n \nsplits{}的用法：\n \nsplits {\n    density {\n        enable true\n        exclude 'ldpi', 'mdpi'\n        compatibleScreens 'normal', 'large', 'xlarge'\n    }\n} \n \n生成结果：\napp-hdpi-release.apk\napp-universal-release.apk\napp-xhdpi-release.apk\napp-xxhdpi-release.apk\napp-xxxhdpi-release.apk\n \nsplits {\n    abi {\n      enable true\n      reset()\n      include 'x86', 'armeabi-v7a', 'mips'\n      universalApk true\n    }\n}\n这个就是生成不同手机架构的app\n```\n\n\n16、testOptions{}\n```\ntestOptions{}对应的是TestOptions\n \nTestOptions的属性：\n1.reportDir：报告目录\n2.resultDir：结果目录\n3.unitTests：单元测试配置参数\n \nTestOptions包含unitTests{}\n \n-------------------------------------------------------\n \nunitTests{}对应的是UnitTestOptions\n \nUnitTestOptions的属性：\n1.returnDefaultValues：无论unmocked方法从android.jar中抛出异常或是默认值（0或null）。\n \n \nUnitTestOtions的方法：\nall(configClosure)：配置所有单元测试任务。\n \n-------------------------------------------------\n \ntestOptions{}的使用：\n \ntestOptions {\n    resultsDir = \"$project.buildDir/foo/results\"\n}\n```\n### 1.4 AppExtension的方法\n- flavorDimensions(dimension):指定flavor名称\n- useLibraray(name)：请求使用一个lib库\n- useLibrary(name,required)：与上面解释一样。\n\n### 1.5 参考文档\n[1、BuildType官方文档](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.BuildType.html)\n\n[2、DataBinding详细用法](https://blog.csdn.net/qq_33689414/article/details/52205703)\n\n[3、Android Studio2.2 配置NDK](https://blog.csdn.net/jdh99/article/details/51765441)\n\n[4、Android studio 2.2 使用cmake编译NDK](https://blog.csdn.net/lmw21848/article/details/52183584)\n\n[5、Android Studio官方文档之使用Lint](https://blog.csdn.net/yishon_android/article/details/51864699)\n\n[6、PackagingOptions官方文档](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.PackagingOptions.html)\n\n[7、ProductFlavor官方文档](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.ProductFlavor.html)\n\n[8、APK-splite官方文档](http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits)\n\n[9、Splite官方文档](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.Splits.html)\n\n[10、AaptOptions官方](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.AaptOptions.html)","tags":["Android","Gradle"]}]