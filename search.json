[{"title":"Android知识-五-layout_weight和weightSum属性的详解及使用","url":"/2019/04/28/Android知识-五-layout-weight和weightSum属性的详解及使用/"},{"title":"深入理解Java注解类型","url":"/2018/03/02/深入理解Java注解类型/","content":"\n### 1、理解Java注解\n\nJava注解与普通修饰符(public、static、void等)的使用方式并没有多大区别，下面的例子是常见的注解：\n\n```java\npublic class AnnotationDemo {\n    //@Test注解修饰方法A\n    @Test\n    public static void A(){\n        System.out.println(\"Test.....\");\n    }\n\t\t//一个方法上可以拥有多个不同的注解\n    @Deprecated\n    @SuppressWarnings(\"uncheck\")\n    public static void B(){\n\n    }\n}\n```\n​\t\t通过在方法上使用@Test注解后，在运行该方法时，测试框架会自动识别该方法并单独调用，@Test实际上是一种标记注解，起标记作用，运行时告诉测试框架该方法为测试方法。而对于@Deprecated和@SuppressWarnings(“uncheck”)，则是Java本身内置的注解，在代码中，可以经常看见它们，但这并不是一件好事，毕竟当方法或是类上面有@Deprecated注解时，说明该方法或是类都已经过期不建议再用，@SuppressWarnings 则表示忽略指定警告，比如@SuppressWarnings(“uncheck”)，这就是注解的最简单的使用方式，那么下面我们就来看看注解定义的基本语法\n\n### 2、基本语法\n\n#### 2.1、声明注解与元注解\n\n我们先来看看前面的Test注解是如何声明的：\n\n```java\n//声明Test注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test {\n}\n```\n\n​\t\t我们使用了@interface声明了Test注解，并使用@Target注解传入ElementType.METHOD参数来标明@Test只能用于方法上，@Retention(RetentionPolicy.RUNTIME)则用来表示该注解生存期是运行时，从代码上看注解的定义很像接口的定义，确实如此，毕竟在编译后也会生成Test.class文件。对于@Target和@Retention是由Java提供的元注解，所谓元注解就是标记其他注解的注解，下面分别介绍\n\n1).@Target 用来约束注解可以应用的地方（如方法、类或字段），其中ElementType是枚举类型，其定义如下，也代表可能的取值范围\n\n```java\npublic enum ElementType {\n    /**标明该注解可以用于类、接口（包括注解类型）或enum声明*/\n    TYPE,\n    /** 标明该注解可以用于字段(域)声明，包括enum实例 */\n    FIELD,\n    /** 标明该注解可以用于方法声明 */\n    METHOD,\n    /** 标明该注解可以用于参数声明 */\n    PARAMETER,\n    /** 标明注解可以用于构造函数声明 */\n    CONSTRUCTOR,\n    /** 标明注解可以用于局部变量声明 */\n    LOCAL_VARIABLE,\n    /** 标明注解可以用于注解声明(应用于另一个注解上)*/\n    ANNOTATION_TYPE,\n    /** 标明注解可以用于包声明 */\n    PACKAGE,\n    /**\n     * 标明注解可以用于类型参数声明（1.8新加入）\n     * @since 1.8\n     */\n    TYPE_PARAMETER,\n    /**\n     * 类型使用声明（1.8新加入)\n     * @since 1.8\n     */\n    TYPE_USE\n}\n```\n请注意，当注解未指定Target值时，则此注解可以用于任何元素之上，多个值使用{}包含并用逗号隔开，如下：\n\n```java\n@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})\n```\n\n2).@Retention用来约束注解的生命周期，分别有三个值，源码级别（source），类文件级别（class）或者运行时级别（runtime），其含有如下：\n\n- SOURCE：注解将被编译器丢弃（该类型的注解信息只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件里）\n\n\n- CLASS：注解在class文件中可用，但会被VM丢弃（该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中），请注意，当注解未定义Retention值时，默认值是CLASS，如Java内置注解，@Override、@Deprecated、@SuppressWarnning等\n\n\n- RUNTIME：注解信息将在运行期(JVM)也保留，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息），如SpringMvc中的@Controller、@Autowired、@RequestMapping等。\n\n#### 2.2、注解元素及其数据类型\n\n通过上述对@Test注解的定义，我们了解了注解定义的过程，由于@Test内部没有定义其他元素，所以@Test也称为标记注解（marker annotation），但在自定义注解中，一般都会包含一些元素以表示某些值，方便处理器使用，这点在下面的例子将会看到：\n\n```java\n/**\n * 对应数据表注解\n */\n@Target(ElementType.TYPE)//只能应用于类上\n@Retention(RetentionPolicy.RUNTIME)//保存到运行时\npublic @interface DBTable {\n    String name() default \"\";\n}\n```\n上述定义一个名为DBTable的注解，该用于主要用于数据库表与Bean类的映射（稍后会有完整案例分析），与前面Test注解不同的是，我们声明一个String类型的name元素，其默认值为空字符，但是必须注意到对应任何元素的声明应采用方法的声明方式，同时可选择使用default提供默认值，@DBTable使用方式如下：\n\n```java\n//在类上使用该注解\n@DBTable(name = \"MEMBER\")\npublic class Member {\n    //.......\n}\n```\n\n关于注解支持的元素数据类型除了上述的String，还支持如下数据类型\n\n- 所有基本类型（int,float,boolean,byte,double,char,long,short）\n- String\n- Class\n- enum\n- Annotation\n- 上述类型的数组\n\n倘若使用了其他数据类型，编译器将会丢出一个编译错误，注意，声明注解元素时可以使用基本类型但不允许使用任何包装类型，同时还应该注意到注解也可以作为元素的类型，也就是嵌套注解，下面的代码演示了上述类型的使用过程：\n\n```java\npackage com.zejian.annotationdemo;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n/**\n* 数据类型使用Demo\n*/\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Reference{\n    boolean next() default false;\n}\n\npublic @interface AnnotationElementDemo {\n    //枚举类型\n    enum Status {FIXED,NORMAL};\n    //声明枚举\n    Status status() default Status.FIXED;\n\n    //布尔类型\n    boolean showSupport() default false;\n\n    //String类型\n    String name()default \"\";\n\n    //class类型\n    Class<?> testCase() default Void.class;\n\n    //注解嵌套\n    Reference reference() default @Reference(next=true);\n\n    //数组类型\n    long[] value();\n}\n```\n#### 2.3.编译器对默认值的限制\n\n编译器对元素的默认值有些过分挑剔。首先，元素不能有不确定的值。也就是说，元素必须要么具有默认值，要么在使用注解时提供元素的值。其次，对于非基本类型的元素，无论是在源代码中声明，还是在注解接口中定义默认值，都不能以null作为值，这就是限制，没有什么利用可言，但造成一个元素的存在或缺失状态，因为每个注解的声明中，所有的元素都存在，并且都具有相应的值，为了绕开这个限制，只能定义一些特殊的值，例如空字符串或负数，表示某个元素不存在。\n\n#### 2.4.注解不支持继承\n\n注解是不支持继承的，因此不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口，这里我们反编译前面定义的DBTable注解\n\n```java\npackage com.zejian.annotationdemo;\n\nimport java.lang.annotation.Annotation;\n//反编译后的代码\npublic interface DBTable extends Annotation\n{\n    public abstract String name();\n}\n```\n\n虽然反编译后发现DBTable注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。\n\n#### 2.5.快捷方式\n\n所谓的快捷方式就是注解中定义了名为value的元素，并且在使用该注解时，如果该元素是唯一需要赋值的一个元素，那么此时无需使用key=value的语法，而只需在括号内给出value元素所需的值即可。这可以应用于任何合法类型的元素，记住，这限制了元素名必须为value，简单案例如下\n\n```java\npackage com.zejian.annotationdemo;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n//定义注解\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface IntegerVaule{\n    int value() default 0;\n    String name() default \"\";\n}\n\n//使用注解\npublic class QuicklyWay {\n    //当只想给value赋值时,可以使用以下快捷方式\n    @IntegerVaule(20)\n    public int age;\n\n    //当name也需要赋值时必须采用key=value的方式赋值\n    @IntegerVaule(value = 10000,name = \"MONEY\")\n    public int money;\n}\n```\n\n#### 2.6.Java内置注解与其它元注解\n\n接着看看Java提供的内置注解，主要有3个，如下：\n\n- @Override：用于标明此方法覆盖了父类的方法，源码如下\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override {\n}\n```\n\n- @Deprecated：用于标明已经过时的方法或类，源码如下，关于@Documented稍后分析：\n\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})\npublic @interface Deprecated {\n\n}\n```\n\n- @SuppressWarnnings:用于有选择的关闭编译器对类、方法、成员变量、变量初始化的警告，其实现源码如下：\n\n```java\n@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})\n@Retention(RetentionPolicy.SOURCE)\npublic @interface SuppressWarnings {\n    String[] value();\n}\n```\n\n其内部有一个String数组，主要接收值如下：\n\ndeprecation：使用了不赞成使用的类或方法时的警告；\nunchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; \nfallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;\npath：在类路径、源文件路径等中有不存在的路径时的警告; \nserial：当在可序列化的类上缺少 serialVersionUID 定义时的警告; \nfinally：任何 finally 子句不能正常完成时的警告; \nall：关于以上所有情况的警告。\n\n这个三个注解比较简单，看个简单案例即可：\n\n```java\n//注明该类已过时，不建议使用\n@Deprecated\nclass A{\n    public void A(){ }\n    //注明该方法已过时，不建议使用\n    @Deprecated()\n    public void B(){ }\n}\nclass B extends A{\n    @Override //标明覆盖父类A的A方法\n    public void A() {\n        super.A();\n    }\n\n    //去掉检测警告\n    @SuppressWarnings({\"uncheck\",\"deprecation\"})\n    public void C(){ } \n    //去掉检测警告\n    @SuppressWarnings(\"uncheck\")\n    public void D(){ }\n}\n```\n前面我们分析了两种元注解，@Target和@Retention，除了这两种元注解，Java还提供了另外两种元注解，@Documented和@Inherited，下面分别介绍：\n\n@Documented 被修饰的注解会生成到javadoc中\n\n```java\n@Documented\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface DocumentA {\n  \n}\n//没有使用@Documented\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface DocumentB {\n}\n//使用注解\n@DocumentA\n@DocumentB\npublic class DocumentDemo {\n    public void A(){\n    }\n}\n```\n\n使用javadoc命令生成文档：\n\n```java\njavadoc DocumentDemo.java DocumentA.java DocumentB.java\n```\n\n可以发现使用@Documented元注解定义的注解(@DocumentA)将会生成到javadoc中,而@DocumentB则没有在doc文档中出现，这就是元注解@Documented的作用。\n\n可以发现使用@Documented元注解定义的注解(@DocumentA)将会生成到javadoc中,而@DocumentB则没有在doc文档中出现，这就是元注解@Documented的作用。\n\n```java\n@Inherited\n@Documented\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface DocumentA {\n}\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface DocumentB {\n}\n\n@DocumentA\nclass A{ }\n\nclass B extends A{ }\n\n@DocumentB\nclass C{ }\n\nclass D extends C{ }\n\n//测试\npublic class DocumentDemo {\n\n    public static void main(String... args){\n        A instanceA=new B();\n        System.out.println(\"已使用的@Inherited注解:\"+Arrays.toString(instanceA.getClass().getAnnotations()));\n\n        C instanceC = new D();\n\n        System.out.println(\"没有使用的@Inherited注解:\"+Arrays.toString(instanceC.getClass().getAnnotations()));\n    }\n\n    /**\n     * 运行结果:\n     已使用的@Inherited注解:[@com.zejian.annotationdemo.DocumentA()]\n     没有使用的@Inherited注解:[]\n     */\n}\n```\n\n### 3.注解与反射机制\n\n前面经过反编译后，我们知道Java所有注解都继承了Annotation接口，也就是说　Java使用Annotation接口代表注解元素，该接口是所有Annotation类型的父接口。同时为了运行时能准确获取到注解的相关信息，Java在java.lang.reflect 反射包下新增了AnnotatedElement接口，它主要用于表示目前正在 VM 中运行的程序中已使用注解的元素，通过该接口提供的方法可以利用反射技术地读取注解的信息，如反射包的Constructor类、Field类、Method类、Package类和Class类都实现了AnnotatedElement接口，它简要含义如下：\n\n```java\nClass：类的Class对象定义 　 \nConstructor：代表类的构造器定义 　 \nField：代表类的成员变量定义 \nMethod：代表类的方法定义 　 \nPackage：代表类的包定义\n```\n\n下面是AnnotatedElement中相关的API方法，以上5个类都实现以下的方法\n\n返回值\t方法名称\t说明\n\n\n| 返回值| 方法名称                      | 说明 |\n| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| <A extends Annotation> | getAnnotation(Class<A> annotationClass)                      | 该元素如果存在指定类型的注解，则返回这些注解，否则返回 null。 |\n| Annotation[]           | getAnnotations()                                             | 返回此元素上存在的所有注解，包括从父类继承的                 |\n| boolean                | isAnnotationPresent(Class<? extends Annotation> annotationClass) | 如果指定类型的注解存在于此元素上，则返回 true，否则返回 false。 |\n| Annotation[]           | getDeclaredAnnotations()                                     | 返回直接存在于此元素上的所有注解，注意，不包括父类的注解，调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响，没有则返回长度为0的数组 |\n\n简单案例演示如下：\n\n```java\npackage com.zejian.annotationdemo;\n\nimport java.lang.annotation.Annotation;\nimport java.util.Arrays;\n@DocumentA\nclass A{ }\n\n//继承了A类\n@DocumentB\npublic class DocumentDemo extends A{\n\t\tpublic static void main(String... args){\n        Class<?> clazz = DocumentDemo.class;\n        //根据指定注解类型获取该注解\n        DocumentA documentA=clazz.getAnnotation(DocumentA.class);\n        System.out.println(\"A:\"+documentA);\n\n        //获取该元素上的所有注解，包含从父类继承\n        Annotation[] an= clazz.getAnnotations();\n        System.out.println(\"an:\"+ Arrays.toString(an));\n        //获取该元素上的所有注解，但不包含继承！\n        Annotation[] an2=clazz.getDeclaredAnnotations();\n        System.out.println(\"an2:\"+ Arrays.toString(an2));\n\n        //判断注解DocumentA是否在该元素上\n        boolean b=clazz.isAnnotationPresent(DocumentA.class);\n        System.out.println(\"b:\"+b);\n\n        /**\n         * 执行结果:\n         A:@com.zejian.annotationdemo.DocumentA()\n         an:[@com.zejian.annotationdemo.DocumentA(), @com.zejian.annotationdemo.DocumentB()]\n         an2:@com.zejian.annotationdemo.DocumentB()\n         b:true\n         */\n\t\t}\n}\n```\n### 4.运行时注解处理器\n\n了解完注解与反射的相关API后，现在通过一个实例（该例子是博主改编自《Tinking in Java》）来演示利用运行时注解来组装数据库SQL的构建语句的过程\n\n```java\n/**\n * 表注解\n */\n@Target(ElementType.TYPE)//只能应用于类上\n@Retention(RetentionPolicy.RUNTIME)//保存到运行时\npublic @interface DBTable {\n    String name() default \"\";\n}\n\n\n/**\n * 注解Integer类型的字段\n */\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface SQLInteger {\n    //该字段对应数据库表列名\n    String name() default \"\";\n    //嵌套注解\n    Constraints constraint() default @Constraints;\n}\n\n\n/**\n * 注解String类型的字段\n */\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface SQLString {\n\n    //对应数据库表的列名\n    String name() default \"\";\n\n    //列类型分配的长度，如varchar(30)的30\n    int value() default 0;\n\n    Constraints constraint() default @Constraints;\n}\n\n\n/**\n * 约束注解\n */\n\n@Target(ElementType.FIELD)//只能应用在字段上\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Constraints {\n    //判断是否作为主键约束\n    boolean primaryKey() default false;\n    //判断是否允许为null\n    boolean allowNull() default false;\n    //判断是否唯一\n    boolean unique() default false;\n}\n\n/**\n * 数据库表Member对应实例类bean\n */\n@DBTable(name = \"MEMBER\")\npublic class Member {\n    //主键ID\n    @SQLString(name = \"ID\",value = 50, constraint = @Constraints(primaryKey = true))\n    private String id;\n\n    @SQLString(name = \"NAME\" , value = 30)\n    private String name;\n\n    @SQLInteger(name = \"AGE\")\n    private int age;\n\n    @SQLString(name = \"DESCRIPTION\" ,value = 150 , constraint = @Constraints(allowNull = true))\n    private String description;//个人描述\n\n   //省略set get.....\n}\n```\n\n上述定义4个注解，分别是@DBTable(用于类上)、@Constraints(用于字段上)、 @SQLString(用于字段上)、@SQLString(用于字段上)并在Member类中使用这些注解，这些注解的作用的是用于帮助注解处理器生成创建数据库表MEMBER的构建语句，在这里有点需要注意的是，我们使用了嵌套注解@Constraints，该注解主要用于判断字段是否为null或者字段是否唯一。必须清楚认识到上述提供的注解生命周期必须为@Retention(RetentionPolicy.RUNTIME)，即运行时，这样才可以使用反射机制获取其信息。有了上述注解和使用，剩余的就是编写上述的注解处理器了，前面我们聊了很多注解，其处理器要么是Java自身已提供、要么是框架已提供的，我们自己都没有涉及到注解处理器的编写，但上述定义处理SQL的注解，其处理器必须由我们自己编写了，如下\n\n```java\npackage com.zejian.annotationdemo;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 运行时注解处理器，构造表创建语句\n */\npublic class TableCreator {\n\n  public static String createTableSql(String className) throws ClassNotFoundException {\n    Class<?> cl = Class.forName(className);\n    DBTable dbTable = cl.getAnnotation(DBTable.class);\n    //如果没有表注解，直接返回\n    if(dbTable == null) {\n      System.out.println(\n              \"No DBTable annotations in class \" + className);\n      return null;\n    }\n    String tableName = dbTable.name();\n    // If the name is empty, use the Class name:\n    if(tableName.length() < 1)\n      tableName = cl.getName().toUpperCase();\n    List<String> columnDefs = new ArrayList<String>();\n    //通过Class类API获取到所有成员字段\n    for(Field field : cl.getDeclaredFields()) {\n      String columnName = null;\n      //获取字段上的注解\n      Annotation[] anns = field.getDeclaredAnnotations();\n      if(anns.length < 1)\n        continue; // Not a db table column\n\n      //判断注解类型\n      if(anns[0] instanceof SQLInteger) {\n        SQLInteger sInt = (SQLInteger) anns[0];\n        //获取字段对应列名称，如果没有就是使用字段名称替代\n        if(sInt.name().length() < 1)\n          columnName = field.getName().toUpperCase();\n        else\n          columnName = sInt.name();\n        //构建语句\n        columnDefs.add(columnName + \" INT\" +\n                getConstraints(sInt.constraint()));\n      }\n      //判断String类型\n      if(anns[0] instanceof SQLString) {\n        SQLString sString = (SQLString) anns[0];\n        // Use field name if name not specified.\n        if(sString.name().length() < 1)\n          columnName = field.getName().toUpperCase();\n        else\n          columnName = sString.name();\n        columnDefs.add(columnName + \" VARCHAR(\" +\n                sString.value() + \")\" +\n                getConstraints(sString.constraint()));\n      }\n\n\n    }\n    //数据库表构建语句\n    StringBuilder createCommand = new StringBuilder(\n            \"CREATE TABLE \" + tableName + \"(\");\n    for(String columnDef : columnDefs)\n      createCommand.append(\"\\n    \" + columnDef + \",\");\n\n    // Remove trailing comma\n    String tableCreate = createCommand.substring(\n            0, createCommand.length() - 1) + \");\";\n    return tableCreate;\n  }\n\n\n    /**\n     * 判断该字段是否有其他约束\n     * @param con\n     * @return\n     */\n  private static String getConstraints(Constraints con) {\n    String constraints = \"\";\n    if(!con.allowNull())\n      constraints += \" NOT NULL\";\n    if(con.primaryKey())\n      constraints += \" PRIMARY KEY\";\n    if(con.unique())\n      constraints += \" UNIQUE\";\n    return constraints;\n  }\n\n  public static void main(String[] args) throws Exception {\n    String[] arg={\"com.zejian.annotationdemo.Member\"};\n    for(String className : arg) {\n      System.out.println(\"Table Creation SQL for \" +\n              className + \" is :\\n\" + createTableSql(className));\n    }\n\n    /**\n     * 输出结果：\n     Table Creation SQL for com.zejian.annotationdemo.Member is :\n     CREATE TABLE MEMBER(\n     ID VARCHAR(50) NOT NULL PRIMARY KEY,\n     NAME VARCHAR(30) NOT NULL,\n     AGE INT NOT NULL,\n     DESCRIPTION VARCHAR(150)\n     );\n     */\n  }\n}\n```\n\n如果对反射比较熟悉的同学，上述代码就相对简单了，我们通过传递Member的全路径后通过Class.forName()方法获取到Member的class对象，然后利用Class对象中的方法获取所有成员字段Field，最后利用field.getDeclaredAnnotations()遍历每个Field上的注解再通过注解的类型判断来构建建表的SQL语句。这便是利用注解结合反射来构建SQL语句的简单的处理器模型，是否已回想起Hibernate？\n\n### 5.Java 8中注解增强\n\n#### 5.1、元注解@Repeatable\n\n元注解@Repeatable是JDK1.8新加入的，它表示在同一个位置重复相同的注解。在没有该注解前，一般是无法在同一个类型上使用相同的注解的\n\n```java\n//Java8前无法这样使用\n@FilterPath(\"/web/update\")\n@FilterPath(\"/web/add\")\npublic class A {}\n```\n\nJava8前如果是想实现类似的功能，我们需要在定义@FilterPath注解时定义一个数组元素接收多个值如下\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface FilterPath {\n    String [] value();\n}\n\n//使用\n@FilterPath({\"/update\",\"/add\"})\npublic class A { }\n```\n\n但在Java8新增了@Repeatable注解后就可以采用如下的方式定义并使用了\n\n```java\npackage com.zejian.annotationdemo;\n\nimport java.lang.annotation.*;\n\n//使用Java8新增@Repeatable原注解\n@Target({ElementType.TYPE,ElementType.FIELD,ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Repeatable(FilterPaths.class)//参数指明接收的注解class\npublic @interface FilterPath {\n    String  value();\n}\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@interface FilterPaths {\n    FilterPath[] value();\n}\n\n//使用案例\n@FilterPath(\"/web/update\")\n@FilterPath(\"/web/add\")\n@FilterPath(\"/web/delete\")\nclass AA{ }\n```\n\n我们可以简单理解为通过使用@Repeatable后，将使用@FilterPaths注解作为接收同一个类型上重复注解的容器，而每个@FilterPath则负责保存指定的路径串。为了处理上述的新增注解，Java8还在AnnotatedElement接口新增了getDeclaredAnnotationsByType() 和 getAnnotationsByType()两个方法并在接口给出了默认实现，在指定@Repeatable的注解时，可以通过这两个方法获取到注解相关信息。但请注意，旧版API中的getDeclaredAnnotation()和 getAnnotation()是不对@Repeatable注解的处理的(除非该注解没有在同一个声明上重复出现)。注意getDeclaredAnnotationsByType方法获取到的注解不包括父类，其实当 getAnnotationsByType()方法调用时，其内部先执行了getDeclaredAnnotationsByType方法，只有当前类不存在指定注解时，getAnnotationsByType()才会继续从其父类寻找，但请注意如果@FilterPath和@FilterPaths没有使用了@Inherited的话，仍然无法获取。下面通过代码来演示：\n\n```java\n/**\n * Created by zejian on 2017/5/20.\n * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]\n */\n//使用Java8新增@Repeatable原注解\n@Target({ElementType.TYPE,ElementType.FIELD,ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Repeatable(FilterPaths.class)\npublic @interface FilterPath {\n    String  value();\n}\n\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@interface FilterPaths {\n    FilterPath[] value();\n}\n\n@FilterPath(\"/web/list\")\nclass CC { }\n\n//使用案例\n@FilterPath(\"/web/update\")\n@FilterPath(\"/web/add\")\n@FilterPath(\"/web/delete\")\nclass AA extends CC{\n    public static void main(String[] args) {\n\n        Class<?> clazz = AA.class;\n        //通过getAnnotationsByType方法获取所有重复注解\n        FilterPath[] annotationsByType = clazz.getAnnotationsByType(FilterPath.class);\n        FilterPath[] annotationsByType2 = clazz.getDeclaredAnnotationsByType(FilterPath.class);\n        if (annotationsByType != null) {\n            for (FilterPath filter : annotationsByType) {\n                System.out.println(\"1:\"+filter.value());\n            }\n        }\n\n        System.out.println(\"-----------------\");\n\n        if (annotationsByType2 != null) {\n            for (FilterPath filter : annotationsByType2) {\n                System.out.println(\"2:\"+filter.value());\n            }\n        }\n\n\n        System.out.println(\"使用getAnnotation的结果:\"+clazz.getAnnotation(FilterPath.class));\n\n\n        /**\n         * 执行结果(当前类拥有该注解FilterPath,则不会从CC父类寻找)\n         1:/web/update\n         1:/web/add\n         1:/web/delete\n         -----------------\n         2:/web/update\n         2:/web/add\n         2:/web/delete\n         使用getAnnotation的结果:null\n         */\n    }\n}\n```\n\n从执行结果来看如果当前类拥有该注解@FilterPath,则getAnnotationsByType方法不会从CC父类寻找，下面看看另外一种情况，即AA类上没有@FilterPath注解\n\n```java\n//使用Java8新增@Repeatable原注解\n@Target({ElementType.TYPE,ElementType.FIELD,ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited //添加可继承元注解\n@Repeatable(FilterPaths.class)\npublic @interface FilterPath {\n    String  value();\n}\n\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited //添加可继承元注解\n@interface FilterPaths {\n    FilterPath[] value();\n}\n\n@FilterPath(\"/web/list\")\n@FilterPath(\"/web/getList\")\nclass CC { }\n\n//AA上不使用@FilterPath注解,getAnnotationsByType将会从父类查询\nclass AA extends CC{\n    public static void main(String[] args) {\n\n        Class<?> clazz = AA.class;\n        //通过getAnnotationsByType方法获取所有重复注解\n        FilterPath[] annotationsByType = clazz.getAnnotationsByType(FilterPath.class);\n        FilterPath[] annotationsByType2 = clazz.getDeclaredAnnotationsByType(FilterPath.class);\n        if (annotationsByType != null) {\n            for (FilterPath filter : annotationsByType) {\n                System.out.println(\"1:\"+filter.value());\n            }\n        }\n\n        System.out.println(\"-----------------\");\n\n        if (annotationsByType2 != null) {\n            for (FilterPath filter : annotationsByType2) {\n                System.out.println(\"2:\"+filter.value());\n            }\n        }\n\n\n        System.out.println(\"使用getAnnotation的结果:\"+clazz.getAnnotation(FilterPath.class));\n\n\n        /**\n         * 执行结果(当前类没有@FilterPath,getAnnotationsByType方法从CC父类寻找)\n         1:/web/list\n         1:/web/getList\n         -----------------\n         使用getAnnotation的结果:null\n         */\n    }\n}\n```\n\n注意定义@FilterPath和@FilterPath时必须指明@Inherited，getAnnotationsByType方法否则依旧无法从父类获取@FilterPath注解，这是为什么呢，不妨看看getAnnotationsByType方法的实现源码：\n\n```java\n//接口默认实现方法\ndefault <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass) {\n//先调用getDeclaredAnnotationsByType方法\nT[] result = getDeclaredAnnotationsByType(annotationClass);\n\n//判断当前类获取到的注解数组是否为0\nif (result.length == 0 && this instanceof Class && \n//判断定义注解上是否使用了@Inherited元注解 \n AnnotationType.getInstance(annotationClass).isInherited()) { // Inheritable\n        //从父类获取\n       Class<?> superClass = ((Class<?>) this).getSuperclass();\n   if (superClass != null) {\n      result = superClass.getAnnotationsByType(annotationClass);\n       }\n   }\n\n   return result;\n}\n```\n\n#### 5.2、新增的两种ElementType\n\n在Java8中 ElementType 新增两个枚举成员，TYPE_PARAMETER 和 TYPE_USE ，在Java8前注解只能标注在一个声明(如字段、类、方法)上，Java8后，新增的TYPE_PARAMETER可以用于标注类型参数，而TYPE_USE则可以用于标注任意类型(不包括class)。如下所示\n\n```java\n//TYPE_PARAMETER 标注在类型参数上\nclass D<@Parameter T> { }\n\n//TYPE_USE则可以用于标注任意类型(不包括class)\n//用于父类或者接口\nclass Image implements @Rectangular Shape { }\n\n//用于构造函数\nnew @Path String(\"/usr/bin\")\n\n//用于强制转换和instanceof检查,注意这些注解中用于外部工具，它们不会对类型转换或者instanceof的检查行为带来任何影响。\nString path=(@Path String)input;\nif(input instanceof @Path String)\n\n//用于指定异常\npublic Person read() throws @Localized IOException.\n\n//用于通配符绑定\nList<@ReadOnly ? extends Person>\nList<? extends @ReadOnly Person>\n\n@NotNull String.class //非法，不能标注class\nimport java.lang.@NotNull String //非法，不能标注import\n```\n\n这里主要说明一下TYPE_USE，类型注解用来支持在Java的程序中做强类型检查，配合第三方插件工具（如Checker Framework），可以在编译期检测出runtime error（如UnsupportedOperationException、NullPointerException异常），避免异常延续到运行期才发现，从而提高代码质量，这就是类型注解的主要作用。总之Java 8 新增加了两个注解的元素类型ElementType.TYPE_USE 和ElementType.TYPE_PARAMETER ，通过它们，我们可以把注解应用到各种新场合中。\n\n","tags":["Java"]},{"title":"Android知识(四)--图片信息之ExifInterface","url":"/2018/03/01/Android知识-四-图片信息之ExifInterface/","content":"\n### 1、Exif-ExifInterface简介 \n\n​\tExif是一种图像文件格式，它的数据存储与JPEG格式是完全相同的。实际上Exif格式就是在JPEG格式头部插入了数码照片的信息，包括拍摄时的光圈、快门、白平衡、ISO、焦距、日期时间等各种和拍摄条件以及相机品牌、型号、色彩编码、拍摄时录制的声音以及GPS全球定位系统数据、缩略图等。你可以利用任何可以查看JPEG文件的看图软件浏览Exif格式的照片，但并不是所有的图形程序都能处理Exif信息。今天这篇文章就来讲讲Android中操作Exif。\n\n### 2、ExifInterface中的功能简单进行介绍 \n\n​\tAndroid开发中，在对图片进行展示、编辑、发送等操作时经常会涉及Exif的操作，Android中操作Exif主要是通过ExifInterface，ExifInterface看上去是一个接口，其实是一个类，位于Android.media.ExifInterface的位置。进入ExifInterface类，发现方法很少，主要就是三个方面：读取、写入、缩略图。\n\n### 3、ExifInterface进行读取操作\n\n​\tExif信息在文件头中是以二进制的形式存储的，存储的字段名称和字段值格式都是固定的。我测试的Android23（6.0）版本中，总共有26个Exif字段，其中TAG_SUBSECTIME被加上了@hide注解，也就是还剩25个，我写了个demo，获取这25个字段的值，看看都是什么样的格式。\n\n```java\nExifInterface exifInterface = new ExifInterface(filePath);\n\nString orientation = exifInterface.getAttribute(ExifInterface.TAG_ORIENTATION);\nString dateTime = exifInterface.getAttribute(ExifInterface.TAG_DATETIME);\nString make = exifInterface.getAttribute(ExifInterface.TAG_MAKE);\nString model = exifInterface.getAttribute(ExifInterface.TAG_MODEL);\nString flash = exifInterface.getAttribute(ExifInterface.TAG_FLASH);\nString imageLength = exifInterface.getAttribute(ExifInterface.TAG_IMAGE_LENGTH);\nString imageWidth = exifInterface.getAttribute(ExifInterface.TAG_IMAGE_WIDTH);\nString latitude = exifInterface.getAttribute(ExifInterface.TAG_GPS_LATITUDE);\nString longitude = exifInterface.getAttribute(ExifInterface.TAG_GPS_LONGITUDE);\nString latitudeRef = exifInterface.getAttribute(ExifInterface.TAG_GPS_LATITUDE_REF);\nString longitudeRef = exifInterface.getAttribute(ExifInterface.TAG_GPS_LONGITUDE_REF);\nString exposureTime = exifInterface.getAttribute(ExifInterface.TAG_EXPOSURE_TIME);\nString aperture = exifInterface.getAttribute(ExifInterface.TAG_APERTURE);\nString isoSpeedRatings = exifInterface.getAttribute(ExifInterface.TAG_ISO);\nString dateTimeDigitized = exifInterface.getAttribute(ExifInterface.TAG_DATETIME_DIGITIZED);\nString subSecTime = exifInterface.getAttribute(ExifInterface.TAG_SUBSEC_TIME);\nString subSecTimeOrig = exifInterface.getAttribute(ExifInterface.TAG_SUBSEC_TIME_ORIG);\nString subSecTimeDig = exifInterface.getAttribute(ExifInterface.TAG_SUBSEC_TIME_DIG);\nString altitude = exifInterface.getAttribute(ExifInterface.TAG_GPS_ALTITUDE);\nString altitudeRef = exifInterface.getAttribute(ExifInterface.TAG_GPS_ALTITUDE_REF);\nString gpsTimeStamp = exifInterface.getAttribute(ExifInterface.TAG_GPS_TIMESTAMP);\nString gpsDateStamp = exifInterface.getAttribute(ExifInterface.TAG_GPS_DATESTAMP);\nString whiteBalance = exifInterface.getAttribute(ExifInterface.TAG_WHITE_BALANCE);\nString focalLength = exifInterface.getAttribute(ExifInterface.TAG_FOCAL_LENGTH);\nString processingMethod = exifInterface.getAttribute(ExifInterface.TAG_GPS_PROCESSING_METHOD);\n\nLog.e(\"TAG\", \"## orientation=\" + orientation);\nLog.e(\"TAG\", \"## dateTime=\" + dateTime);\nLog.e(\"TAG\", \"## make=\" + make);\nLog.e(\"TAG\", \"## model=\" + model);\nLog.e(\"TAG\", \"## flash=\" + flash);\nLog.e(\"TAG\", \"## imageLength=\" + imageLength);\nLog.e(\"TAG\", \"## imageWidth=\" + imageWidth);\nLog.e(\"TAG\", \"## latitude=\" + latitude);\nLog.e(\"TAG\", \"## longitude=\" + longitude);\nLog.e(\"TAG\", \"## latitudeRef=\" + latitudeRef);\nLog.e(\"TAG\", \"## longitudeRef=\" + longitudeRef);\nLog.e(\"TAG\", \"## exposureTime=\" + exposureTime);\nLog.e(\"TAG\", \"## aperture=\" + aperture);\nLog.e(\"TAG\", \"## isoSpeedRatings=\" + isoSpeedRatings);\nLog.e(\"TAG\", \"## dateTimeDigitized=\" + dateTimeDigitized);\nLog.e(\"TAG\", \"## subSecTime=\" + subSecTime);\nLog.e(\"TAG\", \"## subSecTimeOrig=\" + subSecTimeOrig);\nLog.e(\"TAG\", \"## subSecTimeDig=\" + subSecTimeDig);\nLog.e(\"TAG\", \"## altitude=\" + altitude);\nLog.e(\"TAG\", \"## altitudeRef=\" + altitudeRef);\nLog.e(\"TAG\", \"## gpsTimeStamp=\" + gpsTimeStamp);\nLog.e(\"TAG\", \"## gpsDateStamp=\" + gpsDateStamp);\nLog.e(\"TAG\", \"## whiteBalance=\" + whiteBalance);\nLog.e(\"TAG\", \"## focalLength=\" + focalLength);\nLog.e(\"TAG\", \"## processingMethod=\" + processingMethod);\n```\n\n打印的结果\n\n```java\nE/TAG: ## orientation=0\nE/TAG: ## dateTime=2016:05:23 17:30:11\nE/TAG: ## make=Xiaomi\nE/TAG: ## model=Mi-4c\nE/TAG: ## flash=16\nE/TAG: ## imageLength=4160\nE/TAG: ## imageWidth=3120\nE/TAG: ## latitude=31/1,58/1,253560/10000\nE/TAG: ## longitude=118/1,44/1,491207/10000\nE/TAG: ## latitudeRef=N\nE/TAG: ## longitudeRef=E\nE/TAG: ## exposureTime=0.050\nE/TAG: ## aperture=2.0\nE/TAG: ## iso=636\nE/TAG: ## dateTimeDigitized=2016:05:23 17:30:11\nE/TAG: ## subSecTime=379693\nE/TAG: ## subSecTimeOrig=379693\nE/TAG: ## subSecTimeDig=379693\nE/TAG: ## altitude=0/1000\nE/TAG: ## altitudeRef=0\nE/TAG: ## gpsTimeStamp=9:30:8\nE/TAG: ## gpsDateStamp=2016:05:23\nE/TAG: ## whiteBalance=0\nE/TAG: ## focalLength=412/100\nE/TAG: ## processingMethod=NETWORK\n```\n\n这25个字段分别是代表什么呢？\n\n```java\nExifInterface.TAG_ORIENTATION //旋转角度，整形表示，在ExifInterface中有常量对应表示\nExifInterface.TAG_DATETIME //拍摄时间，取决于设备设置的时间\nExifInterface.TAG_MAKE //设备品牌\nExifInterface.TAG_MODEL //设备型号，整形表示，在ExifInterface中有常量对应表示\nExifInterface.TAG_FLASH //闪光灯\nExifInterface.TAG_IMAGE_LENGTH //图片高度\nExifInterface.TAG_IMAGE_WIDTH //图片宽度\nExifInterface.TAG_GPS_LATITUDE //纬度\nExifInterface.TAG_GPS_LONGITUDE //经度\nExifInterface.TAG_GPS_LATITUDE_REF //纬度名（N or S）\nExifInterface.TAG_GPS_LONGITUDE_REF //经度名（E or W）\nExifInterface.TAG_EXPOSURE_TIME //曝光时间\nExifInterface.TAG_APERTURE //光圈值\nExifInterface.TAG_ISO //ISO感光度\nExifInterface.TAG_DATETIME_DIGITIZED //数字化时间\nExifInterface.TAG_SUBSEC_TIME //\nExifInterface.TAG_SUBSEC_TIME_ORIG //\nExifInterface.TAG_SUBSEC_TIME_DIG //\nExifInterface.TAG_GPS_ALTITUDE //海拔高度\nExifInterface.TAG_GPS_ALTITUDE_REF //海拔高度\nExifInterface.TAG_GPS_TIMESTAMP //时间戳\nExifInterface.TAG_GPS_DATESTAMP //日期戳\nExifInterface.TAG_WHITE_BALANCE //白平衡\nExifInterface.TAG_FOCAL_LENGTH //焦距\nExifInterface.TAG_GPS_PROCESSING_METHOD //用于定位查找的全球定位系统处理方法。\n```\n\n其中TAG_SUBSEC_TIME 、TAG_SUBSEC_TIME_ORIG 、TAG_SUBSEC_TIME_DIG 没有加注释，我也没查清楚具体是什么意思，但是看log，三个值是一样的。有知道的朋友可以跟我说下，谢谢！\n\n细心的朋友会发现，上面所有的取值都是用的一个方法：exifInterface.getAttribute(String tag)，其实ExifInterface还提供了其它方法。\n\n```java\nexifInterface.getAltitude(long default); //返回海拔高度，单位米，如果exif的tag不存在，返回默认值。 \nexifInterface.getAttributeDouble(String tag, Double default) //返回double值，传入默认值 \nexifInterface.getAttributeInt(String tag, int default) //返回int值，传入默认值 \nexifInterface.getLatLong(float[] value) //返回纬度和经度，数组第一个是纬度，第二个是经度\n```\n\n### 4、ExifInterface进行写入操作\n\n相对读取，写入就简单很多了。\n\n```java\nExifInterface exifInterface = new ExifInterface(filePath);\nexifInterface.setAttribute(ExifInterface.TAG_GPS_ALTITUDE,\"1/1000\");\nexifInterface.setAttribute(ExifInterface.TAG_ORIENTATION,\"6\");\nexifInterface.setAttribute(ExifInterface.TAG_IMAGE_WIDTH,\"2000\");\nexifInterface.saveAttributes();\n```\n\n代码很简答，但有一点需要说下，setAttributes只是设置属性值，没有保存，saveAttributes才真正保存，但是这个方法比较耗时，不要每set一次都save，全部set完后，再统一save一次。 \n\n有一点很尴尬，saveAttributes()这个方法内部会遍历保存所有的值，哪怕你只改变了其中一个值。\n\n### 5、ExifInterface获取缩略图\n\ngetThumbnail()这个方法可以生成一个缩略图，返回一个字节数组，得到字节数组就可以轻松生成Bitmap。\n\n但是在调用这个方法前，最好先调用exifInterface.hasThumbnail()判断一下是否有缩略图。\n\ngetThumbnail()这个方法调用的是native方法，所以具体的实现就看不到了，我也不知道生成的缩略图的分辨率是多少。到这里，ExifInterface的使用介绍以及完毕。\n\n### 6、在ExifInterface获取的信息中进行添加到图片\n\n#### 步骤一\n\n我们在布局文件中activity_main.xml中的代码，创建一个控件\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:id=\"@+id/activity_main\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n\ttools:context=\"com.yoyoyt.exifinterfacedemo.MainActivity\">\n    <ImageView\n        android:id=\"@+id/imageview\"\n        android:layout_width=\"500dp\"\n        android:layout_height=\"300dp\"/>\n</RelativeLayout>\n```\n#### 步骤二\n\n我们在MainActivity中找的控制，并获取信息，将信息添加到图片上面。并显示在控件上，具体代码如下：\n\n```java\npackage com.zalex.exifinterfacedemo;\n\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.Rect;\nimport android.graphics.Typeface;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.ExifInterface;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.support.v7.app.AppCompatActivity;\nimport android.util.Log;\nimport android.widget.ImageView;\nimport android.widget.Toast;\n\npublic class MainActivity extends AppCompatActivity {\n   \n        //获取加载图片的路径\nString path = Environment.getExternalStorageDirectory().getPath() + \"/DCIM/Camera/IMG_20160927_135402.jpg\";\nprivate String width;\nprivate String height;\nprivate Bitmap bitmap;\nprivate Bitmap imgTemp;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    //找到控件的id\n    ImageView iv= (ImageView) findViewById(R.id.imageview);\n    bitmap = BitmapFactory.decodeFile(path);//        iv.setImageBitmap(bitmap);\n         //android读取图片EXIF信息\n    try {\n        ExifInterface exifInterface=new ExifInterface(path);\n      //         执行保存\n            exifInterface.saveAttributes();\n            //获取图片的方向\n            String orientation = exifInterface.getAttribute(ExifInterface.TAG_ORIENTATION);\n            //获取图片的时间\n            String dateTime = exifInterface.getAttribute(ExifInterface.TAG_DATETIME);\n            String make = exifInterface.getAttribute(ExifInterface.TAG_MAKE);\n            String model = exifInterface.getAttribute(ExifInterface.TAG_MODEL);\n            String flash = exifInterface.getAttribute(ExifInterface.TAG_FLASH);\n             height = exifInterface.getAttribute(ExifInterface.TAG_IMAGE_LENGTH);\n             width = exifInterface.getAttribute(ExifInterface.TAG_IMAGE_WIDTH);\n            String latitude = exifInterface.getAttribute(ExifInterface.TAG_GPS_LATITUDE);\n            String longitude = exifInterface.getAttribute(ExifInterface.TAG_GPS_LONGITUDE);\n        StringBuilder sb = new StringBuilder();\n        sb.append(longitude)\n                .append(latitude);\n\n        Log.e(\"TAG\", \"## orientation=\" + orientation);\n        Log.e(\"TAG\", \"## dateTime=\" + dateTime);\n        Log.e(\"TAG\", \"## make=\" + make);\n        Log.e(\"TAG\", \"## model=\" + model);\n        Log.e(\"TAG\", \"## flash=\" + flash);\n        Log.e(\"TAG\", \"## imageLength=\" + height);\n        Log.e(\"TAG\", \"## imageWidth=\" + width);\n        Log.e(\"TAG\", \"## latitude=\" + latitude);\n        Log.e(\"TAG\", \"## longitude=\" + longitude);\n        String driving_name=\"驾校名称:东方时尚驾校\";\n        String coach=\"教练员姓名:张三\";\n        String lerner=\"学员姓名:李四\";\n        String time=\"采集时间:2016\";\n        String car_number=\"车牌号:京RF8900786\";\n        String longt=\"102.00\";\n        String lat=\"35.5\";\n        String car_speed=\"车辆行驶速度:20km/h\";\n\n        Toast.makeText(MainActivity.this,sb, Toast.LENGTH_LONG).show();\n        Drawable drawable = createDrawable(driving_name,coach,lerner,time,car_number,longt,lat,car_speed);\n        iv.setBackgroundDrawable(drawable);\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n}\n\n// 穿件带字母的标记图片\nprivate Drawable createDrawable(String driving_name, String coach, String lerner, String time, String car_number, String longt, String lat, String car_speed) {\n    imgTemp = Bitmap.createBitmap(Integer.valueOf(width), Integer.valueOf(height), Bitmap.Config.ARGB_8888);\n    Canvas canvas = new Canvas(imgTemp);\n    Paint paint = new Paint(); // 建立画笔\n    paint.setDither(true);\n    paint.setFilterBitmap(true);\n    Rect src = new Rect(0, 0,Integer.valueOf(width), Integer.valueOf(height));\n    Rect dst = new Rect(0, 0, Integer.valueOf(width), Integer.valueOf(height));\n    canvas.drawBitmap(bitmap, src, dst, paint);\n\n    Paint textPaint = new Paint(Paint.ANTI_ALIAS_FLAG\n            | Paint.DEV_KERN_TEXT_FLAG);\n    textPaint.setTextSize(100.0f);\n    textPaint.setTypeface(Typeface.DEFAULT_BOLD); // 采用默认的宽度\n    textPaint.setColor(Color.WHITE);\n\n    canvas.drawText(driving_name,Integer.valueOf(width)/100, Integer.valueOf(height)/8,\n            textPaint);\n    canvas.drawText(coach,0, (Integer.valueOf(height)/8)+100,textPaint);\n    canvas.drawText(lerner,0,(Integer.valueOf(height)/8)+200,textPaint);\n    canvas.drawText(time,0,(Integer.valueOf(height)/8)+300,textPaint);\n    canvas.drawText(car_number,0,(Integer.valueOf(height)/8)+400,textPaint);\n    canvas.drawText(longt,0,(Integer.valueOf(height)/8)+500,textPaint);\n    canvas.drawText(lat,0,(Integer.valueOf(height)/8)+600,textPaint);\n    canvas.drawText(car_speed,0,(Integer.valueOf(height)/8)+700,textPaint);\n    canvas.save(Canvas.ALL_SAVE_FLAG);\n    canvas.restore();\n\n    return (Drawable) new BitmapDrawable(getResources(), imgTemp);\n\n}\n}\n```\n\n#### 步骤三\n\n最后，我们在配置文件中进行添加权限\n\n```xml\n <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/>\n <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"/>\n <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n```\n\n","tags":["Android"]},{"title":"Android知识(三)--RecyclerView深入解析","url":"/2018/02/27/Android知识-三-RecyclerView深入解析/","content":"\n1、简介\n\n​\t本文将从RecyclerView实现原理并结合源码详细分析这个强大的控件\n\n2、基本使用\n\n​\tRecyclerView的基本使用并不复杂，只需要提供一个RecyclerView.Apdater的实现用于处理数据集与ItemView的绑定关系，和一个RecyclerView.LayoutManager的实现用于测量并布局ItemView。\n\n3、绘制流程\n\n​\t众所周知，android控件的绘制可以分为3个步骤：[measure、layout、draw](https://alex0605.github.io/2018/02/25/Android%E7%9F%A5%E8%AF%86-%E4%BA%8C-View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/)。RecyclerView的绘制自然也经这3个步骤。但是，RecyclerView将它的measure与layout过程委托给了RecyclerView.LayoutManager来处理，并且，它对子控件的measure及layout过程是逐个处理的，也就是说，执行完成一个子控件的measure及layout过程再去执行下一个。下面看下这段代码：\n\n```java\nprotected void onMeasure(int widthSpec, int heightSpec) {\n    ...\n    if (mLayout.mAutoMeasure) {\n        final int widthMode = MeasureSpec.getMode(widthSpec);\n        final int heightMode = MeasureSpec.getMode(heightSpec);\n        final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY\n                && heightMode == MeasureSpec.EXACTLY;\n        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n        if (skipMeasure || mAdapter == null) {\n            return;\n        }\n        ...\n        dispatchLayoutStep2();\n        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);\n        ...\n    } else {\n        ...\n    }\n}\n```\n\n这是RecyclerView的测量方法，再看下dispatchLayoutStep2()方法：\n\n```java\nprivate void dispatchLayoutStep2() {\n    ...\n    mLayout.onLayoutChildren(mRecycler, mState);\n    ...\n}\n```\n\n​\t上面的mLayout就是一个RecyclerView.LayoutManager实例。通过以上代码（和方法名称），不难推断出，RecyclerView的measure及layout过程委托给了RecyclerView.LayoutManager。接着看onLayoutChildren方法，在兼容包中提供了3个RecyclerView.LayoutManager的实现，这里我就只以LinearLayoutManager来举例说明：\n\n```java\npublic void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n    // layout algorithm:\n    // 1) by checking children and other variables, find an anchor coordinate and an anchor\n    //  item position.\n    // 2) fill towards start, stacking from bottom\n    // 3) fill towards end, stacking from top\n    // 4) scroll to fulfill requirements like stack from bottom.\n    ...\n    mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;\n    // calculate anchor position and coordinate\n    updateAnchorInfoForLayout(recycler, state, mAnchorInfo);\n    ...\n    if (mAnchorInfo.mLayoutFromEnd) {\n        ...\n    } else {\n        // fill towards end\n        updateLayoutStateToFillEnd(mAnchorInfo);\n        mLayoutState.mExtra = extraForEnd;\n        fill(recycler, mLayoutState, state, false);\n        endOffset = mLayoutState.mOffset;\n        final int lastElement = mLayoutState.mCurrentPosition;\n        if (mLayoutState.mAvailable > 0) {\n            extraForStart += mLayoutState.mAvailable;\n        }\n        // fill towards start\n        updateLayoutStateToFillStart(mAnchorInfo);\n        mLayoutState.mExtra = extraForStart;\n        mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;\n        fill(recycler, mLayoutState, state, false);\n        startOffset = mLayoutState.mOffset;\n        ...\n    }\n    ...\n}\n```\n\n​\t源码中的注释部分我并没有略去，它已经解释了此处的逻辑了。这里我以垂直布局来说明，mAnchorInfo为布局锚点信息，包含了子控件在Y轴上起始绘制偏移量（coordinate），ItemView在Adapter中的索引位置（position）和布局方向（mLayoutFromEnd）——这里是指start、end方向。这部分代码的功能就是：确定布局锚点，以此为起点向开始和结束方向填充ItemView，如图所示：\n\n![recyclerview_layout](Android知识-三-RecyclerView深入解析/recyclerview_layout.png)\n\n​\t在上一段代码中，fill()方法的作用就是填充ItemView，而图（3）说明了，在上段代码中fill()方法调用2次的原因。虽然图（3）是更为普遍的情况，而且在实现填充ItemView算法时，也是按图（3）所示来实现的，但是mAnchorInfo在赋值过程(updateAnchorInfoForLayout)中，只会出现图（1）、图（2）所示情况。现在来看下fill()方法：\n\n```java\nint fill(RecyclerView.Recycler recycler, LayoutState layoutState,\n        RecyclerView.State state, boolean stopOnFocusable) {\n    ...\n    int remainingSpace = layoutState.mAvailable + layoutState.mExtra;\n    LayoutChunkResult layoutChunkResult = new LayoutChunkResult();\n    while (...&&layoutState.hasMore(state)) {\n        ...\n        layoutChunk(recycler, state, layoutState, layoutChunkResult);\n        ...\n        if (...) {\n            layoutState.mAvailable -= layoutChunkResult.mConsumed;\n            remainingSpace -= layoutChunkResult.mConsumed;\n        }\n        if (layoutState.mScrollingOffset != LayoutState.SCOLLING_OFFSET_NaN) {\n            layoutState.mScrollingOffset += layoutChunkResult.mConsumed;\n            if (layoutState.mAvailable < 0) {\n                layoutState.mScrollingOffset += layoutState.mAvailable;\n            }\n            recycleByLayoutState(recycler, layoutState);\n        }\n    }\n    ...\n}\n```\n\n下面是layoutChunk方法：\n\n```java\nvoid layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,\n        LayoutState layoutState, LayoutChunkResult result) {\n    View view = layoutState.next(recycler);\n    ...\n    if (layoutState.mScrapList == null) {\n        if (mShouldReverseLayout == (layoutState.mLayoutDirection\n                == LayoutState.LAYOUT_START)) {\n            addView(view);\n        } else {\n            addView(view, 0);\n        }\n    }\n    ...\n    measureChildWithMargins(view, 0, 0);\n    ...\n    // We calculate everything with View's bounding box (which includes decor and margins)\n    // To calculate correct layout position, we subtract margins.\n    layoutDecorated(view, left + params.leftMargin, top + params.topMargin,\n            right - params.rightMargin, bottom - params.bottomMargin);\n    ...\n}\n```\n\n​\t这里的addView()方法，其实就是ViewGroup的addView()方法；measureChildWithMargins()方法看名字就知道是用于测量子控件大小的，这里我先跳过这个方法的解释，放在后面来做，目前就简单地理解为测量子控件大小就好了。下面是layoutDecoreated()方法：\n\n```java\npublic void layoutDecorated(...) {\n    ...\n    child.layout(...);\n}\n```\n\n总结上面代码，在RecyclerView的measure及layout阶段，填充ItemView的算法为：向父容器增加子控件，测量子控件大小，布局子控件，布局锚点向当前布局方向平移子控件大小，重复上诉步骤至RecyclerView可绘制空间消耗完毕或子控件已全部填充。 \n　　这样所有的子控件的measure及layout过程就完成了。回到RecyclerView的onMeasure方法，执行mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec)这行代码的作用就是根据子控件的大小，设置RecyclerView的大小。至此，RecyclerView的measure和layout实际上已经完成了。 \n\n​\t但是，你有可能已经发现上面过程中的问题了：如何确定RecyclerView的可绘制空间？不过，如果你熟悉android控件的绘制机制的话，这就不是问题。其实，这里的可绘制空间，可以简单地理解为父容器的大小；更准确的描述是，父容器对RecyclerView的布局大小的要求，可以通过MeasureSpec.getSize()方法获得——这里不包括滑动情况，滑动情况会在后文描述。需要特别说明的是在23.2.0版本之前，RecyclerView是不支持WRAP_CONTENT的。先看下RecyclerView的onLayout()方法：\n\n```java\nprotected void onLayout(boolean changed, int l, int t, int r, int b) {\n    ...\n    dispatchLayout();\n    ...\n}\n```\n\n这是dispatchLayout方法：\n\n```java\nvoid dispatchLayout() {\n    ...\n    if (mState.mLayoutStep == State.STEP_START) {\n        dispatchLayoutStep1();\n        ...\n        dispatchLayoutStep2();\n    }\n    dispatchLayoutStep3();\n    ...\n}\n```\n\n​\t可以看出，这里也会执行子控件的measure及layout过程。结合onMeasure方法对skipMeasure的判断可以看出，如果要支持WRAP_CONTENT，那么子控件的measure及layout就会提前在RecyclerView的测量方法中执行完成，也就是说，先确定了子控件的大小及位置后，再由此设置RecyclerView的大小；如果是其它情况(测量模式为EXACTLY)，子控件的measure及layout过程就会延迟至RecyclerView的layout过程（RecyclerView.onLayout()）中执行。\n\n​\t再看onMeasure方法中的mLayout.mAutoMeasure，它表示，RecyclerView的measure及layout过程是否要委托给RecyclerView.LayoutManager，在兼容包中提供的３种RecyclerView.LayoutManager的这个属性默认都是为true的。好了，以上就是RecyclerView的measure及layout过程，下面来看下它的draw过程。\n\n​\tRecyclerView的draw过程可以分为２部分来看：RecyclerView负责绘制所有decoration；ItemView的绘制由ViewGroup处理，这里的绘制是android常规绘制逻辑，本文就不再阐述了。下面来看看RecyclerView的draw()和onDraw()方法：\n\n```java\n@Override\npublic void draw(Canvas c) {\n    super.draw(c);\n    final int count = mItemDecorations.size();\n    for (int i = 0; i < count; i++) {\n        mItemDecorations.get(i).onDrawOver(c, this, mState);\n    }\n    ...\n}\n@Override\npublic void onDraw(Canvas c) {\n    super.onDraw(c);\n    final int count = mItemDecorations.size();\n    for (int i = 0; i < count; i++) {\n        mItemDecorations.get(i).onDraw(c, this, mState);\n    }\n}\n```\n\n​\t可以看出对于decoration的绘制代码上十分简单。但是这里，我必须要抱怨一下RecyclerView.ItemDecoration的设计，它实在是太过于灵活了，虽然理论上我们可以使用它在RecyclerView内的任何地方绘制你想要的任何东西——到这一步，RecyclerView的大小位置已经确定的哦。但是过于灵活，太难使用，以至往往使我们无从下手。 好了，题外话就不多说了，来看看decoration的绘制吧。还记得上面提到过的measureChildWithMargins()方法吗？先来看看它：\n\n```java\npublic void measureChildWithMargins(View child, int widthUsed, int heightUsed) {\n        final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n    final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);\n    widthUsed += insets.left + insets.right;\n    heightUsed += insets.top + insets.bottom;\n\n    final int widthSpec = ...\n    final int heightSpec = ...\n    if (shouldMeasureChild(child, widthSpec, heightSpec, lp)) {\n        child.measure(widthSpec, heightSpec);\n    }\n}\n```\n这里是getItemDecorInsetsForChild()方法：\n\n```java\nRect getItemDecorInsetsForChild(View child) {\n    ...\n    final Rect insets = lp.mDecorInsets;\n    insets.set(0, 0, 0, 0);\n    final int decorCount = mItemDecorations.size();\n    for (int i = 0; i < decorCount; i++) {\n        mTempRect.set(0, 0, 0, 0);\n        mItemDecorations.get(i).getItemOffsets(mTempRect, child, this, mState);\n        insets.left += mTempRect.left;\n        insets.top += mTempRect.top;\n        insets.right += mTempRect.right;\n        insets.bottom += mTempRect.bottom;\n    }\n    lp.mInsetsDirty = false;\n    return insets;\n}\n```\n\n​\t方法getItemOffsets()就是我们在实现一个RecyclerView.ItemDecoration时可以重写的方法，通过mTempRect的大小，可以为每个ItemView设置位置偏移量，这个偏移量最终会参与计算ItemView的大小，也就是说ItemView的大小是包含这个位置偏移量的。我们在重写getItemOffsets()时，可以指定任意数值的偏移量：\n\n![itemdecoration](Android知识-三-RecyclerView深入解析/itemdecoration.png)\n\n4个方向的位置偏移量对应mTempRect的4个属性(left,top,right,bottom)，我以top offset的值在垂直线性布局中的应用来举例说明下。如果top offset等于0，那么ItemView之间就没有空隙；如果top offset大于0，那么ItemView之前就会有一个间隙；如果top offset小于0，那么ItemView之间就会有重叠的区域。 \n\n​\t当然，我们在实现RecyclerView.ItemDecoration时，并不一定要重写getItemOffsets()，同样的对于RecyclerView.ItemDecoration.onDraw()或RecyclerView.ItemDecoration.onDrawOver()方法也不是一定要重写，而且，这个绘制方法和我们所设置的位置偏移量没有任何联系。下面我来实现一个RecyclerView.ItemDecoration来加深下这里的理解：我将在垂直线性布局下，在ItemView间绘制一条5个像素宽、只有ItemView一半长、与ItemView居中对齐的红色分割线，这条分割线在ItemView内部top位置。\n\n```java\n@Override\npublic void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {\n  Paint paint = new Paint();\n  paint.setColor(Color.RED);\n  for (int i = 0; i < parent.getLayoutManager().getChildCount(); i++) {\n    final View child = parent.getChildAt(i);\n    float left = child.getLeft() + (child.getRight() - child.getLeft()) / 4;\n    float top = child.getTop();\n    float right = left + (child.getRight() - child.getLeft()) / 2;\n    float bottom = top + 5;\n    c.drawRect(left,top,right,bottom,paint);\n  }\n}\n@Override\npublic void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {\n  outRect.set(0, 0, 0, 0);\n}\n```\n\n代码不是很严谨，大家姑且一看吧，当然这里getItemOffsets()方法可以省略的。 \n\n​\t以上就是RecyclerView的整个绘制流程了，值得注意的地方也就是在23.2.0中RecyclerView支持WRAP_CONTENT属性了；还有就是ItemView的填充算法fill()算是一个亮点吧。接下来，我将分析ReyclerView的滑动流程。\n\n4、滑动流程\n\n​\tRecyclerView的滑动过程可以分为2个阶段：手指在屏幕上移动，使RecyclerView滑动的过程，可以称为scroll；手指离开屏幕，RecyclerView继续滑动一段距离的过程，可以称为fling。现在先看看RecyclerView的触屏事件处理onTouchEvent()方法：\n\n```java\npublic boolean onTouchEvent(MotionEvent e) {\n\t...\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n\t...\n    switch (action) {\n    ...\n        case MotionEvent.ACTION_MOVE: {\n        ...\n            final int x = (int) (MotionEventCompat.getX(e, index) + 0.5f);\n            final int y = (int) (MotionEventCompat.getY(e, index) + 0.5f);\n            int dx = mLastTouchX - x;\n            int dy = mLastTouchY - y;\n        ...\n            if (mScrollState != SCROLL_STATE_DRAGGING) {\n            ...\n                if (canScrollVertically && Math.abs(dy) > mTouchSlop) {\n                    if (dy > 0) {\n                        dy -= mTouchSlop;\n                    } else {\n                        dy += mTouchSlop;\n                    }\n                    startScroll = true;\n                }\n                if (startScroll) {\n                    setScrollState(SCROLL_STATE_DRAGGING);\n                }\n            }\n            if (mScrollState == SCROLL_STATE_DRAGGING) {\n                mLastTouchX = x - mScrollOffset[0];\n                mLastTouchY = y - mScrollOffset[1];\n                if (scrollByInternal(\n                        canScrollHorizontally ? dx : 0,\n                        canScrollVertically ? dy : 0,\n                        vtev)) {\n                    getParent().requestDisallowInterceptTouchEvent(true);\n                }\n            }\n        } break;\n    \t...\n        case MotionEvent.ACTION_UP: {\n        ...\n            final float yvel = canScrollVertically ?\n                    -VelocityTrackerCompat.getYVelocity(mVelocityTracker, mScrollPointerId) : 0;\n            if (!((xvel != 0 || yvel != 0) && fling((int) xvel, (int) yvel))) {\n                setScrollState(SCROLL_STATE_IDLE);\n            }\n            resetTouch();\n        } break;\n    \t...\n    }\n\t...\n}\n```\n\n​\t这里我以垂直方向的滑动来说明。当RecyclerView接收到ACTION_MOVE事件后，会先计算出手指移动距离（dy），并与滑动阀值（mTouchSlop）比较，当大于此阀值时将滑动状态设置为SCROLL_STATE_DRAGGING，而后调用scrollByInternal()方法，使RecyclerView滑动，这样RecyclerView的滑动的第一阶段scroll就完成了；当接收到ACTION_UP事件时，会根据之前的滑动距离与时间计算出一个初速度yvel，这步计算是由VelocityTracker实现的，然后再以此初速度，调用方法fling()，完成RecyclerView滑动的第二阶段fling。显然滑动过程中关键的方法就2个：scrollByInternal()与fling()。接下来同样以垂直线性布局来说明。先来说明scrollByInternal()，跟踪进入后，会发现它最终会调用到LinearLayoutManager.scrollBy()方法，这个过程很简单，我就不列出源码了，但是分析到这里先暂停下，去看看fling()方法：\n\n```java\npublic boolean fling(int velocityX, int velocityY) {\n\t...\n    mViewFlinger.fling(velocityX, velocityY);\n\t...\n}\n```\n\n​\t有用的就这一行，其它乱七八糟的不看也罢。mViewFlinger是一个Runnable的实现ViewFlinger的对象，就是它来控件着ReyclerView的fling过程的算法的。下面来看下类ViewFlinger的一段代码：\n\n```java\nvoid postOnAnimation() {\n    if (mEatRunOnAnimationRequest) {\n        mReSchedulePostAnimationCallback = true;\n    } else {\n        removeCallbacks(this);\n        ViewCompat.postOnAnimation(RecyclerView.this, this);\n    }\n}\npublic void fling(int velocityX, int velocityY) {\n    setScrollState(SCROLL_STATE_SETTLING);\n    mLastFlingX = mLastFlingY = 0;\n    mScroller.fling(0, 0, velocityX, velocityY,\n            Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    postOnAnimation();\n}\n```\n\n​\t可以看到，其实RecyclerView的fling是借助Scroller实现的；然后postOnAnimation()方法的作用就是在将来的某个时刻会执行我们给定的一个Runnable对象，在这里就是这个mViewFlinger对象，这部分原理我就不再深入分析了，它已经不属于本文的范围了。并且，关于Scroller的作用及原理，本文也不会作过多解释。对于这两点各位可以自行查阅，有很多文章对于作过详细阐述的。接下来看看ViewFlinger.run()方法：\n\n```java\npublic void run() {\n    ...\n    if (scroller.computeScrollOffset()) {\n        final int x = scroller.getCurrX();\n        final int y = scroller.getCurrY();\n        final int dx = x - mLastFlingX;\n        final int dy = y - mLastFlingY;\n        ...\n        if (mAdapter != null) {\n        ...\n            if (dy != 0) {\n                vresult = mLayout.scrollVerticallyBy(dy, mRecycler, mState);\n                overscrollY = dy - vresult;\n            }\n        ...\n        }\n        ...\n        if (!awakenScrollBars()) {\n            invalidate();//刷新界面\n        }\n        ...\n        if (scroller.isFinished() || !fullyConsumedAny) {\n            setScrollState(SCROLL_STATE_IDLE);\n        } else {\n            postOnAnimation();\n        }\n    }\n    ...\n}\n```\n\n​\t本段代码中有个方法mLayout.scrollVerticallyBy()，跟踪进入你会发现它最终也会走到LinearLayoutManager.scrollBy()，这样虽说RecyclerView的滑动可以分为两阶段，但是它们的实现最终其实是一样的。这里我先解释下上段代码。第一，dy表示滑动偏移量，它是由Scroller根据时间偏移量（Scroller.fling()开始时间到当前时刻）计算出的，当然如果是RecyclerView的scroll阶段，这个偏移量也就是手指滑动距离。第二，上段代码会多次执行，至到Scroller判断滑动结束或已经滑动到边界。再多说一下，postOnAnimation()保证了RecyclerView的滑动是流畅，这里涉及到著名的“android 16ms”机制，简单来说理想状态下，上段代码会以16毫秒一次的速度执行，这样其实，Scroller每次计算的滑动偏移量是很小的一部分，而RecyclerView就会根据这个偏移量，确定是平移ItemView，还是除了平移还需要再创建新ItemView。\n\n![recyclerview_scroll](Android知识-三-RecyclerView深入解析/recyclerview_scroll.png)\n\n现在就来看看LinearLayoutManager.scrollBy()方法：\n\n```java\nint scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) {\n    ...\n    final int absDy = Math.abs(dy);\n    updateLayoutState(layoutDirection, absDy, true, state);\n    final int consumed = mLayoutState.mScrollingOffset\n            + fill(recycler, mLayoutState, state, false);\n    ...\n    final int scrolled = absDy > consumed ? layoutDirection * consumed : dy;\n    mOrientationHelper.offsetChildren(-scrolled);\n    ...\n}\n```\n\n​\t如上文所讲到的fill()方法，作用就是向可绘制区间填充ItemView，那么在这里，可绘制区间就是滑动偏移量！再看方法mOrientationHelper.offsetChildren()作用就是平移ItemView。好了整个滑动过程就分析完成了，当然RecyclerView的滑动还有个特性叫平滑滑动（smooth scroll），其实它的实现就是一个fling滑动，所以就不再赘述了。\n\n5、Recycler\n\n　Recycler的作用就是重用ItemView。在填充ItemView的时候，ItemView是从它获取的；滑出屏幕的ItemView是由它回收的。对于不同状态的ItemView存储在了不同的集合中，比如有scrapped、cached、exCached、recycled，当然这些集合并不是都定义在同一个类里。 \n\n​\t回到之前的layoutChunk方法中，有行代码layoutState.next(recycler)，它的作用自然就是获取ItemView，我们进入这个方法查看，最终它会调用到RecyclerView.Recycler.getViewForPosition()方法：\n\n```java\nView getViewForPosition(int position, boolean dryRun) {\n\t...\n    // 0) If there is a changed scrap, try to find from there\n    if (mState.isPreLayout()) {\n        holder = getChangedScrapViewForPosition(position);\n        fromScrap = holder != null;\n    }\n    // 1) Find from scrap by position\n    if (holder == null) {\n        holder = getScrapViewForPosition(position, INVALID_TYPE, dryRun);\n    ...\n    }\n    if (holder == null) {\n    ...\n        // 2) Find from scrap via stable ids, if exists\n        if (mAdapter.hasStableIds()) {\n            holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);\n        ...\n        }\n        if (holder == null && mViewCacheExtension != null) {\n            final View view = mViewCacheExtension\n                    .getViewForPositionAndType(this, position, type);\n            if (view != null) {\n                holder = getChildViewHolder(view);\n            ...\n            }\n        }\n        if (holder == null) {\n        ...\n            holder = getRecycledViewPool().getRecycledView(type);\n        ...\n        }\n        if (holder == null) {\n            holder = mAdapter.createViewHolder(RecyclerView.this, type);\n        ...\n        }\n    }\n\t...\n    boolean bound = false;\n    if (mState.isPreLayout() && holder.isBound()) {\n        // do not update unless we absolutely have to.\n        holder.mPreLayoutPosition = position;\n    } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {\n    ...\n        mAdapter.bindViewHolder(holder, offsetPosition);\n    ...\n    }\n\t...\n}\n```\n\n​\t这个方法比较长，我先解释下它的逻辑吧。根据列表位置获取ItemView，先后从scrapped、cached、exCached、recycled集合中查找相应的ItemView，如果没有找到，就创建（Adapter.createViewHolder()），最后与数据集绑定。其中scrapped、cached和exCached集合定义在RecyclerView.Recycler中，分别表示将要在RecyclerView中删除的ItemView、一级缓存ItemView和二级缓存ItemView，cached集合的大小默认为２，exCached是需要我们通过RecyclerView.ViewCacheExtension自己实现的，默认没有；recycled集合其实是一个Map，定义在RecyclerView.RecycledViewPool中，将ItemView以ItemType分类保存了下来，这里算是RecyclerView设计上的亮点，通过RecyclerView.RecycledViewPool可以实现在不同的RecyclerView之间共享ItemView，只要为这些不同RecyclerView设置同一个RecyclerView.RecycledViewPool就可以了。 \n\n​\t上面解释了ItemView从不同集合中获取的方式，那么RecyclerView又是在什么时候向这些集合中添加ItemView的呢？下面我逐个介绍下。 scrapped集合中存储的其实是正在执行REMOVE操作的ItemView，这部分会在后文进一步描述。 在fill()方法的循环体中有行代码recycleByLayoutState(recycler, layoutState);，最终这个方法会执行到RecyclerView.Recycler.recycleViewHolderInternal()方法：\n\n```java\nvoid recycleViewHolderInternal(ViewHolder holder) {\n    ...\n    if (forceRecycle || holder.isRecyclable()) {\n        if (!holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED\n                | ViewHolder.FLAG_UPDATE)) {\n            // Retire oldest cached view\n            final int cachedViewSize = mCachedViews.size();\n            if (cachedViewSize == mViewCacheMax && cachedViewSize > 0) {\n                recycleCachedViewAt(0);\n            }\n            if (cachedViewSize < mViewCacheMax) {\n                mCachedViews.add(holder);\n                cached = true;\n            }\n        }\n        if (!cached) {\n            addViewHolderToRecycledViewPool(holder);\n            recycled = true;\n        }\n    }\n    ...\n}\n```\n\n​\t这个方法的逻辑是这样的：首先判断集合cached是否満了，如果已満就从cached集合中移出一个到recycled集合中去，再把新的ItemView添加到cached集合；如果不満就将ItemView直接添加到cached集合。 \n\n​\t最后exCached集合是我们自己创建的，所以添加删除元素也要我们自己实现。\n\n6、数据集、动画\n\n　　RecyclerView定义了4种针对数据集的操作，分别是ADD、REMOVE、UPDATE、MOVE，封装在了AdapterHelper.UpdateOp类中，并且所有操作由一个大小为30的对象池管理着。当我们要对数据集作任何操作时，都会从这个对象池中取出一个UpdateOp对象，放入一个等待队列中，最后调用RecyclerView.RecyclerViewDataObserver.triggerUpdateProcessor()方法，根据这个等待队列中的信息，对所有子控件重新测量、布局并绘制且执行动画。以上就是我们调用Adapter.notifyItemXXX()系列方法后发生的事。 \n\n​\t显然当我们对某个ItemView做操作时，它很有可以会影响到其它ItemView。下面我以REMOVE为例来梳理下这个流程。 \n\n![recyclerview_annomation_data](Android知识-三-RecyclerView深入解析/recyclerview_annomation_data.png)\n\n首先调用Adapter.notifyItemRemove()，追溯到方法RecyclerView.RecyclerViewDataObserver.onItemRangeRemoved()：\n\n```java\npublic void onItemRangeRemoved(int positionStart, int itemCount) {\n    assertNotInLayoutOrScroll(null);\n    if (mAdapterHelper.onItemRangeRemoved(positionStart, itemCount)) {\n        triggerUpdateProcessor();\n    }\n}\n```\n\n​\t这里的mAdapterHelper.onItemRangeRemoved()就是向之前提及的等待队列添加一个类型为REMOVE的UpdateOp对象， triggerUpdateProcessor()方法就是调用View.requestLayout()方法，这会导致界面重新布局，也就是说方法RecyclerView.onLayout()会随后调用，这之后的流程就和在绘制流程一节中所描述的一致了。但是动画在哪是执行的呢？查看之前所列出的onLayout()方法发现dispatchLayoutStepX方法共有3个，前文只解释了dispatchLayoutStep2()的作用，这里就其它2个方法作进一步说明。不过dispatchLayoutStep1()没有过多要说明的东西，它的作用只是初始化数据，需要详细说明的是dispatchLayoutStep3()方法：\n\n```java\nprivate void dispatchLayoutStep3() {\n    ...\n    if (mState.mRunSimpleAnimations) {\n        // Step 3: Find out where things are now, and process change animations.\n        ...\n        // Step 4: Process view info lists and trigger animations\n        mViewInfoStore.process(mViewInfoProcessCallback);\n    }\n    ...\n}\n```\n\n​\t代码注释已经说明得很清楚了，这里我没有列出step 3相关的代码是因为这部分只是初始化或赋值一些执行动画需要的中间数据，process()方法最终会执行到RecyclerView.animateDisappearance()方法：\n\n```java\nprivate void animateDisappearance(...) {\n    addAnimatingView(holder);\n    holder.setIsRecyclable(false);\n    if (mItemAnimator.animateDisappearance(holder, preLayoutInfo, postLayoutInfo)) {\n        postAnimationRunner();\n    }\n}\n```\n\n​\t这里的animateDisappearance()会把一个动画与ItemView绑定，并添加到待执行队列中， postAnimationRunner()调用后就会执行这个队列中的动画，注意方法addAnimatingView()：\n\n```java\nprivate void addAnimatingView(ViewHolder viewHolder) {\n    final View view = viewHolder.itemView;\n    ...\n    mChildHelper.addView(view, true);\n    ...\n}\n```\n\n​\t这里最终会向ChildHelper中的一个名为mHiddenViews的集合添加给定的ItemView，那么这个mHiddenViews又是什么东西？上节中的getViewForPosition()方法中有个getScrapViewForPosition()，作用是从scrapped集合中获取ItemView：\n\n```java\nViewHolder getScrapViewForPosition(int position, int type, boolean dryRun) {\n    ...\n    View view = mChildHelper.findHiddenNonRemovedView(position, type);\n    ...\n}\n```\n\n接下来是findHiddenNonRemovedView()方法：\n\n```java\nView findHiddenNonRemovedView(int position, int type) {\n    final int count = mHiddenViews.size();\n    for (int i = 0; i < count; i++) {\n        final View view = mHiddenViews.get(i);\n        RecyclerView.ViewHolder holder = mCallback.getChildViewHolder(view);\n        if (holder.getLayoutPosition() == position && !holder.isInvalid() && !holder.isRemoved()\n                && (type == RecyclerView.INVALID_TYPE || holder.getItemViewType() == type)) {\n            return view;\n        }\n    }\n    return null;\n}\n```\n\n看到这里就之前所讲的scrapped集合联系起来了，虽然绕了个圈。所以这里就论证我之前对于scrapped集合的理解。 \n\n7、pre&post layout\n\n​\t在RecyclerView中存在一个叫“预布局”的阶段，当然这个是我自己作的翻译，本来叫pre layout，与之对应的还有个叫post layout的阶段，它们分别发生在真正的子控件测量&布局的前后。其中pre layout阶段的作用是记录数据集改变前的子控件信息，post layout阶段的作用是记录数据集改变后的子控件信息及触发动画。\n\n```java\nvoid dispatchLayout() {\n    ...\n    if (mState.mLayoutStep == State.STEP_START) {\n        dispatchLayoutStep1();\n       ...\n        dispatchLayoutStep2();\n    }\n    dispatchLayoutStep3();\n    ...\n}\n```\n\n方法dispatchLayout()会在RecyclerView.onLayout()中被调用，其中dispatchLayoutStep1就是pre layout，dispatchLayoutStep3就是post layout，而dispatchLayoutStep2自然就是处理真正测量&布局的了。 \n　　首先来看看pre layout时都记录了什么内容：\n\n```java\nprivate void dispatchLayoutStep1() {\n    ...\n    if (mState.mRunSimpleAnimations) {\n        // Step 0: Find out where all non-removed items are, pre-layout\n        int count = mChildHelper.getChildCount();\n        for (int i = 0; i < count; ++i) {\n            final ViewHolder holder = ...\n            ...\n            final ItemHolderInfo animationInfo = mItemAnimator\n                    .recordPreLayoutInformation(...);\n            mViewInfoStore.addToPreLayout(holder, animationInfo);\n            ...\n        }\n    }\n    ...\n}\n```\n\n类ItemHolderInfo中封闭了对应ItemView的边界信息，即ItemView的left、top、right、bottom值。对象mViewInfoStore的作用正如源码注释：\n\n```java\n  /**\n   * Keeps data about views to be used for animations\n   */\n  final ViewInfoStore mViewInfoStore = new ViewInfoStore();\n```\n\n再来看看addToPreLayout()方法：\n\n```java\nvoid addToPreLayout(ViewHolder holder, ItemHolderInfo info) {\n    InfoRecord record = mLayoutHolderMap.get(holder);\n    if (record == null) {\n        record = InfoRecord.obtain();\n        mLayoutHolderMap.put(holder, record);\n    }\n    record.preInfo = info;\n    record.flags |= FLAG_PRE;\n}\n```\n\n由上可已看出RecyclerView将pre layout阶段的ItemView信息存放在了ViewInfoStore中的mLayoutHolderMap集合中。 \n　　接下来我们看看post layout阶段：\n\n```java\nprivate void dispatchLayoutStep3() {\n    ...\n    if (mState.mRunSimpleAnimations) {\n        // Step 3: Find out where things are now, and process change animations.\n        ...\n        for (int i = mChildHelper.getChildCount() - 1; i >= 0; i--) {\n            ...\n            final ItemHolderInfo animationInfo = mItemAnimator\n                    .recordPostLayoutInformation(mState, holder);\n            ...\n            if (...) {\n                ...\n                animateChange(oldChangeViewHolder, holder, preInfo, postInfo,\n                                oldDisappearing, newDisappearing);\n            } else {\n                mViewInfoStore.addToPostLayout(holder, animationInfo);\n            }\n        }\n        // Step 4: Process view info lists and trigger animations\n        mViewInfoStore.process(mViewInfoProcessCallback);\n    }\n    ...\n}\n```\n\n这是addToPostLayout()方法：\n\n```java\nvoid addToPostLayout(ViewHolder holder, ItemHolderInfo info) {\n    InfoRecord record = mLayoutHolderMap.get(holder);\n    if (record == null) {\n        record = InfoRecord.obtain();\n        mLayoutHolderMap.put(holder, record);\n    }\n    record.postInfo = info;\n    record.flags |= FLAG_POST;\n}\n```\n\n与pre layout阶段相同RecyclerView也是将post layout阶段的ItemView信息存放在mViewInfoStore的mLayoutHolderMap集合中，并且不难看出，同一个ItemView（或者叫ViewHolder）的pre layout信息与post layout信息封装在了同一个InfoRecord中，分别叫InfoRecord.preInfo与InforRecord.postInfo，**这样InfoRecord就保存着同一个ItemView在数据集变化前后的信息，我们可以根据此信息定义动画的开始和结束状态。** \n\n![pre_post_layout](Android知识-三-RecyclerView深入解析/pre_post_layout.png)\n\n​\t如上图所示，当我们插入A时，在完成了上文所诉过程后，以ItemView2为例，通过比较它的preInfo与postInfo——都为非空，源码中是以标志位的形式实现的，就可以知道它将执行MOVE操作；而A自然就是ADD操作。下面是ViewInfoStore.ProcessCallback实现中的其中一个方法，它会在mViewInfoStore.process()方法中被调用：\n\n```java\npublic void processPersistent(...) {\n        ...\n        if (mDataSetHasChangedAfterLayout) {\n            ...\n        } else if (mItemAnimator.animatePersistence(viewHolder, preInfo, postInfo)) {\n            postAnimationRunner();\n        }\n    }\n```\n\n我们知道，RecyclerView中ItemAnimator的默认实现是DefaultItemAnimator，这里我就只以默认实现来说明，这是animatePersistence()方法：\n\n```java\npublic boolean animatePersistence(...) {\n    if (preInfo.left != postInfo.left || preInfo.top != postInfo.top) {\n        ...\n        return animateMove(viewHolder,\n                preInfo.left, preInfo.top, postInfo.left, postInfo.top);\n    }\n    dispatchMoveFinished(viewHolder);\n    return false;\n}\n```\n\n当然这个方法在DefaultItemAnimator的父类SimpleItemAnimator中，通过比较preInfo与postInfo的left和top属性分别确定ItemView在水平或垂直方向是否要执行MOVE操作，而上面的方法postAnimationRunner()就是用来触发动画执行的。 \n　　通过前文我们知道，RecyclerView中定义了4种针对数据集的操作（也可以称为针对ItemView的操作），分别是ADD、REMOVE、UPDATE、MOVE，RecyclerView就是通过比较preInfo与postInfo来确定ItemView要执行哪种操作的，上文我描述了MOVE情况，这个比较过程是在方法ViewInfoStore.process()中实现的，其它情况我就不再赘述了，各位不妨自己去看看。 \n　　在DefaultItemAnimator中实现了上面4种操作下的动画。当postAnimationRunner()执行后，会触发DefaultItemAnimator.runPendingAnimations()方法的调用，这个方法过长，我这里只作下解释便可。4种操作对应的动画是有先后顺序的，remove–>move&change–>add，之所以有这样的顺序，不难看出是为了不让ItemView之间有重叠的区域，这个顺序是由ViewCompat.postOnAnimationDelayed()方法通过控制延时来实现的。在DefaultItemAnimator中，REMOVE和ADD对应的是淡入淡出动画（改变透明度），MOVE对应的是平移动画；UPDATE相对来说要复杂一些，是因为它不再是记录同一个ItemView的变化情况，而是记录2个ItemView的信息来作比较，pre layout阶段的信息来自“oldChangeViewHolder”，post layout阶段的信息来自“holder”，这两个对象在dispatchLayoutStep3方法中可以找到，而且，这2个ItemView的动画是同时执行的，所以它对应的动画是：“oldHolder”淡出且向“newHolder”平移，同时“newHolder”淡入。特别说明，前文有提过一个叫scrapped的集合，其实它除了保存REMOVE操作的ItemView，还保存着UPDATE操作中的“oldHolder”！ \n　　以上就是RecyclerView默认动画的具体实现逻辑了，总结下来就是：当数据集发生变化时，会导致RecyclerView重新测量&布局子控件，我们记录下这个变化前后的RecyclerView的快照（preInfo与postInfo），通过比较这2个快照，从而确定子控件要执行什么操作，最后再实现不同操作下对应的动画就好了。通常我们会调用notifyItemXXX()系列方法来通知RecyclerView数据集变化，这些方法之所以比notifyDataSetChanged()高效的原因就是它们不会让整个RecyclerView重新绘制，而是只重绘具体的子控件，并且通过动画连接子控件的前后状态，这样也就实现了在Material design中所讲的“Visual continuity”效果。\n\n8、子控件的测量与布局\n\n这一节将对preInfo与postInfo是如果确定（赋值）的，作进一步描述。 \n　　从前文我们知道，子控件的测量与布局其实在RecyclerView的测量阶段（onMeasure）就执行完了，这样做是为了支持WRAP_CONTENT，具体的方法呢就是dispatchLayoutStep1()与dispatchLayoutStep2()，同样这两个方法也会出现在RecyclerView的布局阶段（onLayout），但并不是说它们就会被调用，这里的调用逻辑是由RecyclerView.State类控制的，它定义了RecyclerView的整个测量布局过程，分为3步STEP_START、STEP_LAYOUT、STEP_ANIMATIONS，具体流程是：初始状态是STEP_START；如果RecyclerView当前在STEP_START阶段dispatchLayoutStep1()会执行，记录下preInfo，将状态改为STEP_LAYOUT；如果RecyclerView在STEP_LAYOUT阶段dispatchLayoutStep2()会执行，测量布局子控件，将状态改为STEP_ANIMATIONS；如果RecyclerView在STEP_ANIMATIONS阶段dispatchLayoutStep3()会执行，记录下postInfo，触发动画，将状态改为STEP_START。每次数据集更改都会执行上述3步。 \n　　在测量布局子控件的过程中，最重要的莫过于确定布局锚点了，以LinearLayoutManager垂直布局为例，在onLayoutChildren()方法中，会调用updateAnchorInfoForLayout()方法来确定布局锚点：\n\n```java\nprivate void updateAnchorInfoForLayout(...) {\n    if (updateAnchorFromPendingData(state, anchorInfo)) {\n        ...\n        return;\n    }\n    if (updateAnchorFromChildren(recycler, state, anchorInfo)) {\n        ...\n        return;\n    }\n    ...\n    anchorInfo.assignCoordinateFromPadding();\n    anchorInfo.mPosition = mStackFromEnd ? state.getItemCount() - 1 : 0;\n}\n```\n\n​\t这里布局锚点的确定方法有3种依据。首先，如果是第一次布局（没有ItemView），这种情况已经在前文有过描述了，这里就不再说明；剩余的2种分别是“滑动位置”与“子控件”，这2种情况都是发生在已经有ItemView时的，而且这里的“滑动位置”是指由方法scrollToPosition()确认的，并赋给了mPendingScrollPosition变量。现在先来看看“滑动位置”updateAnchorFromPendingData()方法：\n\n```java\nprivate boolean updateAnchorFromPendingData(...) {\n    ...\n    // if child is visible, try to make it a reference child and ensure it is fully visible.\n    // if child is not visible, align it depending on its virtual position.\n    anchorInfo.mPosition = mPendingScrollPosition;\n    ...\n    if (mPendingScrollPositionOffset == INVALID_OFFSET) {\n        View child = findViewByPosition(mPendingScrollPosition);\n        if (child != null) {\n            ...\n        } else { // item is not visible.\n            ...\n        }\n        return true;\n    }\n    ...\n    return true;\n}\n```\n\n布局锚点中的mCoordinate与mPosition，在前文描述为起始绘制偏移量与索引位置，再直白点就是屏幕位置与数据集位置，就是告诉RecyclerView从屏幕的mCoordinate位置开始填充子控件，与子控件绑定的数据从数据集的mPosition位置开始取得。上面这个方法中确定“屏幕位置”分为2种情况，就是对应于mPendingScrollPosition是否存在子控件，mCoordinate值的确定我就不再讲述了，无非是一边界判断的语句。 \n　　下面来看看“子控件”依据的情况，这是updateAnchorFromChildren()：\n\n```java\nprivate boolean updateAnchorFromChildren(...) {\n    ...\n    View referenceChild = anchorInfo.mLayoutFromEnd\n            ? findReferenceChildClosestToEnd(recycler, state)\n            : findReferenceChildClosestToStart(recycler, state);\n    if (referenceChild != null) {\n        anchorInfo.assignFromView(referenceChild);\n        ...\n        return true;\n    }\n    return false;\n}\n```\n\n​\t这种情况也并不复杂，就是找到最外边的一个子控件，以它的位置信息来确定布局锚点，就是方法assignFromView()，我也就不再列出来了。以上就是详细的布局锚点确认过程了。 ","tags":["Android"]},{"title":"Android知识(二)--View的绘制流程","url":"/2018/02/25/Android知识-二-View的绘制流程/","content":"\n### 1、View 绘制依赖关系简介\n\n#### 1.1、概述\n\n![view_draw](Android知识-二-View的绘制流程/view_draw.png)\n\n​\t如上图所示：DecorView是一个应用窗口的根容器，它本质上是一个FrameLayout。DecorView有唯一一个子View，它是一个垂直LinearLayout，包含两个子元素，一个是TitleView（ActionBar的容器），另一个是ContentView（窗口内容的容器）。关于ContentView，它是一个FrameLayout（android.R.id.content)，我们平常用的setContentView就是设置它的子View。上图还表达了每个Activity都与一个Window（具体来说是PhoneWindow）相关联，用户界面则由Window所承载。\n\n#### 1.2、window\n\n​\tWindow即窗口，这个概念在Android Framework中的实现为android.view.Window这个抽象类，这个抽象类是对Android系统中的窗口的抽象。在介绍这个类之前，我们先来看看究竟什么是窗口呢？\n\n实际上，窗口是一个宏观的思想，它是屏幕上用于绘制各种UI元素及响应用户输入事件的一个矩形区域。通常具备以下两个特点：\n\n- 独立绘制，不与其它界面相互影响；\n- 不会触发其它界面的输入事件；\n\n​\t在Android系统中，窗口是独占一个Surface实例的显示区域，每个窗口的Surface由WindowManagerService分配。我们可以把Surface看作一块画布，应用可以通过Canvas或OpenGL在其上面作画。画好之后，通过SurfaceFlinger将多块Surface按照特定的顺序（即Z-order）进行混合，而后输出到FrameBuffer中，这样用户界面就得以显示。\n\nandroid.view.Window这个抽象类可以看做Android中对窗口这一宏观概念所做的约定，而PhoneWindow这个类是Framework为我们提供的Android窗口概念的具体实现。接下来我们先来介绍一下android.view.Window这个抽象类。\n\n这个抽象类包含了三个核心组件：\n\n- WindowManager.LayoutParams: 窗口的布局参数；\n- Callback: 窗口的回调接口，通常由Activity实现；\n- ViewTree: 窗口所承载的控件树。\n\n下面我们来看一下Android中Window的具体实现（也是唯一实现）——PhoneWindow。\n\n#### 1.3、PhoneWindow\n\n​\t前面我们提到了，PhoneWindow这个类是Framework为我们提供的Android窗口的具体实现。我们平时调用setContentView()方法设置Activity的用户界面时，实际上就完成了对所关联的PhoneWindow的ViewTree的设置。我们还可以通过Activity类的requestWindowFeature()方法来定制Activity关联PhoneWindow的外观，这个方法实际上做的是把我们所请求的窗口外观特性存储到了PhoneWindow的mFeatures成员中，在窗口绘制阶段生成外观模板时，会根据mFeatures的值绘制特定外观。\n\n#### 1.4、setContentView()\n\n​\t在分析setContentView()方法前，我们需要明确：这个方法只是完成了Activity的ContentView的创建，而并没有执行View的绘制流程。\n​\t当我们自定义Activity继承自android.app.Activity时候，调用的setContentView()方法是Activity类的，源码如下：\n\n```java\npublic void setContentView(@LayoutRes int layoutResID) {   \n  getWindow().setContentView(layoutResID);   \n  . . .\n}\n```\n\ngetWindow()方法会返回Activity所关联的PhoneWindow，也就是说，实际上调用到了PhoneWindow的setContentView()方法，源码如下：\n\n```java\n@Override\npublic void setContentView(int layoutResID) {\n  if (mContentParent == null) {\n    // mContentParent即为上面提到的ContentView的父容器，若为空则调用installDecor()生成\n    installDecor();\n  } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n    // 具有FEATURE_CONTENT_TRANSITIONS特性表示开启了Transition\n    // mContentParent不为null，则移除decorView的所有子View\n    mContentParent.removeAllViews();\n  }\n  if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n    // 开启了Transition，做相应的处理，我们不讨论这种情况\n    // 感兴趣的同学可以参考源码\n    . . .\n  } else {\n    // 一般情况会来到这里，调用mLayoutInflater.inflate()方法来填充布局\n    // 填充布局也就是把我们设置的ContentView加入到mContentParent中\n    mLayoutInflater.inflate(layoutResID, mContentParent);\n  }\n  . . .\n  // cb即为该Window所关联的Activity\n  final Callback cb = getCallback();\n  if (cb != null && !isDestroyed()) {\n    // 调用onContentChanged()回调方法通知Activity窗口内容发生了改变\n    cb.onContentChanged();\n  }\n. . .\n}　\n```\n\n​\t在上面我们看到了，PhoneWindow的setContentView()方法中调用了LayoutInflater的inflate()方法来填充布局，这个方法的源码如下：\n\n```java\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {\n  return inflate(resource, root, root != null);\n}\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n  final Resources res = getContext().getResources();\n  . . .\n  final XmlResourceParser parser = res.getLayout(resource);\n  try {\n    return inflate(parser, root, attachToRoot);\n  } finally {\n    parser.close();\n  }\n}\n```\n\n​\t在PhoneWindow的setContentView()方法中传入了decorView作为LayoutInflater.inflate()的root参数，我们可以看到，通过层层调用，最终调用的是inflate(XmlPullParser, ViewGroup, boolean)方法来填充布局。这个方法的源码如下：\n\n```java\npublic View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n  synchronized (mConstructorArgs) {\n    . . .\n    final Context inflaterContext = mContext;\n    final AttributeSet attrs = Xml.asAttributeSet(parser);\n    Context lastContext = (Context) mConstructorArgs[0];\n    mConstructorArgs[0] = inflaterContext;\n    View result = root;\n    try {\n      // Look for the root node.\n      int type;\n      // 一直读取xml文件，直到遇到开始标记\n      while ((type = parser.next()) != XmlPullParser.START_TAG &&\n          type != XmlPullParser.END_DOCUMENT) {\n        // Empty\n       }\n      // 最先遇到的不是开始标记，报错\n      if (type != XmlPullParser.START_TAG) {\n        throw new InflateException(parser.getPositionDescription()+ \": No start tag found!\");\n      }\n      final String name = parser.getName();\n      . . .\n      // 单独处理<merge>标签，不熟悉的同学请参考官方文档的说明\n      if (TAG_MERGE.equals(name)) {\n        // 若包含<merge>标签，父容器（即root参数）不可为空且attachRoot须为true，否则报错\n        if (root == null || !attachToRoot) {\n          throw new InflateException(\"<merge/> can be used only with a valid ViewGroup root and attachToRoot=true\");\n        }\n        // 递归地填充布局\n        rInflate(parser, root, inflaterContext, attrs, false);\n     } else {\n        // temp为xml布局文件的根View\n        final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n        ViewGroup.LayoutParams params = null;\n        if (root != null) {\n          . . .\n          // 获取父容器的布局参数（LayoutParams）\n          params = root.generateLayoutParams(attrs);\n          if (!attachToRoot) {\n            // 若attachToRoot参数为false，则我们只会将父容器的布局参数设置给根View\n            temp.setLayoutParams(params);\n          }\n        }\n        // 递归加载根View的所有子View\n        rInflateChildren(parser, temp, attrs, true);\n        . . .\n        if (root != null && attachToRoot) {\n          // 若父容器不为空且attachToRoot为true，则将父容器作为根View的父View包裹上来\n          root.addView(temp, params);\n        }\n        // 若root为空或是attachToRoot为false，则以根View作为返回值\n        if (root == null || !attachToRoot) {\n           result = temp;\n        }\n      }\n    } catch (XmlPullParserException e) {\n      . . .\n    } catch (Exception e) {\n      . . .\n    } finally {\n      . . .\n    }\n    return result;\n  }\n}\n```\n\n​\t在上面的源码中，首先对于布局文件中的<merge>标签进行单独处理，调用rInflate()方法来递归填充布局。这个方法的源码如下：\n\n```java\npublic void rInflate(XmlPullParser parser, View parent, Context context,\n    AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {\n    // 获取当前标记的深度，根标记的深度为0\n    final int depth = parser.getDepth();\n    int type;\n    while (((type = parser.next()) != XmlPullParser.END_TAG ||\n        parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {\n      // 不是开始标记则继续下一次迭代\n      if (type != XmlPullParser.START_TAG) {\n        continue;\n      }\n      final String name = parser.getName();\n      // 对一些特殊标记做单独处理\n      if (TAG_REQUEST_FOCUS.equals(name)) {\n        parseRequestFocus(parser, parent);\n      } else if (TAG_TAG.equals(name)) {\n        parseViewTag(parser, parent, attrs);\n      } else if (TAG_INCLUDE.equals(name)) {\n        if (parser.getDepth() == 0) {\n          throw new InflateException(\"<include /> cannot be the root element\");\n        }\n        // 对<include>做处理\n        parseInclude(parser, context, parent, attrs);\n      } else if (TAG_MERGE.equals(name)) {\n        throw new InflateException(\"<merge /> must be the root element\");\n      } else {\n        // 对一般标记的处理\n        final View view = createViewFromTag(parent, name, context, attrs);\n        final ViewGroup viewGroup = (ViewGroup) parent;\n        final ViewGroup.LayoutParams params=viewGroup.generateLayoutParams(attrs);\n        // 递归地加载子View\n        rInflateChildren(parser, view, attrs, true);\n        viewGroup.addView(view, params);\n      }\n    }\n    if (finishInflate) {\n      parent.onFinishInflate();\n    }\n}\n```\n\n我们可以看到，上面的inflate()和rInflate()方法中都调用了rInflateChildren()方法，这个方法的源码如下：\n\n```java\nfinal void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {\n    rInflate(parser, parent, parent.getContext(), attrs, finishInflate);\n}\n```\n\n​\t从源码中我们可以知道，rInflateChildren()方法实际上调用了rInflate()方法。\n\n​\t到这里，setContentView()的整体执行流程我们就分析完了，至此我们已经完成了Activity的ContentView的创建与设置工作。接下来，我们开始进入正题，分析View的绘制流程。\n\n#### 1.5、ViewRoot\n\n​\t在介绍View的绘制前，首先我们需要知道是谁负责执行View绘制的整个流程。实际上，View的绘制是由ViewRoot来负责的。每个应用程序窗口的decorView都有一个与之关联的ViewRoot对象，这种关联关系是由WindowManager来维护的。那么decorView与ViewRoot的关联关系是在什么时候建立的呢？答案是Activity启动时，ActivityThread.handleResumeActivity()方法中建立了它们两者的关联关系。这里我们不具体分析它们建立关联的时机与方式，感兴趣的同学可以参考相关源码。下面我们直入主题，分析一下ViewRoot是如何完成View的绘制的。\n\n#### 1.6、View绘制的起点\n\n​\t当建立好了decorView与ViewRoot的关联后，ViewRoot类的requestLayout()方法会被调用，以完成应用程序用户界面的初次布局。实际被调用的是ViewRootImpl类的requestLayout()方法，这个方法的源码如下：\n\n```java\n@Override\npublic void requestLayout() {\n  if (!mHandlingLayoutInLayoutRequest) {\n    // 检查发起布局请求的线程是否为主线程 \n    checkThread();\n    mLayoutRequested = true;\n    scheduleTraversals();\n  }\n}\n```\n\n上面的方法中调用了scheduleTraversals()方法来调度一次完成的绘制流程，该方法会向主线程发送一个“遍历”消息，最终会导致ViewRootImpl的performTraversals()方法被调用。下面，我们以performTraversals()为起点，来分析View的整个绘制流程。\n\n### 2、View 树的绘图流程\n\n#### 2.1、绘制流程概述\n\n​\t当 Activity 接收到焦点的时候，它会被请求绘制布局,该请求由 Android framework 处理.绘制是从根节点开始，对布局树进行 measure 和 draw。整个 View 树的绘图流程在`ViewRoot.java`类的`performTraversals()`函数展开，该函数所做 的工作可简单概况可以分为以下三个阶段(即View的整个绘制流程)：\n\n- measure: 判断是否需要重新计算View的大小，需要的话则计算；\n- layout: 判断是否需要重新计算View的位置，需要的话则计算；\n- draw: 判断是否需要重新绘制View，需要的话则重绘制。\n\n![view_mechanism_flow](Android知识-二-View的绘制流程/view_mechanism_flow.png)\n\nView 绘制流程函数调用链:\n\n![view_draw_method_chain](Android知识-二-View的绘制流程/view_draw_method_chain.png)\n\n​\t**注意：用户主动调用 request，只会出发 measure 和 layout 过程，而不会执行 draw 过程**\n\n从整体上来看 Measure 和 Layout 两个步骤的执行：\n\n#### 2.2、measure阶段\n\n​\t此阶段的目的是计算出控件树中的各个控件要显示其内容的话，需要多大尺寸。起点是ViewRootImpl的measureHierarchy()方法，这个方法的源码如下\n\n```java\nprivate boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res,\n    final int desiredWindowWidth, final int desiredWindowHeight) {\n  // 传入的desiredWindowXxx为窗口尺寸\n  int childWidthMeasureSpec;\n  int childHeightMeasureSpec;\n  boolean windowSizeMayChange = false;\n  . . .\n  boolean goodMeasure = false;\n  if (!goodMeasure) {\n        childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);\n        childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);\n        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n        if (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) {\n         \twindowSizeMayChange = true;\n        }\n  }\n  return windowSizeMayChange;\n}\n```\n\n​\t上面的代码中调用getRootMeasureSpec()方法来获取根MeasureSpec，这个根MeasureSpec代表了对decorView的宽高的约束信息。继续分析之前，我们先来简单地介绍下MeasureSpec的概念。\n​\tMeasureSpec是一个32位整数，由SpecMode和SpecSize两部分组成，其中，高2位为SpecMode，低30位为SpecSize。SpecMode为测量模式，SpecSize为相应测量模式下的测量尺寸。View（包括普通View和ViewGroup）的SpecMode由本View的LayoutParams结合父View的MeasureSpec生成。SpecMode的取值可为以下三种：\n\n- EXACTLY: 对子View提出了一个确切的建议尺寸（SpecSize）；\n- AT_MOST: 子View的大小不得超过SpecSize；\n- UNSPECIFIED: 对子View的尺寸不作限制，通常用于系统内部。\n\n传入performMeasure()方法的MeasureSpec的SpecMode为EXACTLY，SpecSize为窗口尺寸。\nperformMeasure()方法的源码如下：\n\n```java\nprivate void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {\n      . . .\n      try {\n        \tmView.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n      } finally {\n        \t. . .\n      }\n}\n```\n\n上面代码中的mView即为decorView，也就是说会转向对View.measure()方法的调用，这个方法的源码如下：\n\n```java\n  /**\n  * 调用这个方法来算出一个View应该为多大。参数为父View对其宽高的约束信息。\n  * 实际的测量工作在onMeasure()方法中进行\n  */\n  public final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n      . . .\n      // 判断是否需要重新布局\n\n      // 若mPrivateFlags中包含PFLAG_FORCE_LAYOUT标记，则强制重新布局\n      // 比如调用View.requestLayout()会在mPrivateFlags中加入此标记\n      final boolean forceLayout = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;\n      final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec\n          || heightMeasureSpec != mOldHeightMeasureSpec;\n      final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY\n          && MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;\n      final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)\n          && getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);\n      final boolean needsLayout = specChanged\n          && (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);\n\n      // 需要重新布局 \n      if (forceLayout || needsLayout) {\n            . . .\n            // 先尝试从缓从中获取，若forceLayout为true或是缓存中不存在或是\n            // 忽略缓存，则调用onMeasure()重新进行测量工作\n            int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);\n            if (cacheIndex < 0 || sIgnoreMeasureCache) {\n                  // measure ourselves, this should set the measured dimension flag back\n                  onMeasure(widthMeasureSpec, heightMeasureSpec);\n                  . . .\n            } else {\n                  // 缓存命中，直接从缓存中取值即可，不必再测量\n                  long value = mMeasureCache.valueAt(cacheIndex);\n                  // Casting a long to int drops the high 32 bits, no mask needed\n                  setMeasuredDimensionRaw((int) (value >> 32), (int) value);\n                  . . .\n            }\n            . . .\n      }\n      mOldWidthMeasureSpec = widthMeasureSpec;\n      mOldHeightMeasureSpec = heightMeasureSpec;\n      mMeasureCache.put(key, ((long) mMeasuredWidth) << 32 |\n          (long) mMeasuredHeight & 0xffffffffL); // suppress sign extension\n}\n```\n\n​\tFrameLayout是ViewGroup的子类，后者有一个View[]类型的成员变量mChildren，代表了其子View集合。通过getChildAt(i)能获取指定索引处的子View，通过getChildCount()可以获得子View的总数。\n\n​\t在上面的源码中，首先调用measureChildWithMargins()方法对所有子View进行了一遍测量，并计算出所有子View的最大宽度和最大高度。而后将得到的最大高度和宽度加上padding，这里的padding包括了父View的padding和前景区域的padding。然后会检查是否设置了最小宽高，并与其比较，将两者中较大的设为最终的最大宽高。最后，若设置了前景图像，我们还要检查前景图像的最小宽高。\n\n​\t经过了以上一系列步骤后，我们就得到了maxHeight和maxWidth的最终值，表示当前容器View用这个尺寸就能够正常显示其所有子View（同时考虑了padding和margin）。而后我们需要调用resolveSizeAndState()方法来结合传来的MeasureSpec来获取最终的测量宽高，并保存到mMeasuredWidth与mMeasuredHeight成员变量中。\n\n​\t从以上代码的执行流程中，我们可以看到，容器View通过measureChildWithMargins()方法对所有子View进行测量后，才能得到自身的测量结果。也就是说，对于ViewGroup及其子类来说，要先完成子View的测量，再进行自身的测量（考虑进padding等）。\n接下来我们来看下ViewGroup的measureChildWithMargins()方法的实现：\n\n```java\npublic static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) {\n  final int specMode = MeasureSpec.getMode(measureSpec);\n  final int specSize = MeasureSpec.getSize(measureSpec);\n  final int result;\n  switch (specMode) {\n    case MeasureSpec.AT_MOST:\n      if (specSize < size) {\n        // 父View给定的最大尺寸小于完全显示内容所需尺寸\n        // 则在测量结果上加上MEASURED_STATE_TOO_SMALL\n        result = specSize | MEASURED_STATE_TOO_SMALL;\n      } else {\n       result = size;\n      }\n      break;\n    case MeasureSpec.EXACTLY:\n      // 若specMode为EXACTLY，则不考虑size，result直接赋值为specSize\n      result = specSize;\n      break;\n    case MeasureSpec.UNSPECIFIED:\n    default:\n      result = size;\n  }\n  return result | (childMeasuredState & MEASURED_STATE_MASK);\n}\n```\n\n对于普通View，会调用View类的onMeasure()方法来进行实际的测量工作，该方法的源码如下：\n\n```java\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n        getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n}\n```\n\n​\t对于普通View（非ViewgGroup）来说，只需完成自身的测量工作即可。以上代码中通过setMeasuredDimension()方法设置测量的结果，具体来说是以getDefaultSize()方法的返回值来作为测量结果。getDefaultSize()方法的源码如下：\n\n```java\npublic static int getDefaultSize(int size, int measureSpec) {\n  int result = size;\n  int specMode = MeasureSpec.getMode(measureSpec);\n  int specSize = MeasureSpec.getSize(measureSpec);\n  switch (specMode) {\n    case MeasureSpec.UNSPECIFIED:\n      result = size;\n      break;\n    case MeasureSpec.AT_MOST:\n    case MeasureSpec.EXACTLY:\n      result = specSize;\n      break;\n  }\n  return result;\n}\n```\n\n​\t由以上代码我们可以看到，View的getDefaultSize()方法对于AT_MOST和EXACTLY这两种情况都返回了SpecSize作为result。所以若我们的自定义View直接继承了View类，我们就要自己对wrap_content (对应了AT_MOST)这种情况进行处理，否则对自定义View指定wrap_content就和match_parent效果一样了。\n\n#### 2.2、layout阶段\n\nlayout阶段的基本思想也是由根View开始，递归地完成整个控件树的布局（layout）工作。\n\nView.layout()\n\n​\t我们把对decorView的layout()方法的调用作为布局整个控件树的起点，实际上调用的是View类的layout()方法，源码如下：\n\n```java\npublic void layout(int l, int t, int r, int b) {\n    // l为本View左边缘与父View左边缘的距离\n    // t为本View上边缘与父View上边缘的距离\n    // r为本View右边缘与父View左边缘的距离\n    // b为本View下边缘与父View上边缘的距离\n    . . .\n    boolean changed=isLayoutModeOptical(mParent)?setOpticalFrame(l, t, r, b):setFrame(l, t, r, b);\n    if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {\n        onLayout(changed, l, t, r, b);\n        . . .\n    }\n    . . .\n}\n```\n\n​\t这个方法会调用setFrame()方法来设置View的mLeft、mTop、mRight和mBottom四个参数，这四个参数描述了View相对其父View的位置（分别赋值为l, t, r, b），在setFrame()方法中会判断View的位置是否发生了改变，若发生了改变，则需要对子View进行重新布局，对子View的局部是通过onLayout()方法实现了。由于普通View（ 非ViewGroup）不含子View，所以View类的onLayout()方法为空。因此接下来，我们看看ViewGroup类的onLayout()方法的实现。\n\nViewGroup.onLayout()\n\n​\t实际上ViewGroup类的onLayout()方法是abstract，这是因为不同的布局管理器有着不同的布局方式。\n这里我们以decorView，也就是FrameLayout的onLayout()方法为例，分析ViewGroup的布局过程：\n\n```java\n@Override\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n    layoutChildren(left, top, right, bottom, false /* no force left gravity */);\n}\n\nprivate void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) {\n    final int count = getChildCount();\n    final int parentLeft = getPaddingLeftWithForeground();\n    final int parentRight = right - left - getPaddingRightWithForeground();\n    final int parentTop = getPaddingTopWithForeground();\n    final int parentBottom = bottom - top - getPaddingBottomWithForeground();\n    for (int i = 0; i < count; i++) {\n        final View child = getChildAt(i);\n        if (child.getVisibility() != GONE) {\n            final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n            final int width = child.getMeasuredWidth();\n            final int height = child.getMeasuredHeight();\n            int childLeft;\n            int childTop;\n            int gravity = lp.gravity;\n            if (gravity == -1) {\n                gravity = DEFAULT_CHILD_GRAVITY;\n            }\n            final int layoutDirection = getLayoutDirection();\n            final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);\n            final int verticalGravity = gravity & Gravity.VERTICAL_GRAVITY_MASK;\n            switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {\n                case Gravity.CENTER_HORIZONTAL:\n                    childLeft = parentLeft + (parentRight - parentLeft - width) / 2 +\n                            lp.leftMargin - lp.rightMargin;\n                    break;\n                case Gravity.RIGHT:\n                    if (!forceLeftGravity) {\n                        childLeft = parentRight - width - lp.rightMargin;\n                        break;\n                    }\n                case Gravity.LEFT:\n                default:\n                    childLeft = parentLeft + lp.leftMargin;\n\n            }\n            switch (verticalGravity) {\n                case Gravity.TOP:\n                    childTop = parentTop + lp.topMargin;\n                    break;\n                case Gravity.CENTER_VERTICAL:\n                    childTop = parentTop + (parentBottom - parentTop - height) / 2 +\n                            lp.topMargin - lp.bottomMargin;\n                    break;\n                case Gravity.BOTTOM:\n                    childTop = parentBottom - height - lp.bottomMargin;\n                    break;\n                default:\n                    childTop = parentTop + lp.topMargin;\n            }\n            child.layout(childLeft, childTop, childLeft + width, childTop + height);\n        }\n    }\n}\n```\n\n在上面的方法中，parentLeft表示当前View为其子View显示区域指定的一个左边界，也就是子View显示区域的左边缘到父View的左边缘的距离，parentRight、parentTop、parentBottom的含义同理。确定了子View的显示区域后，接下来，用一个for循环来完成子View的布局。\n在确保子View的可见性不为GONE的情况下才会对其进行布局。首先会获取子View的LayoutParams、layoutDirection等一系列参数。上面代码中的childLeft代表了最终子View的左边缘距父View左边缘的距离，childTop代表了子View的上边缘距父View的上边缘的距离。会根据子View的layout_gravity的取值对childLeft和childTop做出不同的调整。最后会调用child.layout()方法对子View的位置参数进行设置，这时便转到了View.layout()方法的调用，若子View是容器View，则会递归地对其子View进行布局。\n\n到这里，layout阶段的大致流程我们就分析完了，这个阶段主要就是根据上一阶段得到的View的测量宽高来确定View的最终显示位置。显然，经过了measure阶段和layout阶段，我们已经确定好了View的大小和位置，那么接下来就可以开始绘制View了。\n\n#### 2.3、draw阶段\n\n- View.draw(Canvas canvas)： 由于 ViewGroup 并没有复写此方法，因此，所有的视图最终都是调用 View 的 draw 方法进行绘制的。在自定义的视图中，也不应该复写该方法，而是复写 `onDraw(Canvas)` 方法进行绘制，如果自定义的视图确实要复写该方法，那么请先调用 `super.draw(canvas)`完成系统的绘制，然后再进行自定义的绘制。\n- View.onDraw()：\n  View 的`onDraw（Canvas）`默认是空实现，自定义绘制过程需要复写的方法，绘制自身的内容。\n- dispatchDraw() 发起对子视图的绘制。View 中默认是空实现，ViewGroup 复写了`dispatchDraw()`来对其子视图进行绘制。该方法我们不用去管，自定义的 ViewGroup 不应该对`dispatchDraw()`进行复写。\n\n对于本阶段的分析，我们以decorView.draw()作为分析的起点，也就是View.draw()方法，它的源码如下：\n\n```java\npublic void draw(Canvas canvas) {\n    . . .\n    // 绘制背景，只有dirtyOpaque为false时才进行绘制，下同\n    int saveCount;\n    if (!dirtyOpaque) {\n        drawBackground(canvas);\n    }\n     . . .\n    // 绘制自身内容\n    if (!dirtyOpaque) onDraw(canvas);\n    // 绘制子View\n    dispatchDraw(canvas);\n    . . .\n    // 绘制滚动条等\n    onDrawForeground(canvas);\n}\n```\n\n​\t简单起见，在上面的代码中我们省略了实现滑动时渐变边框效果相关的逻辑。实际上，View类的onDraw()方法为空，因为每个View绘制自身的方式都不尽相同，对于decorView来说，由于它是容器View，所以它本身并没有什么要绘制的。dispatchDraw()方法用于绘制子View，显然普通View（非ViewGroup）并不能包含子View，所以View类中这个方法的实现为空。\n\nViewGroup类的dispatchDraw()方法中会依次调用drawChild()方法来绘制子View，drawChild()方法的源码如下：\n\n```java\nprotected boolean drawChild(Canvas canvas, View child, long drawingTime) {\n  return child.draw(canvas, this, drawingTime);\n}\n```\n\n​\t这个方法调用了View.draw(Canvas, ViewGroup，long)方法来对子View进行绘制。在draw(Canvas, ViewGroup, long)方法中，首先对canvas进行了一系列变换，以变换到将要被绘制的View的坐标系下。完成对canvas的变换后，便会调用View.draw(Canvas)方法进行实际的绘制工作，此时传入的canvas为经过变换的，在将被绘制View的坐标系下的canvas。\n\n进入到View.draw(Canvas)方法后，会向之前介绍的一样，执行以下几步：\n\n- 绘制背景;\n\n- 通过onDraw()绘制自身内容;\n\n- 通过dispatchDraw()绘制子View;\n\n- 绘制滚动条\n\n  \n\n![](Android知识-二-View的绘制流程/draw_method_flow.png)\n\n[**Measure、Layout、Draw详解**](http://www.cnblogs.com/jycboy/p/6066654.html)\n\n","tags":["Android"]},{"title":"Android知识(一)--View事件传递","url":"/2018/02/24/Android知识(一)-View事件传递/","content":"\n### 1、View事件基础知识\n\n　　(1) 所有 Touch 事件都被封装成了 MotionEvent 对象，包括 Touch 的位置、时间、历史记录以及第几个手指(多指触摸)等；\n\n　　(2) 事件类型分为 ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_POINTER_DOWN, ACTION_POINTER_UP, ACTION_CANCEL，每个事件都是以 ACTION_DOWN 开始 ACTION_UP 结束；\n\n　　(3) 对事件的处理包括三类，分别为传递——dispatchTouchEvent()函数、拦截——onInterceptTouchEvent()函数、消费——onTouchEvent()函数和 OnTouchListener；\n\n　　(4)、事件一定是先到达父控件上；\n\n　　(5)、父控件和父类不是一回事，这两个概念初学者很容易混淆。\n\n### 2、View事件模型\n\n​\t所谓的事件模型就是：控件→子控件\n\n​\t事件模型主要涉及到3个概念：事件的分发、事件的拦截、事件的响应。\n\n#### ​\t2.1、事件分发主要分为以下三种情况\n\n​\t\tA、首先会先调用自身的onInterceptTouchEvent方法，调用此方法的目的是为了，先让自己这个控件判断下是否需要把此事件拦截下来，如果拦截下来，那么就代表自己这个控件需要处理这个事件，所以此时会调用自身onTouchEvent来对这个事件进行响应。\n\n​\t\tB、如果不拦截下来，那么才会有后续的事件向下传递的流程。将这个事件传递给子控件。现在子控件接收到了这个事件，上文提过，一个事件到达一个View或者ViewGroup，就会最先调用这个控件的dispatchTouchEvent，所以此时，事件到达子控件的dispatchTouchEvent方法，如果这个控件仍然是一个ViewGroup的类型，那么事件继续分发的逻辑依然遵循A流程的逻辑。\n\n​\t\tC、如果这个子控件只是一个View，而不是ViewGroup，那么此时，事件分发的逻辑略有不同。由于View没有onInterceptTouchEvent的方法，所以当一个事件到达这个View的dispatchTouchEvent的时候，dispatchTouchEvent就调用不到onInterceptTouchEvent，它会直接调用onTouchEvent的方法，直接让这个View来响应此事件。\n\n#### ​\t2.2、事件响应\n\n![event_respose](Android知识-View事件传递/event_respose.jpg)\n\n​        如上图所示，如果ViewGroupB拦截了事件，那么此时事件就会由ViewGroupB来响应，调用ViewGroupB中的onTouchEvent，此时ViewGroupB中的onTouchEvent的返回值有两种可能，一种是true，一种是false，如果返回true，则代表ViewGroupB消费了此事件，事件此时终止。如果返回的值是false，那么此时这个事件会回传给父控件，调用到父控件的onTouchEvent方法，由父控件来进行响应，那父控件的onTouchEvent也是同样的逻辑。要么消费事件，要么回传给父控件的父控件。\n　　此时，就可以得出我们通常所说的两个方向：\n　　(1)、事件传递的方向：父控件→子控件\n　　(2)、事件响应的方向：子控件→父控件\t\n\n​\t当然，仅仅是这个结论是无法满足我们实际开发的需要，我们需要更细致的分析。这里有一个细节上的问题需要注意，就是事件分为Down事件、Move事件、Up事件，任何一种事件都遵循事件传递和响应的逻辑原则，很多开发者常常会认为Down-Move-Up连在一起才是一个事件的产生，这种想法是不对的。\n事件的起点是由Down事件开始的，然后产生一系列的Move事件，最后通常以Up事件结束。当Down事件产生的时候，会由父控件传递给子控件，Move事件也由父控件传递给子控件，Up事件也由父控件传递给子控件。它们都遵循同样的传递事件的逻辑流程。不过Down事件最终响应的结果，会影响到后续事件的执行。这句话是什么意思呢？\n\n#### ​\t2.3 、事件拦截\n\n​\t如果Down事件传递到了子View上，但是子View的onTouchEvent对于这个Down事件的处理是return了一个false，这样的结果就是会造成父View的onTouchEvent的调用，同时还有另外一个后果，那就是后续的Move事件、Up事件就都传递不到子View上。所以，如果一个View要处理滑动事件，也就是Move事件的话，那么它一定不能在onTouchEvent中，对Down事件return false。\n\n　　如果Down事件到了父View上，父View需要调用自身的onInterceptTouchEvent判断是否对这个Down事件进行拦截，如果拦截，return了true，那么这个事件就会到父View的onTouchEvent中进行响应。如果此时父View的onTouchEvent也返回了true，那么代表这个父View响应了Down事件。不过这里有一点不太一样的地方是，事件传递到父View的onTouchEvent方法是因为自身的onInterceptTouchEvent方法判断拦截导致的，而不是由子View回传回来的，在这种情况下，当Move事件、Up事件传递到父View的时候，它当然不会传递给子View，并且，也不再调用自身的onInterceptTouchEvent方法。\n\n#### \t2.4 、事件冲突的解决\n\n　　理解事件传递的基本逻辑，对于工作过程中解决滑动事件冲突非常有帮助。比如我们此时有一个父控件ViewPager，这个ViewPager其中一个Item是ScrollView，此时会发生什么问题呢？当ViewPager滑动到ScrollView这个条目的时候，再左右滑动，发现ViewPager再也左右滑动不了了。这是为什么呢？我们结合图6一起来分析一下。\n\n\n　　(1)、我们都知道ViewPager是能够横向滑动的控件，而ScrollView是纵向滑动的控件，当Down事件产生的时候，此时会由ViewPager传递给ScrollView，ViewPager没有对Down事件拦截，ScrollView也不会对这个Down事件进行拦截，所以事件就会传递给ScrollView的孩子，也就是类似于图6中的子View，子View如果没有对Down事件响应，那么最后会到ScrollView中的onTouchEvent，而ScrollView的onTouchEvent对于这个Down事件返回了true，代表ScrollView消费了这个Down事件。\n\n\n　　(2)、接下来开始滑动手指，产生一系列的Move事件。Move事件也是由ViewPager传递给ScrollView。由于Down事件是被ScrollView的onTouchEvent中消费的，所以Move事件就不会传递给ScrollView的子控件了。一系列的Move事件也是在ScrollView的onTouchEvent中被执行。\n\n\n　　(3)、最后的Up事件也是由ScrollView中的onTouchEvent消费。\n\n\n　　从上述1至3的步骤中，我们看出来无论是Down事件、Move事件还是Up事件，最后全部都是被ScrollView所消费。从头到尾ViewPager的onTouchEvent都没有得到执行。而ViewPager之所以能够左右滑动，正是因为ViewPager的onTouchEvent里面的代码逻辑产生的效果。ViewPager的onTouchEvent没有执行，这个ViewPager当然就不能够左右滑动了。所以解决上述问题，就是在于如何让ViewPager中的onTouchEvent方法执行。\n我们可以自定义一个MyViewPager继承ViewPager，重写onInterceptTouchEvent方法，如果我们在onInterceptTouchEvent方法中直接野蛮地return一个true，此时就代表无论是Down事件、Move事件，还是Up事件，全部都拦截下来了，拦截在MyViewPager中，我们可以认为是图6中的ViewGroupB，既然拦截下来了所有事件，那么所有事件就会传递到MyViewPager的onTouchEvent，所以此时，这个MyViewPager一定可以左右滑动。\n\n　　但是，由此会引发另外一个问题，就是这个ScrollView不能上下滑动了。这又是为什么呢？因为ScrollView能够上下滑动的代码逻辑在ScrollView中的onTouchEvent方法内，而此时事件又全部被MyViewPager拦截了下来，ScrollView完全得不到事件，onTouchEvent方法得不到执行，自然不能上下滑动。所以我们需要修改MyViewPager中的onInterceptTouchEvent的逻辑。\n\n\n　　ViewPager只对左右滑动感兴趣，而ScrollView对上下滑动这个动作感兴趣，所以我们只需要在MyViewPager的onInterceptTouchEvent中，根据多个Move事件，判断是左右滑动还是上下滑动，如果是左右滑动，return true将事件拦截下来，如果是上下滑动，return false将事件传递给ScrollView，这样就能解决问题了。\n所以，对于Down事件，我们一般都不进行拦截，判断是否拦截得根据一些列的Move事件才能得出具体的条件是否成立。\n\n#### \t2.5、Cancel事件的产生：\n\n　　刚才我们说了事件一般有三个，Down、Move、Up，这三个事件比较好理解。其实还有一种事件就是Cancel事件。它代表什么含义呢？\n还是回到图6，如果一个Down事件产生了，这个Down事件从ViewGroupA传递到ViewGroupB，最终到达子View，被子View的onTouchEvent消费，return了true，那么此时Down事件就终止了。接下来后续的Move事件也会从ViewGroupA传递给ViewGroupB，也就是说ViewGroupA和ViewGroupB会比子View更先拿到Move事件，那既然ViewGroupA和ViewGroupB比子View更先拿到Move事件，那么他们当中的任何一个都有可能在某一个Move事件中，把这个Move事件给拦截下来，一旦Move事件被拦截下来了，子View肯定就拿不到这个Move事件了，不过，此时子View会产生一个新的事件，就是Cancel事件。\n\n\n　　所以一个正常的事件序列是 Down→Move→Up,这样才被认为是一个正常的事件序列。如果一个View响应的Down事件，可是却被没有正常结尾，Move事件或者Up事件被拦截了，此时非正常结尾的情况就会给子View产生一个新的事件Cancel。\n\n#### \t2.7、子控件可以影响父控件是否拦截的行为\n\n　　子控件是可以干预父控件是否拦截事件的结果。通过在子View中dispatchTouchEvent中增加一行代码即可。getParent().requestDisallowInterceptTouchEvent(true);这行代码就可以请求父控件不要拦截事件。\n\n\n　　很多人可能不太明白这句话的意思，既然事件一定是先到达父控件，然后才到达子View，那也就是getParent().requestDisallowInterceptTouchEvent(true);这句话是在父控件是否拦截判断结束之后才调用，怎么能改变父控件是否拦截的结果呢，这里存在一个执行先后顺序的疑惑。\n　　\n\n　　其实是这样的，getParent().requestDisallowInterceptTouchEvent(true);达到的效果不是修改父控件对本次事件是否拦截的结果，而影响的是后续事件。比如子View在Down事件中调用了getParent().requestDisallowInterceptTouchEvent(true);这行代码，那么在后续Move事件、Up事件产生到达父控件的时候，父控件就不会再拦截了。所以getParent().requestDisallowInterceptTouchEvent(true);只会影响Move事件和Up事件，影响不到Down事件。","tags":["Android"]},{"title":"JDK源码导读","url":"/2018/02/15/JDK源码导读/","content":"\n**注：标题为包名，后面序号为优先级1-4，优先级递减** \n\n#### 1、java.lang\n\n| 序号 |                             类名                             | 优先级 | 备注 |\n| :--: | :----------------------------------------------------------: | :----: | :--: |\n|  1   | <u>[Object](https://alex0605.github.io/2017/10/18/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%E4%B8%80-Object%E7%B1%BB/)</u> |   1    |      |\n|  2   | [<u>String</u>](https://alex0605.github.io/2017/10/19/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%E4%BA%8C-String%E7%B1%BB/) |   1    |      |\n|  3   | <u>[AbstractStringBuilder](https://alex0605.github.io/2017/10/20/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%E4%B8%89-AbstractStringBuilder%E7%B1%BB/)</u> |   1    |      |\n|  4   |                         StringBuffer                         |   1    |      |\n|  5   |                        StringBuilder                         |   1    |      |\n|  6   |                           Boolean                            |   2    |      |\n|  7   |                             Byte                             |   2    |      |\n|  8   |                            Double                            |   2    |      |\n|  9   |                            Float                             |   2    |      |\n|  10  |                           Integer                            |   2    |      |\n|  11  |                             Long                             |   2    |      |\n|  12  |                            Short                             |   2    |      |\n|  13  |                            Thread                            |   2    |      |\n|  14  |                         ThreadLocal                          |   2    |      |\n|  15  |                             Enum                             |   3    |      |\n|  16  |                          Throwable                           |   3    |      |\n|  17  |                            Error                             |   3    |      |\n|  18  |                          Exception                           |   3    |      |\n|  19  |                            Class                             |   4    |      |\n|  20  |                         ClassLoader                          |   4    |      |\n|  21  |                           Compiler                           |   4    |      |\n|  22  |                            System                            |   4    |      |\n|  23  |                           Package                            |   4    |      |\n|  24  |                             Void                             |   4    |      |\n\n#### 2、java.util\n\n| 序号 |     类名      | 优先级 | 备注 |\n| :--: | :-----------: | :----: | :--: |\n|  1   | AbstractList  |   1    |      |\n|  2   |  AbstractMap  |   1    |      |\n|  3   |  AbstractSet  |   1    |      |\n|  4   |   ArrayList   |   1    |      |\n|  5   |  LinkedList   |   1    |      |\n|  6   |    HashMap    |   1    |      |\n|  7   |   Hashtable   |   1    |      |\n|  8   |    HashSet    |   1    |      |\n|  9   | LinkedHashMap |   1    |      |\n|  10  | LinkedHashSet |   1    |      |\n|  11  |    TreeMap    |   1    |      |\n|  12  |    TreeSet    |   1    |      |\n|  13  |    Vector     |   2    |      |\n|  14  |     Queue     |   2    |      |\n|  15  |     Stack     |   2    |      |\n|  16  |   SortedMap   |   2    |      |\n|  17  |   SortedSet   |   2    |      |\n|  18  |  Collections  |   3    |      |\n|  19  |    Arrays     |   3    |      |\n|  20  |  Comparator   |   3    |      |\n|  21  |   Iterator    |   3    |      |\n|  22  |    Base64     |   4    |      |\n|  23  |     Date      |   4    |      |\n|  24  | EventListener |   4    |      |\n|  25  |    Random     |   4    |      |\n|  26  |    SubList    |   4    |      |\n|  27  |     Timer     |   4    |      |\n|  28  |     UUID      |   4    |      |\n|  29  |  WeakHashMap  |   4    |      |\n\n#### 3、java.util.concurrent\n\n| 序号 |            类名            | 优先级 | 备注 |\n| :--: | :------------------------: | :----: | :--: |\n|  1   |     ConcurrentHashMap      |   1    |      |\n|  2   |          Executor          |   2    |      |\n|  3   |  AbstractExecutorService   |   2    |      |\n|  4   |      ExecutorService       |   2    |      |\n|  5   |     ThreadPoolExecutor     |   2    |      |\n|  6   |       BlockingQueue        |   2    |      |\n|  7   | AbstractQueuedSynchronizer |   2    |      |\n|  8   |       CountDownLatch       |   2    |      |\n|  9   |         FutureTask         |   2    |      |\n|  10  |         Semaphore          |   2    |      |\n|  11  |       CyclicBarrier        |   2    |      |\n|  12  |    CopyOnWriteArrayList    |   3    |      |\n|  13  |      SynchronousQueue      |   3    |      |\n|  14  |       BlockingDeque        |   3    |      |\n|  15  |          Callable          |   4    |      |\n\n#### 4、java.util.concurrent.atomic\n\n| 序号 |      类名       | 优先级 | 备注 |\n| :--: | :-------------: | :----: | :--: |\n|  1   |  AtomicBoolean  |   2    |      |\n|  2   |  AtomicInteger  |   2    |      |\n|  3   |   AtomicLong    |   2    |      |\n|  4   | AtomicReference |   3    |      |\n\n#### 5、java.lang.reflect\n\n| 序号 |  类名  | 优先级 | 备注 |\n| :--: | :----: | :----: | ---- |\n|  1   | Field  |   2    |      |\n|  2   | Method |   2    |      |\n\n#### 6、java.lang.annotation\n\n| 序号 |    类名     | 优先级 | 备注 |\n| :--: | :---------: | :----: | :--: |\n|  1   | Annotation  |   3    |      |\n|  2   |   Target    |   3    |      |\n|  3   |  Inherited  |   3    |      |\n|  4   |  Retention  |   3    |      |\n|  5   | Documented  |   4    |      |\n|  6   | ElementType |   4    |      |\n|  7   |   Native    |   4    |      |\n|  8   | Repeatable  |   4    |      |\n\n#### 7、java.util.concurrent.locks\n\n| 序号 |          类名          | 优先级 | 备注 |\n| :--: | :--------------------: | :----: | :--: |\n|  1   |          Lock          |   2    |      |\n|  2   |       Condition        |   2    |      |\n|  3   |     ReentrantLock      |   2    |      |\n|  4   | ReentrantReadWriteLock |   2    |      |\n\n#### 8、java.io\n\n| 序号 |     类名     | 优先级 | 备注 |\n| :--: | :----------: | :----: | :--: |\n|  1   |     File     |   3    |      |\n|  2   | InputStream  |   3    |      |\n|  3   | OutputStream |   3    |      |\n|  4   |    Reader    |   4    |      |\n|  5   |    Writer    |   4    |      |\n\n#### 9、java.nio\n\n| 序号 |     类名     | 优先级 | 备注 |\n| :--: | :----------: | :----: | :--: |\n|  1   |    Buffer    |   3    |      |\n|  2   |  ByteBuffer  |   4    |      |\n|  3   |  CharBuffer  |   4    |      |\n|  4   | DoubleBuffer |   4    |      |\n|  5   | FloatBuffer  |   4    |      |\n|  6   |  IntBuffer   |   4    |      |\n|  7   |  LongBuffer  |   4    |      |\n|  8   | ShortBuffer  |   4    |      |\n\n#### 10、java.sql\n\n| 序号 |     类名      | 优先级 | 备注 |\n| :--: | :-----------: | :----: | :--: |\n|  1   |  Connection   |   3    |      |\n|  2   |    Driver     |   3    |      |\n|  3   | DriverManager |   3    |      |\n|  4   |   JDBCType    |   3    |      |\n|  5   |   ResultSet   |   4    |      |\n|  6   |   Statement   |   4    |      |\n\n#### 11、java.net\n\n| 序号 |     类名     | 优先级 | 备注 |\n| :--: | :----------: | :----: | :--: |\n|  1   |    Socket    |   3    |      |\n|  2   | ServerSocket |   3    |      |\n|  3   |     URI      |   4    |      |\n|  4   |     URL      |   4    |      |\n|  5   |  URLEncoder  |   4    |      |\n\n#### 12、阅读笔记简版\n##### 12.1、Object \n\n- 1) wait(), notify(), notifyAll(), wait(timeout) \n- 2) hashCode(), equals() \n- 3) clone()\n\n##### 12.2、String \n\n- 1) char[] value \n- 2) int hash \n- 3) equals(), startWith(), endWith(), replace\n\n##### 12.3、AbstractStringBuilder \n\n- 1) char[] value \n- 2) int count \n- 3) 扩容：翻倍，不够取所需最小\n\n##### 12.4、StringBuffer \n\n- 1) 继承AbstractStringBuilder \n- 2) synchronized方法保证线程安全 \n- 3) char[] toStringCache\n\n##### 12.5、StringBuilder 继承AbstractStringBuilder\n\n##### 12.6、ArrayList \n\n- 1) Object[] elementData \n- 2) int size \n- 3) 默认大小10 \n- 4) 扩容：翻倍，不够取所需最小\n\n##### 12.7、LinkedList \n\n- 1) Node {E item, Node prev, Node next} \n- 2) int size \n- 3) Node first \n- 4) Node last \n- 5) linkFirst(), linkLast(), linkBefore(), unLinkFirst(), unLinkLast(), unLink(), indexOf()\n\n##### 12.8、HashMap \n\n- 1) Node{int hash, K key, V value, Node next}\n- 2) 默认容量16，负载因子0.75f \n- 3) int size, modCount, threshold, float loadFactor \n- 4) Node[] table \n- 5) Set entrySet \n- 6) put():根据key算hash，根据容量和hash算index，table[index]没有直接添加到数组中，table[index]有，若index位置同一个key则更新，否则遍历next是否有，有则更新，无则新增，最后根据thread与size判断是否扩容。注：扩容时容量翻倍，重新算hash复制到新数组 \n- 7）get()类似 \n  注：先比较hash，若相等在比较equals\n\n##### 12.9、Hashtable \n\n- 1) 结构实现与HashMap基本一致 \n- 2)通过synchronized方法保证线程安全\n\n##### 12.10、HashSet：委托给HashMap，其Value是同一个默认对象\n\n##### 12.11、LinkedHashMap继承HashMap \n\n- 1) Entry{HashMap.Node, Entry before, after} \n- 2) Entry head, tail \n- 3) 重写newNode()添加节点时，除像HashMap中添加外，保存before、after信息\n\n##### 12.12、LinkedHashSet继承HashSet：不知道如何实现的顺序？\n\n##### 12.13、AbstractMap维护EntrySet，AbstractSet维护Iterator，AbstractList维护Iterator\n\n##### 12.14、ConcurrentHashMap \n\n1) JDK1.7及以前： \n\n- a、Segment[] ,HashEntry[] , HashEntry{hash, k, v, next} \n- b、根据key算hash，根据hash和Segment的大小算位置，每个segment拥有一个自己的HashEntry[] \n- c、get()：不加锁，volatile类型 \n- d、put(): 对相应segment加锁 \n- e、size()：各HashEntry[] 之和，先不加锁算两遍，若一致则返回，若不一致则加锁重新计算 \n\n2）JDK1.8 \n\n- a、Node{hash, key, value, next} \n- b、Node[] table \n- c、大多数操作类似于HashMap，不同CAS方式设置，根据key算hash，在根据hash和容量算index，对table[index]加锁，从而达到更大的并发量 \n- d、get(): 同HashMap \n- e、put(): 对table[index]加锁\n\n##### 12.15、TreeMap \n\n- 1）红黑树，即自平衡二叉查找树，时间复杂度O(logn) \n- 2）Entry{K k, V v, Entry parent, left, right, boolean color} \n- 3）Entry root，int size， int modeCount\n\n##### 12.16、TreeSet：委托TreeMap实现","tags":["Java","源码阅读"]},{"title":"Nexus 搭建私有maven仓库","url":"/2018/02/11/Nexus-搭建私有maven仓库/","content":"\n### 一、什么是Maven,Gradle?\n\n​\tMaven 是一个项目管理和自动构建工具。Maven 包集中存放的地方，就是 Maven 仓库。这些仓库，可以是放在本地，也可以放在某个远程服务器上。 可以是私有仓库，也可以是公开的。下开发用的库列表：\n\n```groovy\nmavenCentral();\njcenter()\nmaven {\n     url 'file:///Users/my-user-name/Documents/Android/repo/'\n}\nmaven {\n     url 'http://localhost:8081/nexus/content/repositories/releases/'\n}\n```\n\nAndroid Studio Gradle 主要支持两个 Maven 中央库：mavenCentral 和 jcenter。\n\nmavenCentral 是最早的 maven 中央仓库\njcenter 是 Android Studio 0.8 版本起的默认 maven 中央仓库\n第三个是我的本机的仓库\n第四个是笔者部署在内网服务器的私有仓库\n\n​\tGradle 是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML\n\n### 二、使用Nexus搭建maven私服\n\n1.Nexus 下载安装：\n\n​\t官网下载地址：http://www.sonatype.org/nexus/go/，我的开发环境是Windows，我下载的是Nexus Repository Manager OSS 2.xx下面的 All platforms nexus-2.14.10-01-bundle.zip压缩文件。\n\n2.Nexus 启动：\n\n​\t下载完成之后，解压后进入\\nexus-2.14.10-01-bundle\\bin\\jsw\\，根据操作系统类型选择文件夹，我选的是windows-x86-32文件夹，进入后可看到如下所示bat文件。 \n\n![start_select](Nexus-搭建私有maven仓库/start_select.png)\n\n​\t双击console-nexus.bat运行。再浏览器中输入[http://127.0.0.1:8081/nexus/，](http://127.0.0.1:8081/nexus/)出现下图所示就代表nexus已经启动成功了。\n\n![nexus_home](Nexus-搭建私有maven仓库/nexus_home.png)\n\n​\t8081是默认的端口号，要修改端口号，进入\\conf\\打开nexus.properties文件，修改application-port属性值就可以了。 \n默认的用户名和密码分别是：admin和admin123。点击右上角的log in 登录后如图所示： \n点击左侧的 repositories 查看现有的仓库列表： \n\n![maven_type](Nexus-搭建私有maven仓库/maven_type.png)\n\n3.Nexus仓库：\n这里的仓库分了四种类型\n\nhosted(宿主仓库):用来部署自己,第三方或者公共仓库的构件\n\nproxy(代理仓库):代理远程仓库\n\nvirtual(虚拟仓库):默认提供了一个 Central M1虚拟仓库 用来将maven 2适配为maven 1\n\ngroup(仓库组):统一管理多个仓库\n\n\n\nPublic Repositories: 仓库组\n\n3rd party: 无法从公共仓库获得的第三方发布版本的构件仓库\n\nApache Snapshots: 用了代理ApacheMaven仓库快照版本的构件仓库\n\nCentral: 用来代理maven中央仓库中发布版本构件的仓库\n\nCentral M1 shadow: 用于提供中央仓库中M1格式的发布版本的构件镜像仓库\n\nCodehaus Snapshots: 用来代理CodehausMaven 仓库的快照版本构件的仓库\n\nReleases: 用来部署管理内部的发布版本构件的宿主类型仓库\n\nSnapshots:用来部署管理内部的快照版本构件的宿主类型仓库\n\n4.建立Nexus宿主仓库\n\n​\t新建一个内部仓库，步骤为Repositories –> Add –> Hosted Repository，在页面的下半部分输入框中填入Repository ID和Repository Name即可，另外把Deployment Policy设置为Allow Redeploy，点击save就创建完成了。这里我点击添加宿主类型的仓库，在仓库列表的下方会出现新增仓库的配置，如下所示： \n\n![1001](Nexus-搭建私有maven仓库/1001.png)\n\n​\t建立好新的仓库之后需要配置一下相关账号信息.在安全选项下选择用户选项,可以看到三个默认的账号,分别是管理员账号,部署账号和Nexus账号.正常访问仓库内容的时候是不需要这三个账户的,一般也就是把部署账号暴露出去,方便仓库项目维护人员部署项目使用.所以这里可以用默认的Deployment账户(记得重置下密码).也可以新建一个账号来使用,新建的时候可以通过add role management来控制该账号的权限。 \n​\t点击新建的仓库的url可以直接如今仓库的路劲，因为现在还没有部署项目，所以是空的仓库。","tags":["Git","Maven"]},{"title":"Git命令速查手册","url":"/2018/01/29/Git命令速查手册/","content":"\n### 1、初始化仓库\n\n```java\ngit init\n```\n\n### 2、将文件添加到仓库\n\n```java\ngit add 文件名 # 将工作区的某个文件添加到暂存区   \n\ngit add -u # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，不处理untracked的文件\n\ngit add -A # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，包括untracked的文件\n\ngit add . # 将当前工作区的所有文件都加入暂存区\n\ngit add -i # 进入交互界面模式，按需添加文件到缓存区\n```\n\n\n\n### 3、将暂存区文件提交到本地仓库\n\n```\ngit commit -m \"提交说明\" # 将暂存区内容提交到本地仓库\n\ngit commit -a -m \"提交说明\" # 跳过缓存区操作，直接把工作区内容提交到本地仓库\n```\n\n\n\n### 4、查看仓库当前状态\n\n```\ngit status\n```\n\n\n\n### 5、比较文件异同\n\n```\ngit diff # 工作区与暂存区的差异\n\ngit diff 分支名 #工作区与某分支的差异，远程分支这样写：remotes/origin/分支名\n\ngit diff HEAD  # 工作区与HEAD指针指向的内容差异\n\ngit diff 提交id 文件路径 # 工作区某文件当前版本与历史版本的差异\n\ngit diff --stage # 工作区文件与上次提交的差异(1.6 版本前用 --cached)\n\ngit diff 版本TAG # 查看从某个版本后都改动内容\n\ngit diff 分支A 分支B # 比较从分支A和分支B的差异(也支持比较两个TAG)\n\ngit diff 分支A...分支B # 比较两分支在分开后各自的改动\n\n\\# 另外：如果只想统计哪些文件被改动，多少行被改动，可以添加 --stat 参数\n```\n\n\n\n### 6、查看历史记录\n\n```\ngit log # 查看所有commit记录(SHA-A校验和，作者名称，邮箱，提交时间，提交说明)\n\ngit log -p -次数 # 查看最近多少次的提交记录\n\ngit log --stat # 简略显示每次提交的内容更改\n\ngit log --name-only # 仅显示已修改的文件清单\n\ngit log --name-status # 显示新增，修改，删除的文件清单\n\ngit log --oneline # 让提交记录以精简的一行输出\n\ngit log –graph –all --online # 图形展示分支的合并历史\n\ngit log --author=作者  # 查询作者的提交记录(和grep同时使用要加一个--all--match参数)\n\ngit log --grep=过滤信息 # 列出提交信息中包含过滤信息的提交记录\n\ngit log -S查询内容 # 和--grep类似，S和查询内容间没有空格\n\ngit log fileName # 查看某文件的修改记录，找背锅专用\n```\n\n\n\n### 7、代码回滚\n\n```\ngit reset HEAD^ # 恢复成上次提交的版本\n\ngit reset HEAD^^ # 恢复成上上次提交的版本，就是多个^，以此类推或用~次数\n\ngit reflog\n\ngit reset --hard 版本号\n\n--soft：只是改变HEAD指针指向，缓存区和工作区不变；\n\n--mixed：修改HEAD指针指向，暂存区内容丢失，工作区不变；\n\n--hard：修改HEAD指针指向，暂存区内容丢失，工作区恢复以前状态；\n```\n\n\n\n### 8、同步远程仓库\n\n```\ngit push -u origin master\n```\n\n\n\n### 9、删除版本库文件\n\n```\ngit rm 文件名\n```\n\n\n\n### 10、版本库里的版本替换工作区的版本\n\n```\ngit checkout -- test.txt\n```\n\n\n\n### 11、本地仓库内容推送到远程仓库\n\n```\ngit remote add origin git@github.com:帐号名/仓库名.git\n```\n\n\n\n### 12、从远程仓库克隆项目到本地\n\n```\ngit clone git@github.com:git帐号名/仓库名.git\n```\n\n\n\n### 13、创建分支\n\n```\ngit checkout -b dev\n\n-b表示创建并切换分支\n\n上面一条命令相当于下面的二条：\n\ngit branch dev //创建分支\n\ngit checkout dev //切换分支\n```\n\n\n\n### 14、查看分支\n\n```\ngit branch\n```\n\n\n\n### 15、合并分支\n\n```\ngit merge dev\n\n//用于合并指定分支到当前分支\n\ngit merge --no-ff -m \"merge with no-ff\" dev\n\n//加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并\n```\n\n\n\n### 16、删除分支\n\n```\ngit branch -d dev\n```\n\n\n\n### 17、查看分支合并图\n\n```\ngit log --graph --pretty=oneline --abbrev-commit\n```\n\n\n\n### 18、查看远程库信息\n\n```\ngit remote\n\n// -v 显示更详细的信息\n```\n\n\n\n### 19、git相关配置\n\n\\\n\n```\n# 安装完Git后第一件要做的事，设置用户信息(global可换成local在单独项目生效)：\n\ngit config --global user.name \"用户名\" # 设置用户名\n\ngit config --global user.email \"用户邮箱\"   #设置邮箱\n\ngit config --global user.name   # 查看用户名是否配置成功\n\ngit config --global user.email   # 查看邮箱是否配置\n\n\\# 其他查看配置相关\n\ngit config --global --list  # 查看全局设置相关参数列表\n\ngit config --local --list # 查看本地设置相关参数列表\n\ngit config --system --list # 查看系统配置参数列表\n\ngit config --list  # 查看所有Git的配置(全局+本地+系统)\n\ngit config --global color.ui true //显示git相关颜色\n```\n\n\n\n### 20、撤消某次提交\n\n```\ngit revert HEAD # 撤销最近的一个提交\n\ngit revert 版本号 # 撤销某次commit\n```\n\n\n\n### 21、拉取远程分支到本地仓库\n\n```\ngit checkout -b 本地分支 远程分支 # 会在本地新建分支，并自动切换到该分支\n\ngit fetch origin 远程分支:本地分支 # 会在本地新建分支，但不会自动切换，还需checkout\n\ngit branch --set-upstream 本地分支 远程分支 # 建立本地分支与远程分支的链接\n```\n\n\n\n### 22、标签命令\n\n```\ngit tag 标签 //打标签命令，默认为HEAD\n\ngit tag //显示所有标签\n\ngit tag 标签 版本号 //给某个commit版本添加标签\n\ngit show 标签 //显示某个标签的详细信息\n```\n\n\n\n### 23、同步远程仓库更新\n\n```\ngit fetch  origin master\n\n//从远程获取最新的到本地，首先从远程的origin的master主分支下载最新的版本到origin/master分支上，然后比较本地的master分支和origin/master分支的差别，最后进行合并。\n\ngit fetch比git pull更加安全\n```\n\n","tags":["Git"]},{"title":"机器学习入门（一）","url":"/2018/01/25/机器学习入门（一）/","content":"\n\n\n# 机器学习入门\n\n## 一、定义\n\n使用算法解析数据，从中学习，然后对世界上的某件事情做出决定或预测\n\n机器学习是人工智能的一个分支。人工智能致力于创造出比人类更能完成复杂任务的机器。这些任务通常涉及判断、策略和认知推理，这些技能最初被认为是机器的“禁区”。虽然这听起来很简单，但这些技能的范围非常大——语言处理、图像识别、规划等等。\n\n## 二、分类\n\n1、监督学习\n\n监督学习涉及一组标记数据。计算机可以使用特定的模式来识别每种标记类型的新样本。监督学习的两种主要类型是分类和回归。在分类中，机器被训练成将一个组划分为特定的类。分类的一个简单例子是电子邮件帐户上的垃圾邮件过滤器。过滤器分析你以前标记为垃圾邮件的电子邮件，并将它们与新邮件进行比较。如果它们匹配一定的百分比，这些新邮件将被标记为垃圾邮件并发送到适当的文件夹。那些比较不相似的电子邮件被归类为正常邮件并发送到你的邮箱。\n      第二种监督学习是回归。在回归中，机器使用先前的(标记的)数据来预测未来。天气应用是回归的好例子。使用气象事件的历史数据(即平均气温、湿度和降水量)，你的手机天气应用程序可以查看当前天气，并在未来的时间内对天气进行预测。\n\n2、非监督学习\n      \n\n在无监督学习中，数据是无标签的。由于大多数真实世界的数据都没有标签，这些算法特别有用。无监督学习分为聚类和降维。聚类用于根据属性和行为对象进行分组。这与分类不同，因为这些组不是你提供的。聚类的一个例子是将一个组划分成不同的子组(例如，基于年龄和婚姻状况)，然后应用到有针对性的营销方案中。降维通过找到共同点来减少数据集的变量。大多数大数据可视化使用降维来识别趋势和规则。\n\n3、强化学习\n      \n\n强化学习使用机器的个人历史和经验来做出决定。强化学习的经典应用是玩游戏。与监督和非监督学习不同，强化学习不涉及提供“正确的”答案或输出。相反，它只关注性能。这反映了人类是如何根据积极和消极的结果学习的。很快就学会了不要重复这一动作。同样的道理，一台下棋的电脑可以学会不把它的国王移到对手的棋子可以进入的空间。然后，国际象棋的这一基本教训就可以被扩展和推断出来，直到机器能够打(并最终击败)人类顶级玩家为止。","tags":["人工智能","机器学习"]},{"title":"Android Studio Gradle详解","url":"/2018/01/18/Android-Studio-Gradle详解/","content":"\n## 1、AppExtension类及其属性\n### 1.1 基础介绍\n&emsp; &emsp;可能大部分人看到AppExtension类会感觉到非常的陌生，其实我们在app中的build.gradle中填写配置信息的时候，经常看到它，它是什么呢？\n&emsp; &emsp;如果你按ctrl+鼠标左键对着android{},点击进去就知道了，其实android{…}表示的就是AppExtension这个类。\n下图是AppExtension 继承关系\n![app](https://github.com/Alex0605/Alex0605.github.io/blob/master/img/gradle_lib.png)\n&emsp; &emsp;除了AppExtension之外还有2个类与之相似，LibraryExtension和TestExtension\n&emsp; &emsp;如果是module项目作为lib使用，那么lib下的build.gradle中的android对应的是LibraryExtension\n\n### 1.2 AppExtension的属性\n* aaptOptions：aapt是一个可以将资源文件编译成二进制文件的工具。aaptOptions表示  aapt工具设置的可选项参数。 \n* adbExecutable：adb从编译sdk时执行\n*  adbOptions：adb的可选项参数 \n*  applicationVariants：应用变体列表 \n*  buildToolsVersion：构建工具版本(必要的) \n*  buildTypes：构建类型(一般是release和debug，还可以自定义) \n*  compileOptions：编译可选项参数 \n*  compileSdkVersion：编译sdk版本(必要的) \n*  dataBinding：Data Binding可选项参数(关于DataBinding的使用) \n*  defualtConfig：默认配置，对于所有的打包项目 \n*  defualtPublishConfig：默认是release。\n*   dexOptions：Dex可选项参数。 \n*  externalNativeBuild：native编译支持。\n*  flavorDimensionList：\n*  generatePureSplits：是否拆成多个APK \n*  jacoco：JaCoCo可选项参数 \n*  lintOptions：Lint工具可选项参数\n*   ndkDirectory：ndk目录(一般在local.properties中) \n*  packagingOptions：packaging的可选参数 \n*  productFlavors：项目所有flavor \n*  publishNonDefualt：不仅仅使用默认的publish artifacts。可参defualtPublishConfig。              \n*  resourcePrefix：创建新资源时使用的前缀。 \n*  sdkDirectory：sdk目录(一般在local.properties中) \n*  signingConfigs：签名文件的可选项参数 \n*  sourceSets：资源文件目录指定(Android中有自己的AndroidSourceSets，这个一般用于assets，jin等目录) splits：splits类型。\n*   testBuildType：测试构建类型\n*   testOptions：测试可选项参数 \n*  testVariants：测试变体 \n*  unitTestVariants：单元测试变体 \n*  variantFilter：变体过滤器,加粗的表示DSL语言的闭包,如：\n```\nbuildTypes { }\n```\n\n\n### 1.3 AppExtension的闭包\n&emsp; &emsp;与app中build.gradle中android{}一样，代码中由AppExtension类表示。其他的配置闭包也一样。\n1、aaptOptions{}代码由AaptOptions类表示。\n\n```\nAaptOptions的属性：\nadditionalParameters:额外参数，List类型。\ncruncherEnabled：如果PNG图片是否可以大量快速的处理，boolean类型。 true表示可以。\ncruncherProcesses:快速处理，可能需要更多的内存和CPU。int类型。默认0，值越大处理越快，需要的内存和CPU也越大。\nfailOnMissingConfigEntry:如果没有找到一个配置，就返回一个错误。Boolean值，默认false。\nignoreAssetsPattern：忽略Assets模块。\nmoCompress：拓展文件不会打包进apk中。\n \n用法(详细用法可能需要去看看文档了)：\naaptOptions{\n    cruncherEnabled true//快速处理PNG图片\n}\n```\n\n2、adbOption{}\n```\nadbOptions{}对应的是AdbOptions\nAdbOptions的属性：\ninstallOptions：apk安装的可选参数。\ntimeOutInMs：使用adb的超时时间。\n```\n3、buildTypes{}\n```\nbuildTypes{}对应的是BuildType类\n \nbuildTypes的属性：\n \napplicationIdSuffix：应用id后缀(给Applica)\nconsumerProguardFiles：混淆文件包含在arr包中。\ndebuggable：是否生成一个debug的apk\nembedMicroApp：可穿戴设备app是否可以使用这个编译类型\njavaCompileOption：Java编译配置参数\njniDebuggable：这个编译类型的配置是否可以与debuggable的native代码生成一个apk\nmanifestPlaceholders：清单占位符\nminifyEnabled：是否缩小\nmultiDexEnabled：是否拆成多个Dex\nmultiDexKeepFile：指定文本文件编译进主Dex文件中\nmultiDexKeepProguard：指定混淆文件编译进主Dex文件中\nname：build type的名字\nproguardFiles：混淆文件\npseudoLocalesEnabled：是否生成伪现场apk(如果没有提供混淆规则文件，则设置默认的混淆规则文件（SDK/tools/proguard/proguard-android.txt）)\nrenderscriptDebuggable：使用RenderScript编译器的优化级别。\nshrinkResources：是否去除未利用的资源，默认false，表示不去除。\nsigningConfig：签名配置\ntestCoverageEnabled：测试覆盖率是否被激活。\nuseJack：过时\nversionNameSuffix：版本名称后缀\n zipAlignEnable：是否使用zipalign工具压缩。\n \n------------------------------------------------------\n \nbuildType的方法：\n \nbuildConfigField(type,name,value)：添加一个变量生成BuildConfig类。\nconsumeProguardFile(proguardFile)：添加一个混淆文件进arr包。\nconsumeProguardFile(proguardFiles)：添加混淆文件进arr包。\nexternalNativeBuild(action)：配置本地的build选项。\ninitWith：复制这个build类型的所有属性。\nproguardFile(proguardFile)：添加一个新的混淆配置文件。\nproguradFiles(files):添加新的混淆文件\nresValue(type,name,value)：添加一个新的生成资源\nsetProguardFiles(proguardFileIterable):设置一个混淆配置文件。\n------------------------------------------------------------\nbuildType用法：\n \n  buildTypes {\n        release {\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            shrinkResources true\n            zipAlignEnabled true\n            debuggable false\n            //...\n        }\n \n        debug{\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            shrinkResources true\n            zipAlignEnabled true\n            debuggable true\n            //...\n        }\n    }\n```\n\n\n4、compileOptions{}\n```\ncompileOptions{}对应的是CompileOptions\n\nCompileOptions的属性：\nencoding：Java源文件的编码格式\nincremental：是否应该使用Java编写的Gradle新的增量模型\nsourceCompatibility：指定编译编译.java文件的jdk版本\ntargetCompatibility：确保class文件与targetCompatibility指定版本，或者更新的java虚拟机兼容\n```\n5、dataBinding{}\n```\ndataBinding{}对应的是DataBindingOptions\n \n \nDataBindingOptions的属性：\n \naddDefualtAdapters：是否添加一个默认的data binding适配器。默认true。\nenabled：是否使用data binding\nversion：data binding使用版本\n \n \ndataBinding的使用：\n \ndataBinding{\n    enabled true\n}\n```\n\n\n6、defualtConfig{}\n```\ndefaultConfig{}是所有flavor都共有的配置。\n \n英文解释：The default configuration, inherited by all product flavors (if any are defined).\n \n \ndefaultConfig的使用：\n \n defaultConfig {\n        applicationId \"com.example.zhang.demo\"\n        minSdkVersion 15\n        targetSdkVersion 25\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n}\n```\n7、dexOptions{}\n```\ndexOptions{}对应的是DexOptions\n \nDexOptions属性:\n \nadditionalParameters：给dx添加一系列附加的参数\njavaMaxHeapSize：当调用dx时指定-Xmx值。\njumboMode：使用jumbo(庞大的)模式\nkeepRuntimeAnnotatedClasses：保持所有类中的运行时的注解在主Dex中。\nmaxProcessCount：可以使用Dex的最大并发进程数。默认为4。\noptimize：运行在dx编译器是否有optimize标记。\npreDexLibraries：是否预先dex库，它可以改善增量的生成，但是在clear build可能会变慢\nthreadCount：当dx运行时使用的线程的数量。默认4个。\n \n \ndexOptions{}的用法：\n \ndexOptions {\n    preDexLibraries  false\n    javaMaxHeapSize \"4g\"\n}\n```\n\n8、externalNativeBuild{}\n```\nexternalNativeBuild{}对应的是ExternalNativeBuild\n \nExternalNativeBuild的属性：\n \ncmake：CMake工具编译选项。\nndkBuild：ndk-build选项。\n \n \n在externalNativeBuild{}中有2个模块，cmake{}和ndkBuild{}模块\n \n------------------------------------------------\ncmake{}对应的是CmakeOptions\n \nCmakeOption的属性：\npath：你的CmakeLists.txt编译脚本的相对路径。\n \n--------------------------------------------------\nndkBuild{}对应的是NdkBuildOptions\n \nNdkBuildOptions的属性：\npath:你的Android.mk文件的相对路径。\n \n--------------------------------------------------\n \n \nexternalNativeBuild{}的用法：\n \nexternalNativeBuild{\n    ndkBuild{\n        path file(\"src\\\\main\\\\jni\\\\Android.mk\")\n    }\n \n    cmake {\n        path \"src/main/cpp/CMakeLists.txt\"\n    }\n}\n```\n\n9、jacoco{}\n```\njacoco{}对应于JacocoOptions\n \nJacocoOptions的属性：\n1.version：过时\n \n英文原文：\nnote: this property is deprecated and will be removed in a future version of the plugin.\n\n```\n10、lintOptions{}\n```\nlintOptions{}对应于LintOptions\n \n \nLintOptions的属性：\nabortOnError：如果发现错误，lint工具是否应该退出这个程序。true表示退出。\nabsolutePaths：是否在输出错误的时候，lint应该展示出全路径。默认是相对路径，也就是默认false。\ncheck：精确的检查(搜集)问题的集合，默认情况下，任何问题都可以通过LintOptions.getEnable()启用，没有问题可以通过LintOptions.getDisable()使之无效。\ncheckAllWarnings：是否检查所有警告，包括那些默认关闭。\ndisable：通过id's来压制这个问题，允许修改\nenable：通过id's来处理这个问题，循序修改，他会将添加id，并返回一个集合。\nexplainIssues：返回lint是否包含错误问题的解释(注意：HTML和XML报告会无条件的去做，忽略这个设置)。\nhtmlOutput：html输出方式。\nhtmlReport：我们应该是否写一个HTML报告，默认true， 这个使用场景由LintOptions.getHtmlOutput()控制。\nignoreWarings：lint仅仅检查错误，忽略警告。\nlintConfig：默认配置文件作为备份。\nnoLines：lint在输出错误日志的时候，是否包含行数。默认true。\nquiet：lint是否应该quiet(安静)。如：报告文件写入路径，不写消息。\nseverityOverrides：An optional map of severity overrides. The map maps from issue id's to the corresponding severity to use, which must be \"fatal\", \"error\", \"warning\", or \"ignore\".\nshowAll：lint是否包含所有的输出。\ntextOutput：文本输出方式。\ntextReport：是否是文本报告写入，默认false。\nwarningAsErrors：lint是否把警告当做错误来处理。\nxmlOutput：XML输出方式。\nxmlReport：XML格式写入报告，默认true。\n \n------------------------------------------------\n \nLintOptions的方法：\n \ncheck(id)：检查这个id的问题的集合\ncheck(ids)：\ndisable(id)：将id添加到不用启动的问题集\ndisable(ids)：\nenable(id)：将id添加到启动的问题集\nenable(ids)\nerror(id)：将id添加到错误的问题集\nerror(ids)\nfatal(id)：将id添加到fatal级别的问题集\nfatal(ids)\nignore(id)：将id添加到ignore级别的问题集\nignore(ids)\nwaring(id)：将id添加到waring级别的问题集\nwaring(ids)\n \n------------------------------------------------\n \nlintOptions{}的一般用法：\n \nlintOptions {\n    abortOnError false\n}\n```\n\n\n11、packagingOptions{}\n```\npackagingOptions{}对应的是PackagingOptions\nPackaging options有三组路径：first-picks，merges和excludes:\npackagingOptions{}的用法：\npackagingOptions {\n    pickFirsts = [] // Not really needed because the default is empty.\n    merges = []     // Not really needed because the default is empty.\n    excludes = []\n}\n```\n\n\n12、productFlavors{}\n```\nproductFlavors{}对应的是ProductFlavors\n \nProductFlavors的属性：\n \napplicationId：应用程序ID。\napplicationIdSuffix：应用程序ID后缀。\nconsumerProguardFiles：混淆规则文件被包含在aar包中。\ndimension：flavor名称的尺寸。\nexternalNativeBuild：详情见externalNativeBuild{}\nflavorDeminsion：过时\ngeneratedDensities：过时\njackOption：jack配置可选项。\njavaCompileOptions：Java编译配置参数\nmanifestPlaceholders：manifest占位符\nmultiDexEnabled：是否进行dex拆分\nmultiDexKeepFile：文本文件编译进主dex文件中。\nmultiDexKeepProgroud：文本文件作为混淆规则编译进主dex文件中\nndk：ndk配置\nproguardFiles:混淆文件\nsigningConfig：这个flavor的签名配置信息\ntestApplicationId：测试应用ID\ntestFunctionalTest：\ntestHandleProfiling：\ntestInstrumentationRunner：\ntestInstrumentionRunnerArguments：\nuseJack：过时\nverctorDrawables：生成矢量图支持\nversionCode：版本号\nversionName:版本名\nversionNameSuffix：版本名后缀\nwearAppUnbundled：是否对嵌入式穿戴app进行拆分模式。如果true，那么这个app将在应用市场被分发为穿戴设备的app。\n \nproductFlavor{}的用法：\nproductFlavors {\n \n        googlePlay {\n        }\n \n        xiaomi {\n        }\n}\n//所有打包配置（批量处理打包渠道--> manifestPlaceholders：设置打包渠道）\nproductFlavors.all {\n    //平台id\n    flavor -> flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]\n}\n```\n\n13、signingConfig{}\n\n```\nsigningConfig{}对应的是SigningConfig\n \nSigningConfig的属性：\n \nkeyAlias：签名使用key的别名\nKeyPassword：签名使用的key的密码\nstoreFile：store签名文件\nstorePassword：store签名密码\nstoreType：store签名类型\nSigningEnabled：是否使用jar签名(又名v1签名)。\nv2SigningEnabled：是否使用apk签名(又名v2签名)。\n \n \nsigningConfig{}的用法：\n \nsigningConfigs {\n    config {\n        keyAlias '...'\n        keyPassword '...'\n        storeFile file('C:/../Key.jks')\n        storePassword '...'\n    }\n}\n```\n14、sourceSets{}\n```\nsourceSets{}对应的AndroidSourceSet\n \nAndroidSourceSet的属性：\n \naidl：aidl目录\nassets：assets目录\ncompileConfiguraName：编译配置资源目录。\njava：java代码目录（需要编译成.class文件）\njni：jni资源目录\njniLibs：jni库目录\nmanifest：AndroidManifest.xml资源文件\nname：source set名称。\npackageConfigurationName：运行时配置的资源集。\nprovidedConfigurationName：仅仅编译时配置的资源集。\nrenderscript：RenderScript脚本资源目录\nres：Android资源目录\nresource：java资源被复制到输出到javaresource目录\n \nAndroidSourceSet的方法：\n1.setRoot(path)：资源集的根目录，所有的资源都在这个跟目录下。\n \nsourceSets{}的使用：\nsourceSets {\n    //在main目录中\n    main {\n        //assets目录设置\n        assets.srcDirs = ['assets']\n        //jni目录设置\n        jni.srcDirs 'src/main/jni'\n        //jni库设置\n        jniLibs.srcDir 'src/main/jniLibs'\n    }\n}\n```\n15、splits{}\n```\nsplits{}对应的是Splites\n \nSplits的属性：\n \nabi：ABI设置\nabiFilters：用于多个apk的ABI筛选列表\ndensity：密度设置\ndensityFilters：用于多个apk的密度筛选列表\nlanguage：语言设置。\nlanguageFilters：用于多个apk的语言筛选列表\n \n-----------------------------------------------------\n \n \nSpiltes对应有三个模块，abi{},density{},language{}\n \n \nabi{}对应的是AbiSplitOptions\n \nAbiSplitsOptions的属性：\napplicableFilters：返回此范围的所有适用筛选器的列表。\nenable：是否在这个范围分裂\nuniversalApk：是否创建所有可用的ABIs一个APK。\n \n \nAbiSplitesOptions的方法：\nexclude(excludes)：排除一些值。\ninclude(include)：包含一些值。\nreset()：重新设置split配置。\n \n----------------------------------------------------------\n \ndensity{}对应的是DensitySplitOptions\n \nDensitySplitOptions的属性：\napplicableFilters：返回此范围的所有适用筛选器的列表。\nauto：编译系统是否确定分割“language-*”文件夹中的资源。\ncompatibleScreen：兼容屏幕列表\nenable：是否拆分\n \n \nDensitySplitOptions的方法：\n1.exclude(exclude):排除一些值\n2.include(include):包含一些值\n3.reset()：重新设置split配置。\n \n \n-------------------------------------------------------\n \nlanguage{}对应的是LanguageSplitOptions\n \nLanguageSplitOptions的属性：\n1.enable：如果true，就是拆分language\n \n \nLanguageSplitOptions的方法：\n1.include(include)：包含一个模型。\n \n \n---------------------------------------------------------\n \nsplits{}的用法：\n \nsplits {\n    density {\n        enable true\n        exclude 'ldpi', 'mdpi'\n        compatibleScreens 'normal', 'large', 'xlarge'\n    }\n} \n \n生成结果：\napp-hdpi-release.apk\napp-universal-release.apk\napp-xhdpi-release.apk\napp-xxhdpi-release.apk\napp-xxxhdpi-release.apk\n \nsplits {\n    abi {\n      enable true\n      reset()\n      include 'x86', 'armeabi-v7a', 'mips'\n      universalApk true\n    }\n}\n这个就是生成不同手机架构的app\n```\n\n\n16、testOptions{}\n```\ntestOptions{}对应的是TestOptions\n \nTestOptions的属性：\n1.reportDir：报告目录\n2.resultDir：结果目录\n3.unitTests：单元测试配置参数\n \nTestOptions包含unitTests{}\n \n-------------------------------------------------------\n \nunitTests{}对应的是UnitTestOptions\n \nUnitTestOptions的属性：\n1.returnDefaultValues：无论unmocked方法从android.jar中抛出异常或是默认值（0或null）。\n \n \nUnitTestOtions的方法：\nall(configClosure)：配置所有单元测试任务。\n \n-------------------------------------------------\n \ntestOptions{}的使用：\n \ntestOptions {\n    resultsDir = \"$project.buildDir/foo/results\"\n}\n```\n### 1.4 AppExtension的方法\n- flavorDimensions(dimension):指定flavor名称\n- useLibraray(name)：请求使用一个lib库\n- useLibrary(name,required)：与上面解释一样。\n\n### 1.5 参考文档\n[1、BuildType官方文档](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.BuildType.html)\n\n[2、DataBinding详细用法](https://blog.csdn.net/qq_33689414/article/details/52205703)\n\n[3、Android Studio2.2 配置NDK](https://blog.csdn.net/jdh99/article/details/51765441)\n\n[4、Android studio 2.2 使用cmake编译NDK](https://blog.csdn.net/lmw21848/article/details/52183584)\n\n[5、Android Studio官方文档之使用Lint](https://blog.csdn.net/yishon_android/article/details/51864699)\n\n[6、PackagingOptions官方文档](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.PackagingOptions.html)\n\n[7、ProductFlavor官方文档](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.ProductFlavor.html)\n\n[8、APK-splite官方文档](http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits)\n\n[9、Splite官方文档](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.Splits.html)\n\n[10、AaptOptions官方](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.AaptOptions.html)","tags":["Android","Gradle"]},{"title":"JDK源码阅读系列(五)--StringBuilder类","url":"/2017/10/22/JDK源码阅读系列-五-StringBuilder类/","content":"\n1、概况\n\n​\t在 Java 中处理字符串时经常会使用 String 类，实际上 String 对象的值是一个常量，一旦创建后不能被改变。正是因为其不可变，所以也无法进行修改操作，只有不断地 new 出新的 String 对象。为此 Java 引入了可变字符串变量 StringBuilder 类，它不是线程安全的，只用在单线程场景下。类关系如下：\n\n![class_sb_1](D:/Study/Blog/Hexo/source/_posts/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%E4%BA%94-StringBuilder%E7%B1%BB/class_sb_1.png)\n\n2、继承关系及类定义\n\n```java\n--java.lang.Object\n  --java.lang.AbstractStringBuilder\n    --java.lang.StringBuilder\n```\n\n```java\npublic final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence\n```\n\n​\tStringBuilder 类被声明为 final，说明它不能再被继承。同时它继承了 AbstractStringBuilder 类，并实现了 Serializable 和 CharSequence 两个接口。\n\n其中 Serializable 接口表明其可以序列化。\n\nCharSequence 接口用来实现获取字符序列的相关信息，接口定义如下： \n\n- length()获取字符序列长度。 \n- charAt(int index)获取某个索引对应字符。 \n- subSequence(int start, int end)获取指定范围子字符串。 \n- toString()转成字符串对象。 \n- chars()用于获取字符序列的字符的 int 类型值的流，该接口提供了默认的实现。 \n- codePoints()用于获取字符序列的代码点的 int 类型的值的流，提供了默认的实现。\n\n```java\npublic interface CharSequence {\n\n    int length();\n\n    char charAt(int index);\n\n    CharSequence subSequence(int start, int end);\n\n    public String toString();\n\n    public default IntStream chars() {\n        省略代码。。\n    }\n\n    public default IntStream codePoints() {\n        省略代码。。\n    }\n}\n```\n\n","tags":["Java","源码阅读"]},{"title":"JDK源码阅读系列(四)--StringBuffer类","url":"/2017/10/21/JDK源码阅读系列-四-StringBuffer类/","content":"\n1、概况\n\n​\t在 Java 中处理字符串时经常会使用 String 类，实际上 String 对象的值是一个常量，一旦创建后不能被改变。正是因为其不可变，所以也无法进行修改操作，只有不断地 new 出新的 String 对象。为此 Java 引入了可变字符串变量 StringBuilder 类，它不是线程安全的，只用在单线程场景下。类关系如下：\n\n![class_sb_1](JDK源码阅读系列-五-StringBuilder类/class_sb_1.png)\n\n2、继承关系及类定义\n\n```java\n--java.lang.Object\n  --java.lang.AbstractStringBuilder\n    --java.lang.StringBuilder\n```\n\n```java\npublic final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence\n```\n\n​\tStringBuilder 类被声明为 final，说明它不能再被继承。同时它继承了 AbstractStringBuilder 类，并实现了 Serializable 和 CharSequence 两个接口。\n\n其中 Serializable 接口表明其可以序列化。\n\nCharSequence 接口用来实现获取字符序列的相关信息，接口定义如下： \n* length()获取字符序列长度。 \n* charAt(int index)获取某个索引对应字符。 \n* subSequence(int start, int end)获取指定范围子字符串。 \n* toString()转成字符串对象。 \n* chars()用于获取字符序列的字符的 int 类型值的流，该接口提供了默认的实现。 \n* codePoints()用于获取字符序列的代码点的 int 类型的值的流，提供了默认的实现。\n\n```java\npublic interface CharSequence {\n\n    int length();\n\n    char charAt(int index);\n\n    CharSequence subSequence(int start, int end);\n\n    public String toString();\n\n    public default IntStream chars() {\n        省略代码。。\n    }\n\n    public default IntStream codePoints() {\n        省略代码。。\n    }\n}\n```\n\n","tags":["Java","源码阅读"]},{"title":"JDK源码阅读系列(三)--AbstractStringBuilder类","url":"/2017/10/20/JDK源码阅读系列-三-AbstractStringBuilder类/","content":"\n​\t因为看StringBuffer 和 StringBuilder 的源码时发现两者都继承了AbstractStringBuilder，并且很多方法都是直接super的父类AbstractStringBuilder的方法，所以还是决定先看AbstractStringBuilder的源码，然后再看StringBuffer 和 StringBuilder.\n\n#### 1.成员变量\n\n \tAbstractStringBuilder和String一样，在其内部都是以字符数组的形式实现的。也就是String,StringBuffer以及StringBuilder在其内部都是以字符数组的形式实现的。\n\n```java\nchar value[];\nint count;\n```\n\n#### 2.构造函数\n\n​\tAbstractStringBuilder的构造函数中传入的capacity是指容量，实际长度是以leng中的count表示的，注意区分容量和实际长度\n\n```java\nAbstractStringBuilder() {\n }\n \n AbstractStringBuilder(int capacity) {\n     value = new char[capacity];\n }\n```\n\n#### 3.容量和长度\n\n```java\npublic int length() {\n\treturn count;\n}\npublic int capacity() {\n\treturn value.length;\n}\n```\n\n#### 4.AbstractStringBuilder的扩容\n\n```java\npublic void ensureCapacity(int minimumCapacity) {\n\tif (minimumCapacity > value.length) {//如果传入的容量大于原来的容量就扩容\n\t    expandCapacity(minimumCapacity);\n\t}\n    }\n \n void expandCapacity(int minimumCapacity) {\n\tint newCapacity = (value.length + 1) * 2;//首先默认扩容为  （原容量+1）*2\n        if (newCapacity < 0) {\n            newCapacity = Integer.MAX_VALUE;\n        } else if (minimumCapacity > newCapacity) {//如果传入的容量大于 默认扩容量，则传入容量为新容量\n\t    newCapacity = minimumCapacity;\n\t}\n        value = Arrays.copyOf(value, newCapacity);\n    }\n\n```\n\n#### 5.字符串减少存储空间\n\n如果实际长度小于容量，为了减少存储空间，就把容量缩小为刚好满足字符串长度。\n\n```java\npublic void trimToSize() {\n        if (count < value.length) {\n            value = Arrays.copyOf(value, count);\n        }\n    }\n```\n\n#### 6.setLength(int newLength)\n\n```java\npublic void setLength(int newLength) {\n\tif (newLength < 0)\n\t    throw new StringIndexOutOfBoundsException(newLength);\n\tif (newLength > value.length)//设置长度大于容量时先扩容\n\t    expandCapacity(newLength);\nif (count < newLength) {//设置长度大于原来长度时，后面部分补以空白\n    for (; count < newLength; count++)\n\tvalue[count] = '\\0';\n} else {\n        count = newLength;\n    }\n}\n```\n#### 7.char charAt(int index)\n\n```java\npublic char charAt(int index) {\n\tif ((index < 0) || (index >= count))\n\t    throw new StringIndexOutOfBoundsException(index);\n\treturn value[index];\n    }\n```\n\n#### 8.void getChars(int srcBegin, int srcEnd, char dst[],  int dstBegin)\n\ngetChars() 方法将字符从字符串复制到目标字符数组。\n\n参数\n\n- srcBegin -- 字符串中要复制的第一个字符的索引。\n- srcEnd -- 字符串中要复制的最后一个字符之后的索引。\n- dst -- 目标数组。\n- dstBegin -- 目标数组中的起始偏移量。\n\n返回值\n\n没有返回值，但会抛出 IndexOutOfBoundsException 异常。\n\n一定要注意参数情况的考虑，自己编程时一定要养成好习惯。主要是调用了System.arraycopy()的方法，以后具体分析。\n\n源码：\n\n```java\n public void getChars(int srcBegin, int srcEnd, char dst[],\n                                      int dstBegin)\n    {\n\tif (srcBegin < 0)\n\t    throw new StringIndexOutOfBoundsException(srcBegin);\n\tif ((srcEnd < 0) || (srcEnd > count))\n\t    throw new StringIndexOutOfBoundsException(srcEnd);\n        if (srcBegin > srcEnd)\n            throw new StringIndexOutOfBoundsException(\"srcBegin > srcEnd\");\n\tSystem.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);\n    }\n```\n\n实例：\n\n```java\npublic class Test {\n    public static void main(String args[]) {\n        String Str1 = new String(\"www.baidu.com\");\n        char[] Str2 = new char[5];\n\n        try {\n            Str1.getChars(4, 9, Str2, 0);\n            System.out.print(\"拷贝的字符串为：\" );\n            System.out.println(Str2 );\n        } catch( Exception ex) {\n            System.out.println(\"触发异常...\");\n        }\n    }\n}\n```\n\n以上程序执行结果为：\n\n拷贝的字符串为：runoob\n\n#### 9.void setCharAt(int index, char ch)\n\n方法的源码很简单，是直接替换该index的值，而不是后移之类的，因为是数组，不可变长度。\n\n```java\n public void setCharAt(int index, char ch) {\n\tif ((index < 0) || (index >= count))\n\t    throw new StringIndexOutOfBoundsException(index);\n\tvalue[index] = ch;\n    }\n```\n\n#### 10.append(String str)\n\n对于StringBuffer和StringBuilder重要的append()方法的源码闪亮登场咯~~\n\n```java\npublic AbstractStringBuilder append(String str) {\n\tif (str == null) str = \"null\";//若传入为null,则会在后面加上“null”\n        int len = str.length();\n\tif (len == 0) return this;//传入长度为0，则返回本身\n\tint newCount = count + len;\n\tif (newCount > value.length)//传入后的长度大于容量就扩容\n\t    expandCapacity(newCount);\n\tstr.getChars(0, len, value, count);//用的是getChars()为value传值\n\tcount = newCount;\n\treturn this;\n    }\n```\n\n#### 11.append(CharSequence s, int start, int end)\n\n```java\n public AbstractStringBuilder append(CharSequence s, int start, int end) {\n        if (s == null)\n            s = \"null\";\n\tif ((start < 0) || (end < 0) || (start > end) || (end > s.length()))//一定要注意情况考虑\n\t    throw new IndexOutOfBoundsException(\n                \"start \" + start + \", end \" + end + \", s.length() \" \n                + s.length());\n\tint len = end - start;\n\tif (len == 0)\n            return this;\n\tint newCount = count + len;\n\tif (newCount > value.length)\n\t    expandCapacity(newCount);\n        for (int i=start; i<end; i++)//用的是charAt()为value循环赋值\n            value[count++] = s.charAt(i);//!!\n        count = newCount;\n\treturn this;\n    }\n```\n\n#### 12.append(char str[])\n\n若是字符数组，用的是System.arraycopy（）方法。\n\n#### 12.append(char str[])\n\n若是字符数组，用的是System.arraycopy（）方法。\n\n```java\n public AbstractStringBuilder append(char str[]) { \n\tint newCount = count + str.length;\n\tif (newCount > value.length)\n\t    expandCapacity(newCount);\n        System.arraycopy(str, 0, value, count, str.length);\n        count = newCount;\n        return this;\n    }\n```\n\n#### 13.append(boolean b)\n\n这个源码很简单\n\n```java\n public AbstractStringBuilder append(boolean b) {\n        if (b) {\n            int newCount = count + 4;\n            if (newCount > value.length)\n                expandCapacity(newCount);\n            value[count++] = 't';\n            value[count++] = 'r';\n            value[count++] = 'u';\n            value[count++] = 'e';\n        } else {\n            int newCount = count + 5;\n            if (newCount > value.length)\n                expandCapacity(newCount);\n            value[count++] = 'f';\n            value[count++] = 'a';\n            value[count++] = 'l';\n            value[count++] = 's';\n            value[count++] = 'e';\n        }\n\treturn this;\n    }\n```\n\n#### 14.append(int i)\n\n```java\npublic AbstractStringBuilder append(int i) {\n        if (i == Integer.MIN_VALUE) {\n            append(\"-2147483648\");\n            return this;\n        }\n        int appendedLength = (i < 0) ? stringSizeOfInt(-i) + 1 : stringSizeOfInt(i);//!!!\n        int spaceNeeded = count + appendedLength;\n        if (spaceNeeded > value.length)\n            expandCapacity(spaceNeeded);\n\tInteger.getChars(i, spaceNeeded, value);\n        count = spaceNeeded;\n        return this;\n    }\n    final static int [] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                     99999999, 999999999, Integer.MAX_VALUE };\n// Requires positive x\nstatic int stringSizeOfInt(int x) {\n    for (int i=0; ; i++)\n        if (x <= sizeTable[i])\n            return i+1;\n}\n```\n####  15.delete(int start, int end)\n\n主要还是用的System.arraycopy()\n\n```\npublic AbstractStringBuilder delete(int start, int end) {\n\tif (start < 0)\n\t    throw new StringIndexOutOfBoundsException(start);\n\tif (end > count)\n\t    end = count;\n\tif (start > end)\n\t    throw new StringIndexOutOfBoundsException();\n        int len = end - start;\n        if (len > 0) {\n            System.arraycopy(value, start+len, value, start, count-end);\n            count -= len;\n        }\n        return this;\n    }\n```\n\n#### 16.reverse()\n\n这个是StringBuffer和StringBuilder常用到的方法，而String并没有这个牛逼的功能~~\n\n```java\npublic AbstractStringBuilder reverse() {\n\tboolean hasSurrogate = false;\n\tint n = count - 1;\n\tfor (int j = (n-1) >> 1; j >= 0; --j) {\n\t    char temp = value[j];\n\t    char temp2 = value[n - j];\n\t    if (!hasSurrogate) {\n\t\thasSurrogate = (temp >= Character.MIN_SURROGATE && temp <= Character.MAX_SURROGATE)\n\t\t    || (temp2 >= Character.MIN_SURROGATE && temp2 <= Character.MAX_SURROGATE);\n\t    }\n\t    value[j] = temp2;\n\t    value[n - j] = temp;\n\t}\n\tif (hasSurrogate) {\n\t    // Reverse back all valid surrogate pairs\n\t    for (int i = 0; i < count - 1; i++) {\n\t\tchar c2 = value[i];\n\t\tif (Character.isLowSurrogate(c2)) {\n\t\t    char c1 = value[i + 1];\n\t\t    if (Character.isHighSurrogate(c1)) {\n\t\t\tvalue[i++] = c1;\n\t\t\tvalue[i] = c2;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\treturn this;\n    }\n```\n\n#### 17.String toString()\n\n这个只是一个抽象的方法，没有方法体。\n\n```java\npublic abstract String toString();\n```\n","tags":["Java","源码阅读"]},{"title":"JDK源码阅读系列(二)--String类","url":"/2017/10/19/JDK源码阅读系列-二-String类/","content":"\n#### 1、String的定义\n\n```java\npublic final class String implements java.io.Serializable, Comparable<String>, CharSequence \n```\n\n重要点：\n\n- String是一个final类，既不能被继承的类\n- String类实现了java.io.Serializable接口，可以实现序列化\n- String类实现了Comparable<String>，可以用于比较大小（按顺序比较单个字符的ASCII码）\n- String类实现了 CharSequence 接口，表示是一个有序字符的序列，因为String的本质是一个char类型数组\n\n#### 2、字段属性\n\n```java\n //用来存字符串,字符串的本质，是一个final的char型数组\n private final char value[];                                         \n\n //缓存字符串的哈希\n private int hash;  // Default to 0                                \n\n //实现序列化的标识\n private static final long serialVersionUID = -6849794470754667710L; \n```\n\n重要点：\n\n- private final char value[]`这是String字符串的本质，是一个字符集合，而且是`final的，是不可变的。\n\n#### 3、构造函数\n\n\n```java\n/** 01\n* 这是一个经常会使用的String的无参构造函数.\n* 默认将\"\"空字符串的value赋值给实例对象的value，也是空字符\n* 相当于深拷贝了空字符串\"\"\n*/\npublic String() {\n  this.value = \"\".value;\n}\n\n/** 02\n* 这是一个有参构造函数，参数为一个String对象\n* 将形参的value和hash赋值给实例对象作为初始化\n* 相当于深拷贝了一个形参String对象\n*/\npublic String(String original) {\n    this.value = original.value;\n    this.hash = original.hash;\n}\n\n/** 03\n* 这是一个有参构造函数，参数为一个char字符数组\n* 虽然我不知道为什么要Arrays.copyOf去拷贝，而不直接this.value = value;\n* 意义就是通过字符数组去构建一个新的String对象\n*/\npublic String(char value[]) {\n    this.value = Arrays.copyOf(value, value.length);\n}\n\n/** 04\n* 这是一个有参构造函数，参数为char字符数组,offset(起始位置，偏移量),count(个数)\n* 作用就是在char数组的基础上，从offset位置开始计数count个，构成一个新的String的字符串\n* 意义就类似于截取count个长度的字符集合构成一个新的String对象\n*/\npublic String(char value[], int offset, int count) {\n    if (offset < 0) {        //如果起始位置小于0，抛异常\n        throw new StringIndexOutOfBoundsException(offset);\n    }\n    if (count <= 0) {\n        if (count < 0) {     //如果个数小于0，抛异常\n            throw new StringIndexOutOfBoundsException(count);\n        }\n        if (offset <= value.length) {      //在count = 0的前提下，如果offset<=len，则返回\"\"\n            this.value = \"\".value;\n            return;\n        }\n    }\n    // Note: offset or count might be near -1>>>1.\n    //如果起始位置>字符数组长度 - 个数,则无法截取到count个字符，抛异常\n    if (offset > value.length - count) { \n        throw new StringIndexOutOfBoundsException(offset + count);\n    }\n    //重点，从offset开始，截取到offset+count位置(不包括offset+count位置)\n    this.value = Arrays.copyOfRange(value, offset, offset+count); \n}\n\n/** 05\n* 这是一个有参构造函数，参数为int字符数组,offset(起始位置，偏移量),count(个数)\n* 作用跟04构造函数差不多，但是传入的不是char字符数组，而是int数组。\n* 而int数组的元素则是字符对应的ASCII整数值\n* 例子：new String(new int[]{97,98,99},0,3);   output: abc\n*/\npublic String(int[] codePoints, int offset, int count) {\n    if (offset < 0) {\n        throw new StringIndexOutOfBoundsException(offset);\n    }\n    if (count <= 0) {\n        if (count < 0) {\n            throw new StringIndexOutOfBoundsException(count);\n        }\n        if (offset <= codePoints.length) {\n            this.value = \"\".value;\n            return;\n        }\n    }\n    // Note: offset or count might be near -1>>>1.\n    if (offset > codePoints.length - count) {\n        throw new StringIndexOutOfBoundsException(offset + count);\n    }  \n\t//以上都是为了处理offset和count的正确性，如果有错，则抛异常\n\t\n    final int end = offset + count;\n\n    // Pass 1: Compute precise size of char[]\n    int n = count;\n    for (int i = offset; i < end; i++) {\n        int c = codePoints[i];\n        if (Character.isBmpCodePoint(c))\n            continue;\n        else if (Character.isValidCodePoint(c))\n            n++;\n        else throw new IllegalArgumentException(Integer.toString(c));\n    }\n\t\n\t//上面关于BMP什么的，我暂时也没看懂，猜想关于验证int数据的正确性，通过上面的测试就进入下面的算法\n\t\n    // Pass 2: Allocate and fill in char[]\n    final char[] v = new char[n];\n\n    for (int i = offset, j = 0; i < end; i++, j++) {  //从offset开始，到offset + count\n        int c = codePoints[i];\n        if (Character.isBmpCodePoint(c))\n            v[j] = (char)c;   //将Int类型显式缩窄转换为char类型\n        else\n            Character.toSurrogates(c, v, j++);\n    }\n\n    this.value = v; //最后将得到的v赋值给String对象的value，完成初始化\n}\n/****这里把被标记为过时的构造函数去掉了***/\n\n/** 06\n* 这是一个有参构造函数，参数为byte数组,offset(起始位置，偏移量),长度，和字符编码格式\n* 就是传入一个byte数组，从offset开始截取length个长度，其字符编码格式为charsetName，如UTF-8\n* 例子：new String(bytes, 2, 3, \"UTF-8\");\n*/\npublic String(byte bytes[], int offset, int length, String charsetName)\n        throws UnsupportedEncodingException {\n    if (charsetName == null)\n        throw new NullPointerException(\"charsetName\");\n    checkBounds(bytes, offset, length);\n    this.value = StringCoding.decode(charsetName, bytes, offset, length);\n}\n\n/** 07\n* 类似06\n*/\npublic String(byte bytes[], int offset, int length, Charset charset) {\n    if (charset == null)\n        throw new NullPointerException(\"charset\");\n    checkBounds(bytes, offset, length);\n    this.value =  StringCoding.decode(charset, bytes, offset, length);\n}\n\n/** 08\n* 这是一个有参构造函数，参数为byte数组和字符集编码\n* 用charsetName的方式构建byte数组成一个String对象\n*/\npublic String(byte bytes[], String charsetName)\n        throws UnsupportedEncodingException {\n    this(bytes, 0, bytes.length, charsetName);\n}\n\n/** 09\n* 类似08\n*/\npublic String(byte bytes[], Charset charset) {\n    this(bytes, 0, bytes.length, charset);\n}\n\n/** 10\n* 这是一个有参构造函数，参数为byte数组,offset(起始位置，偏移量),length(个数)\n* 通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。\n* \n*/\npublic String(byte bytes[], int offset, int length) {\n    checkBounds(bytes, offset, length);\n    this.value = StringCoding.decode(bytes, offset, length);\n}\n\n/** 11\n* 这是一个有参构造函数，参数为byte数组\n* 通过使用平台默认字符集编码解码传入的byte数组，构造成一个String对象，不需要截取\n* \n*/\npublic String(byte bytes[]) {\n    this(bytes, 0, bytes.length);\n}\n\n/** 12\n* 有参构造函数，参数为StringBuffer类型\n* 就是将StringBuffer构建成一个新的String,比较特别的就是这个方法有synchronized锁\n* 同一时间只允许一个线程对这个buffer构建成String对象\n*/\npublic String(StringBuffer buffer) {\n    synchronized(buffer) {\n        this.value = Arrays.copyOf(buffer.getValue(), buffer.length()); //使用拷贝的方式\n    }\n}\n\n/** 13\n* 有参构造函数，参数为StringBuilder\n* 同12差不多，只不过是StringBuilder的版本，差别就是没有实现线程安全\n*/\npublic String(StringBuilder builder) {\n    this.value = Arrays.copyOf(builder.getValue(), builder.length());\n}\n\n/** 14\n* 这个构造函数比较特殊，有用的参数只有char数组value,是一个不对外公开的构造函数，没有访问修饰符\n* 加入这个share的只是为了区分于String(char[] value)方法，用于重载，功能类似于03，我也在03表示过疑惑。\n* 为什么提供这个方法呢，因为性能好，不需要拷贝。为什么不对外提供呢？因为对外提供会打破value为不变数组的限制。\n* 如果对外提供这个方法让String与外部的value产生关联，如果修改外不的value，会影响String的value。所以不能\n* 对外提供\n*/\nString(char[] value, boolean share) {\n    // assert share : \"unshared not supported\";\n    this.value = value;\n}\n```\n以上代码展示了总共14种构造方法，忽略了两种被标记为过时的构造方法：\n\n- 可以构造空字符串对象,既\"\"\n- 可以根据String,StringBuilder,StringBuffer构造字符串对象\n- 可以根据char数组，其子数组构造字符串对象\n- 可以根据int数组，其子数组构造字符串对象\n- 可以根据某个字符集编码对byte数组，其子数组解码并构造字符串对象\n\n#### 4、长度和是否为空函数\n\n```java\n    public int length() {       //所以String的长度就是一个value的长度\n        return value.length;\n    }\n    public boolean isEmpty() {  //当char数组的长度为0，则代表String为\"\",空字符串\n        return value.length == 0;\n    }\n```\n\n#### 5、charAt、codePointAt类型函数\n\n```java\n\n  /**\n   * 返回String对象的char数组index位置的元素\n   */\n   public char charAt(int index) {\n       if ((index < 0) || (index >= value.length)) {   //index不允许小于0，不允许大于等于String的长度\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        return value[index]; //返回\n    }\n   /**\n    * 返回String对象的char数组index位置的元素的ASSIC码(int类型)\n    */\n    public int codePointAt(int index) {\n        if ((index < 0) || (index >= value.length)) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        return Character.codePointAtImpl(value, index, value.length);\n    }\n\n   /**\n    * 返回index位置元素的前一个元素的ASSIC码(int型)\n    */\n    public int codePointBefore(int index) {\n        int i = index - 1;  //获得index前一个元素的索引位置\n        if ((i < 0) || (i >= value.length)) { //所以，index不能等于0，因为i = 0 - 1 = -1\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        return Character.codePointBeforeImpl(value, index, 0);\n    }\n   /**\n\t* 方法返回的是代码点个数，是实际上的字符个数,功能类似于length()\n\t* 对于正常的String来说，length方法和codePointCount没有区别，都是返回字符个数。\n\t* 但当String是Unicode类型时则有区别了。\n\t* 例如：String str = “/uD835/uDD6B” (即使 'Z' ), length() = 2 ,codePointCount() = 1 \n\t*/\n    public int codePointCount(int beginIndex, int endIndex) {\n        if (beginIndex < 0 || endIndex > value.length || beginIndex > endIndex) {\n            throw new IndexOutOfBoundsException();\n        }\n        return Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex);\n    }\n   /**\n\t* 也是相对Unicode字符集而言的，从index索引位置算起，偏移codePointOffset个位置，返回偏移后的位置是多少\n\t* 例如，index = 2 ,codePointOffset = 3 ，maybe返回 5 \n\t*/\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        if (index < 0 || index > value.length) {\n            throw new IndexOutOfBoundsException();\n        }\n        return Character.offsetByCodePointsImpl(value, 0, value.length,\n                index, codePointOffset);\n    }\n```\n\n从上我们可以发现：\n\n- 只有一个charAt()是针对字符而言的，就是寻找第index位置的字符是什么，在面试的算法中也很常会用到\n  剩下都是有关ASCII、Unicode，等我之后深入学习之后再来修改更新这部分内容\n- ChatAt是实现CharSequence 而重写的方法，是一个有序字符集的方法\n\n#### 6、getChar、getBytes类型函数\n\n```java\n   /**\n\t* 这是一个不对外的方法，是给String内部调用的，因为它是没有访问修饰符的，只允许同一包下的类访问\n\t* 参数：dst[]是目标数组，dstBegin是目标数组的偏移量，既要复制过去的起始位置(从目标数组的什么位置覆盖)\n\t* 作用就是将String的字符数组value整个复制到dst字符数组中，在dst数组的dstBegin位置开始拷贝\n\t* \n\t*/\n\tvoid getChars(char dst[], int dstBegin) {\n        System.arraycopy(value, 0, dst, dstBegin, value.length);\n    }\n\n   /**\n\t* 得到char字符数组，原理是getChars() 方法将一个字符串的字符复制到目标字符数组中。 \n\t* 参数:srcBegin是原始字符串的起始位置,srcEnd是原始字符串要复制的字符末尾的后一个位置(既复制区域不包括srcEnd)\n\t* dst[]是目标字符数组,dstBegin是目标字符的复制偏移量,复制的字符从目标字符数组的dstBegin位置开始覆盖。\n\t*/\n    public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) {\n        if (srcBegin < 0) {           //如果srcBegin小于，抛异常\n            throw new StringIndexOutOfBoundsException(srcBegin);\n        }\n    *    if (srcEnd > value.length) {  //如果srcEnd大于字符串的长度，抛异常\n            throw new StringIndexOutOfBoundsException(srcEnd);\n        }\n        if (srcBegin > srcEnd) {      //如果原始字符串其实位置大于末尾位置，抛异常\n            throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);\n        }\n        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);\n    }\n\n\n   /****去除被标记过时的方法****/\n\n   /**\n    * 获得charsetName编码格式的bytes数组\n    */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        if (charsetName == null) throw new NullPointerException();\n        return StringCoding.encode(charsetName, value, 0, value.length);\n    }\n\n   /**\n    * 与上个方法类似，但charsetName和charset的区别，我还没搞定，搞懂来再更新\n\t*/\n    public byte[] getBytes(Charset charset) {\n        if (charset == null) throw new NullPointerException();\n        return StringCoding.encode(charset, value, 0, value.length);\n    }\n\n\t/**\n    * 使用平台默认的编码格式获得bytes数组\n\t*/\n    public byte[] getBytes() {\n        return StringCoding.encode(value, 0, value.length);\n    }\n\n\n```\n\n从上面，我们可以看出：\n\n- getChars是没有返回值的，原理是通过System.arraycopy方法来实现的，不需要返回值。所以被覆盖的字符数组是需要具体存在的\n- getBytes是有返回值的\n\n#### 7、equal类函数(是否相等)\n\n```java\n/**\n* String的equals方法，重写了Object的equals方法（区分大小写）\n* 比较的是两个字符串的值是否相等\n* 参数是一个Object对象，而不是一个String对象。这是因为重写的是Object的equals方法，所以是Object\n* 如果是String自己独有的方法，则可以传入String对象，不用多此一举\n* \n* 实例：str1.equals(str2)\n*/\npublic boolean equals(Object anObject) {\n        if (this == anObject) {   //首先判断形参str2是否跟当前对象str1是同一个对象，既比较地址是否相等\n            return true;          //如果地址相等，那么自然值也相等，毕竟是同一个字符串对象\n        }\n        if (anObject instanceof String) { //判断str2对象是否是一个String类型，过滤掉非String类型的比较\n            String anotherString = (String)anObject; //如果是String类型，转换为String类型\n            int n = value.length;                    //获得当前对象str1的长度\n            if (n == anotherString.value.length) {   //比较str1的长度和str2的长度是否相等\n                                                     //如是进入核心算法\n                char v1[] = value;                   //v1为当前对象str1的值，v2为参数对象str2的值\n                char v2[] = anotherString.value;\n                int i = 0;                           //就类似于for的int i =0的作用，因为这里使用while\n                while (n-- != 0) {                   //每次循环长度-1,直到长度消耗完，循环结束 \n                    if (v1[i] != v2[i])              //同索引位置的字符元素逐一比较\n                        return false;                //只要有一个不相等，则返回false\n                    i++;\n                }\n                return true;                         //如比较期间没有问题，则说明相等，返回true\n            }\n        }\n        return false;\n    }\n\n\t/**\n\t* 这也是一个String的equals方法，与上一个方法不用，该方法(不区分大小写)，从名字也能看出来\n\t* 是对String的equals方法的补充。\n\t* 这里参数这是一个String对象，而不是Object了，因为这是String本身的方法，不是重写谁的方法\n\t*/\n\tpublic boolean equalsIgnoreCase(String anotherString) {\n        return (this == anotherString) ? true                   //一样，先判断是否为同一个对象\n                : (anotherString != null) \n                && (anotherString.value.length == value.length) //再判断长度是否相等\n               && regionMatches(true, 0, anotherString, 0, value.length);  //再执行regionMatchs方法 \n    }\n\t/**\n\t* 这是一个公有的比较方法，参数是StringBuffer类型\n\t* 实际调用的是contentEquals(CharSequence cs)方法，可以说是StringBuffer的特供版\n\t*/\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\t/**\n\t* 这是一个私有方法，特供给比较StringBuffer和StringBuilder使用的。\n\t* 比如在contentEquals方法中使用，参数是AbstractStringBuilder抽象类的子类\n\t*\n\t*/\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        char v1[] = value;               //当前String对象的值\n        char v2[] = sb.getValue();       //AbstractStringBuilder子类对象的值\n        int n = v1.length;               //后面就不说了，其实跟equals方法是一样的，只是少了一些判断\n        if (n != sb.length()) {\n            return false;\n        }\n        for (int i = 0; i < n; i++) {\n            if (v1[i] != v2[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\t/**\n\t* 这是一个常用于String对象跟StringBuffer和StringBuilder比较的方法\n\t* 参数是StringBuffer或StringBuilder或String或CharSequence\n\t* StringBuffer和StringBuilder和String都实现了CharSequence接口\n\t*/\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {   //如果是AbstractStringBuilder抽象类或其子类\n            if (cs instanceof StringBuffer) {        //如果是StringBuffer类型，进入同步块\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {                                 //如果是StringBuilder类型，则进入非同步块\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        \n\t\t/***下面就是String和CharSequence类型的比较算法*****/\n        // Argument is a String\n        if (cs instanceof String) {                    \n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        char v1[] = value;\n        int n = v1.length;\n        if (n != cs.length()) {\n            return false;\n        }\n        for (int i = 0; i < n; i++) {\n            if (v1[i] != cs.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n```\n\n以上代码重点说明：\n\n- equals()方法作为常用的方法，很具有层次感和借鉴意义，首先判断是否为同一个对象，再判断是否为要比较的类型，再判断两个对象的长度是否相等，首先从广的角度过滤筛选不符合的对象，再符合条件的对象基础上再一个一个字符的比较。\n- equalsIgnoreCase()方法是对equals()方法补充，不区分大小写的判断\n- contentEquals()则是用于String对象与4种类型的判断，通常用于跟StringBuilder和StringBuffer的判断,也是对equals方法的一个补充\n\n#### 8、regionMatchs()方法\n\n```java\n\t/**\n\t* 这是一个类似于equals的方法，比较的是字符串的片段，也即是部分区域的比较\n\t* toffset是当前字符串的比较起始位置(偏移量),other是要比较的String对象参数，ooffset是要参数String的比较片段起始位置，len是两个字符串要比较的片段的长度大小\n\t* \n\t* 例子：String str1 = \"0123456\",Str2 = \"0123456789\"; \n\t* str1.regionMatchs(0,str2,0,6);意思是str1从0位置开始于str2的0位置开始比较6个长度的字符串片段\n\t* 相等则返回 true,不等返回false \n\t*/\n\tpublic boolean regionMatches(int toffset, String other, int ooffset,\n            int len) {\n        char ta[] = value;  //当前对象的值\n        int to = toffset;   //当前对象的比较片段的起始位置，既偏移量\n        char pa[] = other.value;  //参数，既比较字符串的值\n        int po = ooffset;         //比较字符串的起始位置\n        // Note: toffset, ooffset, or len might be near -1>>>1.\n        if ((ooffset < 0) || (toffset < 0)  //起始位置不小于0或起始位置不大于字符串长度 - 片段长度，大于就截取不到这么长的片段了\n                || (toffset > (long)value.length - len)\n                || (ooffset > (long)other.value.length - len)) {\n            return false;      //惊讶脸，居然不是抛异常，而是返回false\n        }\n        while (len-- > 0) {               //使用while循环，当然也可以使for循环\n            if (ta[to++] != pa[po++]) {   //片段区域的字符元素逐个比较\n                return false;\n            }\n        }\n        return true;\n    }\n\n\t/**\n\t* 这个跟上面的方法一样，只不过多了一个参数，既ignoreCase,既是否为区分大小写。\n\t* 是equalsIgnoreCase()方法的片段比较版本，实际上equalsIgnoreCase()也是调用regionMatches函数\n\t*/\t\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        char ta[] = value;\n        int to = toffset;\n        char pa[] = other.value;\n        int po = ooffset;\n        // Note: toffset, ooffset, or len might be near -1>>>1.\n        if ((ooffset < 0) || (toffset < 0)\n                || (toffset > (long)value.length - len)\n                || (ooffset > (long)other.value.length - len)) {\n            return false;\n        }\n\t\t//上面的解释同上\n        while (len-- > 0) {\n            char c1 = ta[to++];\n            char c2 = pa[po++];\n            if (c1 == c2) {\n                continue;\n            }\n            if (ignoreCase) {   //当ignoreCase为true时，既忽视大小写时\n                // If characters don't match but case may be ignored,\n                // try converting both characters to uppercase.\n                // If the results match, then the comparison scan should\n                // continue.\n                char u1 = Character.toUpperCase(c1);   //片段中每个字符转换为大写\n                char u2 = Character.toUpperCase(c2);\n                if (u1 == u2) { //大写比较一次，如果相等则不执行下面的语句，进入下一个循环\n                    continue;\n                }\n                // Unfortunately, conversion to uppercase does not work properly\n                // for the Georgian alphabet, which has strange rules about case\n                // conversion.  So we need to make one last check before\n                // exiting.\n                if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) {\n                 //每个字符换行成小写比较一次\n                    continue;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n```\n\n**从上可以看出：**\n\n- 片段比较时针对String对象的。所以如果你要跟StringBuffer和StringBuilder比较，那么记得toString.\n- 如果你要进行两个字符串之间的片段比较的话，就可以使用regionMatches，如果是完整的比较那么就equals吧\n\n#### 9、compareTo类函数和CaseInsensitiveComparator静态内部类\n\n```java\n\t/**\n\t* 这是一个比较字符串中字符大小的函数，因为String实现了Comparable<String>接口,所以重写了compareTo方法\n\t* Comparable是排序接口。若一个类实现了Comparable接口，就意味着该类支持排序。\n\t* 实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。\n\t* 参数是需要比较的另一个String对象\n\t* 返回的int类型，正数为大，负数为小，是基于字符的ASSIC码比较的\n\t*/\n\tpublic int compareTo(String anotherString) {\n        int len1 = value.length;                  //当前对象的长度\n        int len2 = anotherString.value.length;    //比较对象的长度\n        int lim = Math.min(len1, len2);           //获得最小长度\n        char v1[] = value;                        //获得当前对象的值\n        char v2[] = anotherString.value;          //获得比较对象的值\n\n        int k = 0;                                //相当于for的int k = 0,就是为while循环的数组服务的\n        while (k < lim) {        //当当前索引小于两个字符串中较短字符串的长度时，循环继续\n            char c1 = v1[k];          //获得当前对象的字符\n            char c2 = v2[k];          //获得比较对象的字符\n            if (c1 != c2) {           //从前向后遍历，只要其实一个不相等，返回字符ASSIC的差值,int类型\n                return c1 - c2;\n            }\n            k++;\n        }\n        return len1 - len2;           //如果两个字符串同样位置的索引都相等，返回长度差值，完全相等则为0\n    }\n\t\n\t/**\n\t*  这时一个类似compareTo功能的方法，但是不是comparable接口的方法，是String本身的方法\n\t*  使用途径，我目前只知道可以用来不区分大小写的比较大小，但是不知道如何让它被工具类Collections和Arrays运用\n\t*\n\t*/\n\tpublic int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }  \n    /**\n    * 这是一个饿汉单例模式，是String类型的一个不区分大小写的比较器\n    * 提供给Collections和Arrays的sort方法使用\n    * 例如：Arrays.sort(strs,String.CASE_INSENSITIVE_ORDER);\n    * 效果就是会将strs字符串数组中的字符串对象进行忽视大小写的排序\n    *\n    */\n    public static final Comparator<String> CASE_INSENSITIVE_ORDER\n                                         = new CaseInsensitiveComparator();\n\t/**\n\t* 这一个私有的静态内部类，只允许String类本身调用\n\t* 实现了序列化接口和比较器接口，comparable接口和comparator是有区别的\n\t* 重写了compare方法，该静态内部类实际就是一个String类的比较器\n\t*\n\t*/\n\tprivate static class CaseInsensitiveComparator\n            implements Comparator<String>, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        private static final long serialVersionUID = 8575799808933029326L;\n        public int compare(String s1, String s2) {\n            int n1 = s1.length();                 //s1字符串的长度\n            int n2 = s2.length();                 //s2字符串的长度\n            int min = Math.min(n1, n2);           //获得最小长度 \n            for (int i = 0; i < min; i++) {\n                char c1 = s1.charAt(i);           //逐一获得字符串i位置的字符\n                char c2 = s2.charAt(i);\n                if (c1 != c2) {                   //部分大小写比较一次\n                    c1 = Character.toUpperCase(c1);    //转换大写比较一次\n                    c2 = Character.toUpperCase(c2);\n                    if (c1 != c2) {\n                        c1 = Character.toLowerCase(c1);  //转换小写比较一次\n                        c2 = Character.toLowerCase(c2);\n                        if (c1 != c2) {                  //返回字符差值\n                            // No overflow because of numeric promotion\n                            return c1 - c2;\n                        }\n                    }\n                }\n            }\n            return n1 - n2;  //如果字符相等，但是长度不等，则返回长度差值，短的教小，所以小-大为负数\n        }\n        /** Replaces the de-serialized object. */\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n```\n\n以上的代码可以看出：\n\n- 以上的最大问题可以能就是为什么要有个静态内部类，为什么实现了compareTo又有compare，移步到下面，有解答\n- String实现了comparable接口，重写了compareTo方法，可以用于自己写类进行判断排序，也可以使用collections，Arrays工具类的sort进行排序。只有集合或数组中的元素实现了comparable接口，并重写了compareTo才能使用工具类排序。\n- CASE_INSENSITIVE_ORDER是一个单例，是String提供为外部的比较器，该比较器的作用是忽视大小写进行比较，我们可以通过Collections或Arrays的sort方法将CASE_INSENSITIVE_ORDER比较器作为参数传入，进行排序。\n\n#### 10、startWith、endWith类函数\n\n```java\n\t/**\n\t* 作用就是当前对象[toffset,toffset + prefix.value.lenght]区间的字符串片段等于prefix\n\t* 也可以说当前对象的toffset位置开始是否以prefix作为前缀\n\t* prefix是需要判断的前缀字符串，toffset是当前对象的判断起始位置\n\t*/\n    public boolean startsWith(String prefix, int toffset) {\n        char ta[] = value;     //获得当前对象的值\n        int to = toffset;      //获得需要判断的起始位置，偏移量\n        char pa[] = prefix.value; //获得前缀字符串的值\n        int po = 0;\n        int pc = prefix.value.length;\n        // Note: toffset might be near -1>>>1.\n        if ((toffset < 0) || (toffset > value.length - pc)) {  //偏移量不能小于0且能截取pc个长度\n                    return false;  //不能则返回false\n        }\n        while (--pc >= 0) {                  //循环pc次，既prefix的长度\n            if (ta[to++] != pa[po++]) {      //每次比较当前对象的字符串的字符是否跟prefix一样\n                return false;                //一样则pc--,to++,po++,有一个不同则返回false\n            }\n        }\n        return true;  //没有不一样则返回true，当前对象是以prefix在toffset位置做为开头\n    }\n\t/**\n\t* 判断当前字符串对象是否以字符串prefix起头\n\t* 是返回true,否返回fasle\n\t*/\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\t/**\n\t* 判断当前字符串对象是否以字符串prefix结尾\n\t* 是返回true,否返回fasle\n\t*/\n    public boolean endsWith(String suffix) {\n\t    //suffix是需要判断是否为尾部的字符串。\n\t    //value.length - suffix.value.length是suffix在当前对象的起始位置\n        return startsWith(suffix, value.length - suffix.value.length); \n    }\n```\n\n- endsWith的实现也是startWith()，作用就是判断前后缀\n\n#### 11、hashCode()函数\n\n```java\n  /**\n   * 这是String字符串重写了Object类的hashCode方法。\n   * 给由哈希表来实现的数据结构来使用，比如String对象要放入HashMap中。\n   * 如果没有重写HashCode，或HaseCode质量很差则会导致严重的后果，既不靠谱的后果\n   *\n   */\n   public int hashCode() {\n        int h = hash;  //hash是属性字段，是成员变量，所以默认为0\n        if (h == 0 && value.length > 0) { //如果hash为0，且字符串对象长度大于0，不为\"\"\n            char val[] = value;   //获得当前对象的值\n\t\t\t\n\t\t\t//重点，String的哈希函数\n\t\t\n            for (int i = 0; i < value.length; i++) {  //遍历len次\n                h = 31 * h + val[i];         //每次都是31 * 每次循环获得的h +第i个字符的ASSIC码\n            }\n            hash = h;\n        }\n        return h;  //由此可见\"\"空字符对象的哈希值为0\n    }\n```\n\n所以我们可以知道：\n\n- hashCode的重点就是哈希函数\n- String的哈希函数就是循环len次，每次循环体为 `31 * 每次循环获得的hash + 第i次循环的字符`\n\n#### 12、indexOf、lastIndexOf类函数\n\n```java\n\t/**\n\t* 返回cn对应的字符在字符串中第一次出现的位置，从字符串的索引0位置开始遍历\n\t* \n\t*/\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n\t/**\n\t * index方法就是返回ch字符第一次在字符串中出现的位置\n\t * 既从fromIndex位置开始查找，从头向尾遍历，ch整数对应的字符在字符串中第一次出现的位置\n\t * -1代表字符串没有这个字符，整数代表字符第一次出现在字符串的位置\n\t */\n    public int indexOf(int ch, int fromIndex) {\n        final int max = value.length; //获得字符串对象的长度\n        if (fromIndex < 0) {             //如果偏移量小于0，则代表偏移量为0，校正偏移量\n            fromIndex = 0;\n        } else if (fromIndex >= max) {   //如果偏移量大于最大长度，则返回-1，代表没有字符串没有ch对应的字符\n            // Note: fromIndex might be near -1>>>1.\n            return -1;\n        }\n\n        if (ch < Character.MIN_SUPPLEMENTARY_CODE_POINT) { //emmm,这个判断，不懂\n            // handle most cases here (ch is a BMP code point or a\n            // negative value (invalid code point))\n            final char[] value = this.value;             //获得字符串值\n            for (int i = fromIndex; i < max; i++) {      //从fromIndex位置开始向后遍历\n                if (value[i] == ch) {                    //只有字符串中的某个位置的元素等于ch\n                    return i;                            //返回对应的位置，函数结束，既第一次出现的位置\n                }\n            }\n            return -1;  //如果没有出现，则返回-1\n        } else {\n            return indexOfSupplementary(ch, fromIndex);  //emmm,紧紧接着没看懂的地方\n        }\n    }\n\n\n    private int indexOfSupplementary(int ch, int fromIndex) {\n        if (Character.isValidCodePoint(ch)) {\n            final char[] value = this.value;\n            final char hi = Character.highSurrogate(ch);\n            final char lo = Character.lowSurrogate(ch);\n            final int max = value.length - 1;\n            for (int i = fromIndex; i < max; i++) {\n                if (value[i] == hi && value[i + 1] == lo) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n\t/**\n\t* 从尾部向头部遍历，返回cn第一次出现的位置，value.length - 1就是起点 \n\t* 为了理解，我们可以认为是返回cn对应的字符在字符串中最后出现的位置\n\t*  \n\t* ch是字符对应的整数\n\t*/\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, value.length - 1);\n    }\n\n\t/**\n\t* 从尾部向头部遍历，从fromIndex开始作为起点，返回ch对应字符第一次在字符串出现的位置\n\t* 既从头向尾遍历，返回cn对应字符在字符串中最后出现的一次位置，fromIndex为结束点\n\t*\n\t*/\n    public int lastIndexOf(int ch, int fromIndex) {\n        if (ch < Character.MIN_SUPPLEMENTARY_CODE_POINT) {  //之后不解释了,emmmmmmm\n            // handle most cases here (ch is a BMP code point or a\n            // negative value (invalid code point))\n            final char[] value = this.value;\n            //取最小值，作用就是校正，如果fromIndex传大了，就当时len - 1\n            int i = Math.min(fromIndex, value.length - 1);   \n            for (; i >= 0; i--) {      //算法中是从后向前遍历，直到i<0,退出循环\n                if (value[i] == ch) {  //只有有相等，返回对应的索引位置\n                    return i;\n                }\n            }\n            return -1;   //没有找到则返回-1\n        } else {\n            return lastIndexOfSupplementary(ch, fromIndex);\n        }\n    }\n\n\n    private int lastIndexOfSupplementary(int ch, int fromIndex) {\n        if (Character.isValidCodePoint(ch)) {\n            final char[] value = this.value;\n            char hi = Character.highSurrogate(ch);\n            char lo = Character.lowSurrogate(ch);\n            int i = Math.min(fromIndex, value.length - 2);\n            for (; i >= 0; i--) {\n                if (value[i] == hi && value[i + 1] == lo) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n\t/**\n\t* 返回第一次出现的字符串的位置\n\t*\n\t*/\n    public int indexOf(String str) {\n        return indexOf(str, 0);\n    }\n\n\t/**\n\t*\n\t* 从fromIndex开始遍历，返回第一次出现str字符串的位置\n\t*\n\t*/\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, 0, value.length,\n                str.value, 0, str.value.length, fromIndex);\n    }\n\n\t/**\n\t* 这是一个不对外公开的静态函数\n\t* source就是原始字符串，sourceOffset就是原始字符串的偏移量，起始位置。\n\t* sourceCount就是原始字符串的长度，target就是要查找的字符串。\n\t* fromIndex就是从原始字符串的第fromIndex开始遍历\n\t*\n\t*/\n    static int indexOf(char[] source, int sourceOffset, int sourceCount,\n            String target, int fromIndex) {\n        return indexOf(source, sourceOffset, sourceCount,\n                       target.value, 0, target.value.length,\n                       fromIndex);\n    }\n\n\t/**\n\t* 同是一个不对外公开的静态函数\n\t* 比上更为强大。\n\t* 多了一个targetOffset和targetCount，既代表别查找的字符串也可以被切割\n\t*/\n    static int indexOf(char[] source, int sourceOffset, int sourceCount,\n            char[] target, int targetOffset, int targetCount,\n            int fromIndex) {\n        if (fromIndex >= sourceCount) {   //如果查找的起点大于当前对象的大小\n\t        //如果目标字符串的长度为0，则代表目标字符串为\"\"，\"\"在任何字符串都会出现\n\t        //配合fromIndex >= sourceCount,所以校正第一次出现在最尾部，仅仅是校正作用\n            return (targetCount == 0 ? sourceCount : -1); \n        }\n        if (fromIndex < 0) {  //也是校正，如果起始点小于0，则返回0\n            fromIndex = 0;\n        }\n        if (targetCount == 0) { //如果目标字符串长度为0，代表为\"\"，则第一次出现在遍历起始点fromIndex\n            return fromIndex;\n        }\n\n        char first = target[targetOffset];   //目标字符串的第一个字符\n        int max = sourceOffset + (sourceCount - targetCount); //最大遍历次数\n\n        for (int i = sourceOffset + fromIndex; i <= max; i++) {\n            /* Look for first character. */\n            if (source[i] != first) {\n                while (++i <= max && source[i] != first);\n            }\n\n            /* Found first character, now look at the rest of v2 */\n            if (i <= max) {\n                int j = i + 1;\n                int end = j + targetCount - 1;\n                for (int k = targetOffset + 1; j < end && source[j]\n                        == target[k]; j++, k++);\n\n                if (j == end) {\n                    /* Found whole string. */\n                    return i - sourceOffset;\n                }\n            }\n        }\n        return -1;\n    }\n\n\t/**\n\t* 查找字符串Str最后一次出现的位置\n\t*/\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, value.length);\n    }\n\n\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, 0, value.length,\n                str.value, 0, str.value.length, fromIndex);\n    }\n\n\n    static int lastIndexOf(char[] source, int sourceOffset, int sourceCount,\n            String target, int fromIndex) {\n        return lastIndexOf(source, sourceOffset, sourceCount,\n                       target.value, 0, target.value.length,\n                       fromIndex);\n    }\n\n\n    static int lastIndexOf(char[] source, int sourceOffset, int sourceCount,\n            char[] target, int targetOffset, int targetCount,\n            int fromIndex) {\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don't check for null str.\n         */\n        int rightIndex = sourceCount - targetCount;\n        if (fromIndex < 0) {\n            return -1;\n        }\n        if (fromIndex > rightIndex) {\n            fromIndex = rightIndex;\n        }\n        /* Empty string always matches. */\n        if (targetCount == 0) {\n            return fromIndex;\n        }\n\n        int strLastIndex = targetOffset + targetCount - 1;\n        char strLastChar = target[strLastIndex];\n        int min = sourceOffset + targetCount - 1;\n        int i = min + fromIndex;\n        \n    startSearchForLastChar:\n        while (true) {\n            while (i >= min && source[i] != strLastChar) {\n                i--;\n            }\n            if (i < min) {\n                return -1;\n            }\n            int j = i - 1;\n            int start = j - (targetCount - 1);\n            int k = strLastIndex - 1;\n            while (j > start) {\n                if (source[j--] != target[k--]) {\n                    i--;\n                    continue startSearchForLastChar;\n                }\n            }\n            return start - sourceOffset + 1;\n        }\n    }\n```\n\n- 只对外提供了int整形，String字符串两种参数的重载方法(虽然是Int型，其实我们就当做是传char也无所谓，因为虚拟机会帮我们解决这个事情的)\n\n#### 13、substring()函数\n\n```java\n\t/**\n\t*  截取当前字符串对象的片段，组成一个新的字符串对象\n\t*  beginIndex为截取的初始位置，默认截到len - 1位置\n\t*/\n\tpublic String substring(int beginIndex) {\n        if (beginIndex < 0) {   //小于0抛异常\n            throw new StringIndexOutOfBoundsException(beginIndex);\n        }\n        int subLen = value.length - beginIndex;  //新字符串的长度\n        if (subLen < 0) {       //小于0抛异常\n            throw new StringIndexOutOfBoundsException(subLen);\n        }\n        //如果beginIndex是0，则不用截取，返回自己(非新对象)，否则截取0到subLen位置，不包括(subLen)\n        return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);\n    }\n\n\t/**\n\t* 截取一个区间范围\n\t* [beginIndex,endIndex)，不包括endIndex\n\t*/\n    public String substring(int beginIndex, int endIndex) {\n        if (beginIndex < 0) {\n            throw new StringIndexOutOfBoundsException(beginIndex);\n        }\n        if (endIndex > value.length) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        int subLen = endIndex - beginIndex;\n        if (subLen < 0) {\n            throw new StringIndexOutOfBoundsException(subLen);\n        }\n        return ((beginIndex == 0) && (endIndex == value.length)) ? this\n                : new String(value, beginIndex, subLen);\n    }\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n```\n\n#### 14、concat()函数\n\n```java\n\t/**\n\t* String的拼接函数\n\t* 例如:String  str = \"abc\"; str.concat(\"def\")    output: \"abcdef\"\n\t*\n\t*/\n\tpublic String concat(String str) {\n        int otherLen = str.length();//获得参数字符串的长度\n        if (otherLen == 0) { //如果长度为0，则代表不需要拼接，因为str为\"\"\n            return this;\n        }\n\t\t/****重点****/\n        int len = value.length;  //获得当前对象的长度 \n        //将数组扩容，将value数组拷贝到buf数组中，长度为len + str.lenght\n        char buf[] = Arrays.copyOf(value, len + otherLen); \n        str.getChars(buf, len);//然后将str字符串从buf字符数组的len位置开始覆盖,得到一个完整的buf字符数组\n        return new String(buf, true);//构建新的String对象，调用私有的String构造方法\n    }\n```\n\n#### 15、replace、replaceAll类函数\n\n```java\n\t//替换，将字符串中的oldChar字符全部替换成newChar\n\tpublic String replace(char oldChar, char newChar) {\n        if (oldChar != newChar) {    //如果旧字符不等于新字符的情况下\n            int len = value.length;  //获得字符串长度\n            int i = -1;              //flag\n            char[] val = value; /* avoid getfield opcode */\n\n            while (++i < len) {      //循环len次\n                if (val[i] == oldChar) { //找到第一个旧字符，打断循环\n                    break;\n                }\n            }\n            if (i < len) {   //如果第一个旧字符的位置小于len\n                char buf[] = new char[len]; 新new一个字符数组，len个长度\n                for (int j = 0; j < i; j++) {\n                    buf[j] = val[j];        把旧字符的前面的字符都复制到新字符数组上\n                }\n                while (i < len) {           //从i位置开始遍历\n                    char c = val[i];\n                    buf[i] = (c == oldChar) ? newChar : c; //发生旧字符就替换，不想关的则直接复制\n                    i++;\n                }\n                return new String(buf, true);  //通过新字符数组buf重构一个新String对象\n            }\n        }\n        return this;  //如果old = new ，直接返回自己\n    }\n\t//替换第一个旧字符\n\tString replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\t//当不是正规表达式时，与replace效果一样，都是全体换。如果字符串的正则表达式，则规矩表达式全体替换\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\t//可以用旧字符串去替换新字符串\n    public String replace(CharSequence target, CharSequence replacement) {\n        return Pattern.compile(target.toString(), Pattern.LITERAL).matcher(\n                this).replaceAll(Matcher.quoteReplacement(replacement.toString()));\n    }\n```\n\n- 从replace的算法中，我们可以发现，它不是从头开始遍历替换的，而是首先找到第一个要替换的字符，从要替换的字符开始遍历，发现一个替换一个。但是我暂时没有弄清除这样子的好处是什么，节省时间？应该是吧\n- 四种用法，字符全替换字符，表达式全体换字符，表达式只替换第一个字符，字符串替换字符串\n\n#### 16、matches()和contains()函数\n\n```java\n\t/**\n\t* matches() 方法用于检测字符串是否匹配给定的正则表达式。\n\t* regex -- 匹配字符串的正则表达式。\n\t* 如：String Str = new String(\"www.snailmann.com\");\n\t* System.out.println(Str.matches(\"(.*)snailmann(.*)\"));   output:true\n\t* System.out.println(Str.matches(\"www(.*)\"));             output:true\n\t*/\n\tpublic boolean matches(String regex) {\n        return Pattern.matches(regex, this);   //实际使用的是Pattern.matches()方法\n    }\n\n\t//是否含有CharSequence这个子类元素，通常用于StrngBuffer,StringBuilder\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) > -1;\n    }\n\n```\n\n#### 17、split()函数\n\n```\n\tpublic String[] split(String regex, int limit) {\n        /* fastpath if the regex is a\n         (1)one-char String and this character is not one of the\n            RegEx's meta characters \".$|()[{^?*+\\\\\", or\n         (2)two-char String and the first char is the backslash and\n            the second is not the ascii digit or ascii letter.\n         */\n        char ch = 0;\n        if (((regex.value.length == 1 &&\n             \".$|()[{^?*+\\\\\".indexOf(ch = regex.charAt(0)) == -1) ||\n             (regex.length() == 2 &&\n              regex.charAt(0) == '\\\\' &&\n              (((ch = regex.charAt(1))-'0')|('9'-ch)) < 0 &&\n              ((ch-'a')|('z'-ch)) < 0 &&\n              ((ch-'A')|('Z'-ch)) < 0)) &&\n            (ch < Character.MIN_HIGH_SURROGATE ||\n             ch > Character.MAX_LOW_SURROGATE))\n        {\n            int off = 0;\n            int next = 0;\n            boolean limited = limit > 0;\n            ArrayList<String> list = new ArrayList<>();\n            while ((next = indexOf(ch, off)) != -1) {\n                if (!limited || list.size() < limit - 1) {\n                    list.add(substring(off, next));\n                    off = next + 1;\n                } else {    // last one\n                    //assert (list.size() == limit - 1);\n                    list.add(substring(off, value.length));\n                    off = value.length;\n                    break;\n                }\n            }\n            // If no match was found, return this\n            if (off == 0)\n                return new String[]{this};\n\n            // Add remaining segment\n            if (!limited || list.size() < limit)\n                list.add(substring(off, value.length));\n\n            // Construct result\n            int resultSize = list.size();\n            if (limit == 0) {\n                while (resultSize > 0 && list.get(resultSize - 1).length() == 0) {\n                    resultSize--;\n                }\n            }\n            String[] result = new String[resultSize];\n            return list.subList(0, resultSize).toArray(result);\n        }\n        return Pattern.compile(regex).split(this, limit);\n    }\n    public String[] split(String regex) {\n        return split(regex, 0);\n    }\n```\n\n#### 18、join()函数\n\n```java\n/**\n  * join方法是JDK1.8加入的新函数，静态方法\n  * 这个方法就是跟split有些对立的函数,不过join是静态方法\n  * delimiter就是分割符，后面就是要追加的可变参数，比如str1,str2,str3\n  * \n  * 例子：String.join(\",\",new String(\"a\"),new String(\"b\"),new String(\"c\"))\n  * output: \"a,b,c\"\n  */\t\n  public static String join(CharSequence delimiter, CharSequence... elements) {\n        Objects.requireNonNull(delimiter);  //就是检测是否为Null,是null,抛异常\n        Objects.requireNonNull(elements);   //不是就返回自己，即nothing happen\n        // Number of elements not likely worth Arrays.stream overhead.\n        StringJoiner joiner = new StringJoiner(delimiter);  //嗯，有兴趣自己看StringJoiner类源码啦\n        for (CharSequence cs: elements) {\n            joiner.add(cs);   //既用分割符delimiter将所有可变参数的字符串分割，合并成一个字符串\n        }\n        return joiner.toString();\n    }\n    \n   /**\n   * 功能是一样的，不过传入的参数不同\n   * 这里第二个参数一般就是装着CharSequence子类的集合\n   * 比如String.join(\",\",lists)   \n   * list可以是一个Collection接口实现类，所含元素的基类必须是CharSequence类型\n   * 比如String,StringBuilder,StringBuffer等\n   */ \n   public static String join(CharSequence delimiter,\n            Iterable<? extends CharSequence> elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        StringJoiner joiner = new StringJoiner(delimiter);\n        for (CharSequence cs: elements) {\n            joiner.add(cs);\n        }\n        return joiner.toString();\n    }\n```\n\n- Java 1.8加入的新功能，有点跟split对立的意思，是个静态方法\n- 有两个重载方法，一个是直接传字符串数组，另个是传集合。传集合的方式是一个好功能，很方遍将集合的字符串元素拼接成一个字符串。(分割符为 `\"\"` ,well, It’s great!!)\n\n#### 19、trim()函数\n\n```java\n\t/**\n\t* 去除字符串首尾部分的空值，如,' ' or \" \",非\"\"\n\t* 原理是通过substring去实现的，首尾各一个指针\n\t* 头指针发现空值就++，尾指针发现空值就--\n\t* ' '的Int值为32，其实不仅仅是去空的作用，应该是整数值小于等于32的去除掉\n\t*/\n   public String trim() {\n        int len = value.length; //代表尾指针，实际是尾指针+1的大小\n\t\tint st = 0;             //代表头指针\n        char[] val = value;    /* avoid getfield opcode */\n\t\t\n\t\t//st<len,且字符的整数值小于32则代表有空值，st++\n        while ((st < len) && (val[st] <= ' ')) {   \n            st++;\n        }\n\t    //len - 1才是真正的尾指针，如果尾部元素的整数值<=32,则代表有空值，len--\n        while ((st < len) && (val[len - 1] <= ' ')) {\n            len--;\n        }\n        //截取st到len的字符串(不包括len位置)\n        return ((st > 0) || (len < value.length)) ? substring(st, len) : this;\n    }\n```\n\n- 常见去首尾的空值，实际是去除首尾凡是小于32的字符\n\n#### 20、toString()函数\n\n```java\n\t //emmmmm,这个就不说了吧，就是返回自己\n\t public String toString() {\n        return this;\n\t }\n```\n\n#### 21、toCharArray()函数\n\n```java\n\t/**\n\t* 就是将String转换为字符数组并返回\n\t*/\n\t public char[] toCharArray() {\n        // Cannot use Arrays.copyOf because of class initialization order issues\n        char result[] = new char[value.length];     //定义一个要返回的空数组，长度为字符串长度\n        System.arraycopy(value, 0, result, 0, value.length); //拷贝\n        return result; //返回\n\t }\n```\n\n#### 22、toLowerCase()、toUpperCase()函数\n\n```java\n//en,好长,下次再更新吧，先用着吧\npublic String toLowerCase(Locale locale) {\n        if (locale == null) {\n            throw new NullPointerException();\n        }\n\n        int firstUpper;\n        final int len = value.length;\n\n        /* Now check if there are any characters that need to be changed. */\n        scan: {\n            for (firstUpper = 0 ; firstUpper < len; ) {\n                char c = value[firstUpper];\n                if ((c >= Character.MIN_HIGH_SURROGATE)\n                        && (c <= Character.MAX_HIGH_SURROGATE)) {\n                    int supplChar = codePointAt(firstUpper);\n                    if (supplChar != Character.toLowerCase(supplChar)) {\n                        break scan;\n                    }\n                    firstUpper += Character.charCount(supplChar);\n                } else {\n                    if (c != Character.toLowerCase(c)) {\n                        break scan;\n                    }\n                    firstUpper++;\n                }\n            }\n            return this;\n        }\n\n        char[] result = new char[len];\n        int resultOffset = 0;  /* result may grow, so i+resultOffset\n                                * is the write location in result */\n\n        /* Just copy the first few lowerCase characters. */\n        System.arraycopy(value, 0, result, 0, firstUpper);\n\n        String lang = locale.getLanguage();\n        boolean localeDependent =\n                (lang == \"tr\" || lang == \"az\" || lang == \"lt\");\n        char[] lowerCharArray;\n        int lowerChar;\n        int srcChar;\n        int srcCount;\n        for (int i = firstUpper; i < len; i += srcCount) {\n            srcChar = (int)value[i];\n            if ((char)srcChar >= Character.MIN_HIGH_SURROGATE\n                    && (char)srcChar <= Character.MAX_HIGH_SURROGATE) {\n                srcChar = codePointAt(i);\n                srcCount = Character.charCount(srcChar);\n            } else {\n                srcCount = 1;\n            }\n            if (localeDependent ||\n                srcChar == '\\u03A3' || // GREEK CAPITAL LETTER SIGMA\n                srcChar == '\\u0130') { // LATIN CAPITAL LETTER I WITH DOT ABOVE\n                lowerChar = ConditionalSpecialCasing.toLowerCaseEx(this, i, locale);\n            } else {\n                lowerChar = Character.toLowerCase(srcChar);\n            }\n            if ((lowerChar == Character.ERROR)\n                    || (lowerChar >= Character.MIN_SUPPLEMENTARY_CODE_POINT)) {\n                if (lowerChar == Character.ERROR) {\n                    lowerCharArray =\n                            ConditionalSpecialCasing.toLowerCaseCharArray(this, i, locale);\n                } else if (srcCount == 2) {\n                    resultOffset += Character.toChars(lowerChar, result, i + resultOffset) - srcCount;\n                    continue;\n                } else {\n                    lowerCharArray = Character.toChars(lowerChar);\n                }\n\n                /* Grow result if needed */\n                int mapLen = lowerCharArray.length;\n                if (mapLen > srcCount) {\n                    char[] result2 = new char[result.length + mapLen - srcCount];\n                    System.arraycopy(result, 0, result2, 0, i + resultOffset);\n                    result = result2;\n                }\n                for (int x = 0; x < mapLen; ++x) {\n                    result[i + resultOffset + x] = lowerCharArray[x];\n                }\n                resultOffset += (mapLen - srcCount);\n            } else {\n                result[i + resultOffset] = (char)lowerChar;\n            }\n        }\n        return new String(result, 0, len + resultOffset);\n    }\n\n\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n\n    public String toUpperCase(Locale locale) {\n        if (locale == null) {\n            throw new NullPointerException();\n        }\n\n        int firstLower;\n        final int len = value.length;\n\n        /* Now check if there are any characters that need to be changed. */\n        scan: {\n            for (firstLower = 0 ; firstLower < len; ) {\n                int c = (int)value[firstLower];\n                int srcCount;\n                if ((c >= Character.MIN_HIGH_SURROGATE)\n                        && (c <= Character.MAX_HIGH_SURROGATE)) {\n                    c = codePointAt(firstLower);\n                    srcCount = Character.charCount(c);\n                } else {\n                    srcCount = 1;\n                }\n                int upperCaseChar = Character.toUpperCaseEx(c);\n                if ((upperCaseChar == Character.ERROR)\n                        || (c != upperCaseChar)) {\n                    break scan;\n                }\n                firstLower += srcCount;\n            }\n            return this;\n        }\n\n        /* result may grow, so i+resultOffset is the write location in result */\n        int resultOffset = 0;\n        char[] result = new char[len]; /* may grow */\n\n        /* Just copy the first few upperCase characters. */\n        System.arraycopy(value, 0, result, 0, firstLower);\n\n        String lang = locale.getLanguage();\n        boolean localeDependent =\n                (lang == \"tr\" || lang == \"az\" || lang == \"lt\");\n        char[] upperCharArray;\n        int upperChar;\n        int srcChar;\n        int srcCount;\n        for (int i = firstLower; i < len; i += srcCount) {\n            srcChar = (int)value[i];\n            if ((char)srcChar >= Character.MIN_HIGH_SURROGATE &&\n                (char)srcChar <= Character.MAX_HIGH_SURROGATE) {\n                srcChar = codePointAt(i);\n                srcCount = Character.charCount(srcChar);\n            } else {\n                srcCount = 1;\n            }\n            if (localeDependent) {\n                upperChar = ConditionalSpecialCasing.toUpperCaseEx(this, i, locale);\n            } else {\n                upperChar = Character.toUpperCaseEx(srcChar);\n            }\n            if ((upperChar == Character.ERROR)\n                    || (upperChar >= Character.MIN_SUPPLEMENTARY_CODE_POINT)) {\n                if (upperChar == Character.ERROR) {\n                    if (localeDependent) {\n                        upperCharArray =\n                                ConditionalSpecialCasing.toUpperCaseCharArray(this, i, locale);\n                    } else {\n                        upperCharArray = Character.toUpperCaseCharArray(srcChar);\n                    }\n                } else if (srcCount == 2) {\n                    resultOffset += Character.toChars(upperChar, result, i + resultOffset) - srcCount;\n                    continue;\n                } else {\n                    upperCharArray = Character.toChars(upperChar);\n                }\n\n                /* Grow result if needed */\n                int mapLen = upperCharArray.length;\n                if (mapLen > srcCount) {\n                    char[] result2 = new char[result.length + mapLen - srcCount];\n                    System.arraycopy(result, 0, result2, 0, i + resultOffset);\n                    result = result2;\n                }\n                for (int x = 0; x < mapLen; ++x) {\n                    result[i + resultOffset + x] = upperCharArray[x];\n                }\n                resultOffset += (mapLen - srcCount);\n            } else {\n                result[i + resultOffset] = (char)upperChar;\n            }\n        }\n        return new String(result, 0, len + resultOffset);\n    }\n\n\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n```\n\n#### 23、format()函数\n\n```java\n\t//JAVA字符串格式化\n\t//新字符串使用本地语言环境，制定字符串格式和参数生成格式化的新字符串。\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n\t//使用指定的语言环境，制定字符串格式和参数生成格式化的字符串。\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n```\n\n#### 24、valueOf类函数\n\n```java\n\t//将Object转换为String\n\t\n    public static String valueOf(Object obj) {\n        return (obj == null) ? \"null\" : obj.toString();\n    }\n\n\t//将char数组转换为String\n    public static String valueOf(char data[]) {\n        return new String(data);\n    }\n\n\t//将字符数组的子数组转换为String\n    public static String valueOf(char data[], int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    //e...重复\n    public static String copyValueOf(char data[], int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n\t//e...重复\n    public static String copyValueOf(char data[]) {\n        return new String(data);\n    }\n\n    //将布尔值转换为String\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n\t//将单个字符转换为String\n    public static String valueOf(char c) {\n        char data[] = {c};\n        return new String(data, true);\n    }\n\n\t//将int转换为String\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n\t//将long转换为String\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n    \n\t//将float转换为String\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\t\n\t//将double转换为String\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n```\n\n- copyValueOf和valueOf在Java8看来已经是完全没有区别的函数\n- 所有的value的本质都是新new一个String对象\n\n#### 25、intern()函数\n\n```java\npublic native String intern();\n```\n\nString类中唯一的一条本地方法，既不是用Java语言实现的方法。\n比如str.intern(),作用就是去字符串常量池中寻找str字符串，如果有则返回str在常量池中的引用，如果没有则在常量池中创建str对象\n\n#### 26、相关问题\n\nString类和CharSequencee接口的关系\nCharSequence是一个接口，它只包括length(), charAt(int index), subSequence(int start, int end)这几个API接口。继承了CharSequence代表着这是一个有序的字符集合。\n\nString类为何为不可变类型?\n从String的定义，我们可以知道,String类是被final修饰的，是一个不可被继承的类\n同时我们从字段属性的private final char value[]可以看出，String的本质char数组也是一个不可变的数组对象，且是私有的，不对外公开。\n另外String类也没有提供对value进行修改的方法，所以外部也没有途径对String对象的值进行修改\n从其他的方法中，我们也可以看到，如果是对字符串进行修改，其本质是new了一个新的String的对象\n注意：\nString对象是真的无法修改吗？\n答案是否定的，还是有途径修改的，那就是通过反射。\n因为final的是字符数组，只代表这个value变量的引用不能改变，不代表value指向的对象不可以改变，String只是没有提供修改的途径，即使有也会是不对外公开。但数组中的元素是可以修改的，虽然没有途径，但还是反射就是一个逆天的存在，我们可以通过反射的途径去修改字符数组value的元素的值。\n\n所以String的不可变性仅仅是正常情况下的不可变，但绝非完全的不可变。\n\nString类length与codePointCount的区别\n对于普通字符串，这两种方法得到的值是一样的，但对于UniCode编码来说，还是有一点区别。\n区别：\nlength()方法返回的是使用的是UTF-16编码的字符代码单元数量，不一定是实际上我们认为的字符个数。codePointCount()方法返回的是代码点个数，是实际上的字符个数。\n\n例如：\nString str = “/uD835/uDD6B”，那么机器会识别它是2个代码单元代理的1个代码点”Z“，故而，length的结果是代码单元数量2，而codePointCount()的结果是代码点数量1.\n\n为什么String已经有一个compareTo方法了，还需要一个静态内部类再实现compare?\n这里有一个疑惑，在String中已经有了一个compareTo的方法，为什么还要有一个CaseInsensitiveComparator的内部静态类呢？网上的回答大多数都是说是为了代码复用，我觉得这是有道理的。\n\n首先是一个代码复用的问题，因为String类的compareToIgnoreCase方法实际调用的也是静态内部的compare方法\n其次这里采用了饿汉单例模式\n个人想法：\n我个人觉得，为什么要有个静态内部类呢，首先我们要区别comparable和comparator接口的区别。实现了comparable接口的类，我们就能够本类的内部重写compareTo方法实现大小比较，从而给Collections.sort或Arrays.sort进行排序。而如果一个类没有实现comparable接口也想该类可以排序怎么办，那么就可以创造一个外部比较器去实现comparator接口，重写compare方法。以达到可以给Collections和Arrays使用。\n具体区别参考如下链接：\nComparator和Comparable接口的区别\n\n因为String继承了comparable<String>接口，所以可以重写compareTo(String str)方法,注意参数是String类型的。里面实现的方式不忽略大小写的比较方式。如果我们还需要一个可以忽视大小写的比较方法怎么办？我们可能立马想到的就是重载一个compareTo方法，多对个参数？问题是不行的，工具类只认compareTo(String str)，那么我们此时要怎么办呢？所以只能求救于Comparetor接口。要用Comparetor接口必须创造一个比较器去实现Comparator接口，并重写compare方法。所以就有了String内部就有了实现Comparator接口的静态内部类,这个静态内部类就是一个比较器。(当然这个静态内部类也可以不放进String类里。可以单独作为一个类，可是没有必要，因为这个类也就在String内部使用，所以作为静态内部类即可。)\n\n为什么在忽略大小写比较的时候，通常都会大小写都会比较一次？\n也就是说，通常会同位置的字符会全部转为大写比较一次，又转为小写比较一次？这是为什么，不是转换为大写或小写比较一次既可吗？\n\n同时比较了UpperCase和LowerCase，是为了兼容Georgian字符。\nhttps://www.cnblogs.com/yanyichao/p/4493039.html\n\nString类的CopyValueOf 和ValueOf有什么不同吗？\n目前Java8的源码来看，没有任何区别。\n\n我觉得你最大的疑问应该在char数组上吧？比如\nchar[] test = new char[]{‘a’,‘b’,‘c’};\nString a = String.valueOf(test);\nString b = String.copyValueOf(test);\n有什么区别？答案：没有任何区别！\n首先你得知道，String的底层是由char[]实现的：通过一个char[]类型的value属性！早期的String构造器的实现呢，不会拷贝数组的，直接将参数的char[]数组作为String的value属性。然后\ntest[0] = ‘A’;\n将导致字符串的变化。为了避免这个问题，提供了copyValueOf方法，每次都拷贝成新的字符数组来构造新的String对象。但是现在的String对象，在构造器中就通过拷贝新数组实现了，所以这两个方面在本质上已经没区别了。\n请问String类的CopyValueOf 和ValueOf有什么不同吗？","tags":["Java","源码阅读"]},{"title":"JDK源码阅读系列(一)--Object类","url":"/2017/10/18/JDK源码阅读系列-一-Object类/","content":"\n### 1、Object 方法\n\njava.lang.Object为java所有类的基类，所以一般的类都可用重写或直接使用Object下方法，以下为逻辑结构图:\n\n![object_logic](JDK源码阅读系列-一-Object类/object_logic.png)\n\n**<u>注： 以上绿色方法为 非native方法  粉色方法为 native方法</u>**\n\nObject类中的方法如下：\n\n```java\nObject()：构造方法。 \nregisterNatives()：装载本地库。 \ngetClass()：返回此 Object的运行时类。 \nhashCode()：返回对象的哈希码值。 \nequals(Object)：指示一些其他对象是否等于此。 \nclone()：创建并返回此对象的副本。 \ntoString()：返回对象的字符串表示形式。 \nnotify()：唤醒正在等待对象监视器的单个线程。 \nnotifyAll()：唤醒正在等待对象监视器的所有线程。 \nwait(long)：使当前线程等待，直到另一个线程调用notify()方法或该对象的notifyAll()方法，或指定时间已过。 \nwait(long,int)：使当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法，或指定时间已过。 \nwait()：使当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法。 \nfinalize()：当垃圾收集确定不再有对该对象的引用时，在对象上调用该方法。\n```\n\n### 2、Object()\n\n​\t类构造器是创建Java对象的途径之一。一个类必须要有一个构造器的存在，如果没有显示声明，那么系统会默认创造一个无参构造器。 \n​\t在JDK的Object类源码中，我们可以发现并没有看到构造器的，系统会自动添加一个无参构造器。 \n我们可以通过以下代码构造一个Object类的对象： Object obj = new Object();\n\n### 3、registerNatives()\n\n源码如下： \n\n```java\nprivate static native void registerNatives();\n```\n\n这是一个本地方法。 \n我们接着往下看，可以看到这样一段代码：\n\n```java\nstatic {\n    registerNatives();\n}\n```\n我们知道一个类定义了本地方法后，想要调用操作系统的实现，必须还要装载本地库。上面的这段代码是一个静态代码块，所以在类加载的时候会执行该方法，通过该方法来注册本地方法。\n\n对应的C代码\n\n```c\nstatic JNINativeMethod methods[] = {\n    {\"hashCode\",    \"()I\",                    (void *)&JVM_IHashCode},\n    {\"wait\",        \"(J)V\",                   (void *)&JVM_MonitorWait},\n    {\"notify\",      \"()V\",                    (void *)&JVM_MonitorNotify},\n    {\"notifyAll\",   \"()V\",                    (void *)&JVM_MonitorNotifyAll},\n    {\"clone\",       \"()Ljava/lang/Object;\",   (void *)&JVM_Clone},\n};\n\nJNIEXPORT void JNICALL\nJava_java_lang_Object_registerNatives(JNIEnv *env, jclass cls)\n{\n    (*env)->RegisterNatives(env, cls,\n                            methods, sizeof(methods)/sizeof(methods[0]));\n}\n```\n\n### 3、getClass()\n\n接下来来看该方法的源码： \npublic final native Class<?> getClass();\n\n该方法被声明为public final native方法，这说明该方法无法被重写，且是一个本地方法。 \n通过API文档说明，我们可以知道该方法的作用是返回一个对象的运行时类，通过这个类对象我们可以获取该运行时类的相关属性和方法。\n\n我们知道Java中还可以通过 类名.class 获取这个类的类对象，我们来比较一下这两种用法有什么区别，来加深对这个方法的理解。 \n我们写一个父类： \n\n```java\npublic class Parent {} \n```\n\n再写一个子类： \n\n再写一个子类： \n\n```java\npublic class Son extends Parent {} \n```\n\n再来一段测试代码\n\n再来一段测试代码\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        Parent p = new Son();\n        System.out.println(p.getClass());\n        System.out.println(Parent.class);\n    }\n}\n```\n我们运行一下，输出如下：\n\nclass test.Son\nclass test.Parent\n1\n2\n\n### 4、hashCode()\n\n来看源码： \npublic native int hashCode();\n\n这也是一个用 native 声明的本地方法，作用是返回对象的散列码，是 int 类型的数值。 \n通过刚才查看API文档，我们可以知道hashcode的3个约定： \n1. 在程序运行时期间，只要对象的变化不会影响equals方法的判断结果，那么，在这个期间无论调用多少次hashCode，都必须返回同一个散列码。 \n2. 通过equals调用返回true的2个对象的hashCode一定一样。 \n3. 通过equasl返回false的2个对象的散列码可以一样也可以不一样。\n\n也就是说： \n两个对象相等，其hashCode一定相同; \n两个对象不相等，其hashCode有可能相同; \nhashCode相同的两个对象，不一定相等; \nhashCode不相同的两个对象，一定不相等;\n\n那么这个方法有什么用呢？ \n我们知道在Java 中有几种集合类，其中Set存放的元素是不可重复的。 \n在Set中，每增加一个元素，我们就通过equals方法判断集合中的每一个元素是否重复。如果集合中有10000个元素，我们新加入一个元素时，那就需要进行10000次equals方法的调用，这显然效率很低。 \n于是，Java就采用了哈希表来实现。哈希算法也称为散列算法，是将数据依特定算法产生的结果直接指定到一个地址上。这个结果就是由hashCode方法产生。当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了；不相同的话，也就是发生了Hash key相同导致冲突的情况，那么就在这个Hash key的地方产生一个链表，将所有产生相同HashCode的对象放到这个单链表上去，串在一起。这样一来实际调用equals方法的次数就大大降低了。\n\n那也许我们会想，对于不能重复的集合比如Set，为什么不让hashCode对于每个元素都产生唯一的值，相等的元素就产生一样的hashcode，不一样的元素就产生不一样的hashcode，这样不就完全不需要调用equals方法来判断是否相同了吗？ \n实际上对于元素不是很多的情况下，直接通过hashCode产生唯一的索引值，通过这个索引值能直接找到元素，而且还能判断是否相同，这很好。就像数据库存储的数据的主键或者是rowid一样，我们能通过主键或者rowid直接找到某个元素。但实际上，很难实现hashCode的唯一算法，就算能实现，产生的hashCode码也是非常大的，这会大的超过int所能表示的范围，很占内存空间。\n\n所以，我们在编写hashcode方法时要注意以下几点： \n- 不同对象的hash码应该尽量不同，避免hash冲突，也就是算法获得的元素要尽量均匀分布。 \n- hash 值是int 类型，在Java中占用4个字节，也就是2的32次方，不要溢出。 \n- 对于Map集合，我们可以选取Java中的基本类型，以及String作为 key，因为它们都按照规范重写了equals方法和hashCode方法。但是如果你用自定义对象作为key，那么一定要重写 equals方法和hashCode方法。\n\n像Integer类，String类等都重写了hashCode方法，我们自定义对象的hashCode方法可以参考这些类来写。\n\n### 5、equals(Object)\n\n方法源码如下：\n\n```java\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n\n看了源码我们知道，在Object类中，==运算符和equals方法是等价的，都是比较两个对象的引用是否相等。对于我们自定义的一个对象，如果不重写equals方法，那么在比较对象的时候就是调用Object类的equals方法，也就是用==运算符比较两个对象。\n\n这里我们看一下String类中重写equals方法的源码：\n\n```java\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n可以看到，String类定义两个对象相等的标准是字符串内容都相同，而不是引用是否相等。\n\n假如我们有一个自定义的Parent类，里面有两个属性，我们自定义两个对象相等的标尺为Parent对象的两个属性都相等，则对象相等，否则不相等。 \n那么我们来仿照上面String对equals的重写，我们来重写一下Parent的equals方法：\n\n```java\npublic class Parent {\n    private String name;\n\n    private String age;\n\n    public Parent() {\n    }\n\n    public Parent(String name, String age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAge() {\n        return age;\n    }\n\n    public void setAge(String age) {\n        this.age = age;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        // 引用相等那么两个对象当然相等\n        if (this == obj) {\n            return true;\n        }\n        // 对象为空则不相等\n        if (obj == null) {\n            return false;\n        }\n        // 对象不是Parent类的实例则不相等\n        if (!(obj instanceof Parent)) {\n            return false;\n        }\n        Parent otherParent = (Parent) obj;\n        if (otherParent.getName().equals(this.getName()) \n            && otherParent.getAge() == this.getAge()) {\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n\n\n然后写一个测试方法：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        Parent p1 = new Parent(\"Alice\", \"20\");\n        Parent p2 = new Parent(\"Tom\", \"21\");\n        Parent p3 = new Parent(\"Alice\", \"20\");\n        System.out.println(p1.equals(p2));\n        System.out.println(p1.equals(p3));\n    }\n}\n```\n\n\n看到上面的测试main方法输出，第一个是false，第二个是true，我们觉得这个equals实现的好像没什么问题。 \n如果我们有个Son类继承了Parent类，Son类也同样重写了equals方法，Son类如下：\n\n```java\npublic class Son extends Parent {\n    private String idNo;\n\n    private String score;\n\n    public Son() {\n    }\n\n    public Son(String name, String age, String idNo, String score) {\n        super(name, age);\n        this.idNo = idNo;\n        this.score = score;\n    }\n\n    public String getIdNo() {\n        return idNo;\n    }\n\n    public void setIdNo(String idNo) {\n        this.idNo = idNo;\n    }\n\n    public String getScore() {\n        return score;\n    }\n\n    public void setScore(String score) {\n        this.score = score;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        // 引用相等那么两个对象当然相等\n        if (this == obj) {\n            return true;\n        }\n        // 对象为空则不相等\n        if (obj == null) {\n            return false;\n        }\n        // 对象不是Son类的实例则不相等\n        if (!(obj instanceof Son)) {\n            return false;\n        }\n        Son otherSon = (Son) obj;\n        if (otherSon.getIdNo().equals(this.getIdNo()) \n            && otherSon.getScore() == this.getScore()) {\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n这时候我们再来写一个测试方法：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        Parent p = new Parent(\"Alice\", \"20\");\n        Son s = new Son(\"Alice\", \"20\", \"001\", \"95\");\n        System.out.println(p.equals(s));\n        System.out.println(s.equals(p));\n    }\n}\n```\n\n\n我们看到第一个输出为true，第二个输出竟然是false！这明显违反了我们上面说的equals的几个约定中的对称性。 \n细看一下我们发现，问题出现在 instanceof 关键字上，Son是Parent的子类，所以Son instanceof Parent当然是true，但是Parent instanceof Son就自然是false了。 \n所以，instanceof是做不到对称性的要求的，我们可以使用getClass()方法来代替instanceof运算符，把上面Parent类中使用instanceof的地方改为以下代码：\n\n```java\nif (getClass() != obj.getClass()) {\n    return false;\n}\n```\n\n\n再次运行测试方法，可以看到输出都是false，满足对称性。\n\n再次运行测试方法，可以看到输出都是false，满足对称性。\n\n但是我们也要注意，也不是什么时候都要使用getClass，毕竟自定义对象是否相等的标准是由自己定义的。而且使用getClass不符合多态的设计思想。比如一个父类有两个子类,子类中没有自定义相等的概念，也就是说没有重写equals，如果使用getClass实现父类equals方法的重写，那么就不能在两个不同子类的对象进行相等的比较。 \n所以，如果子类能够拥有自己的相等概念，则根据对称性需求，我们需要采用getClass()；如果由父类决定相等的概念，那么就可以使用instanceof，这样可以在不同的子类的对象之间进行相等的比较。\n\n下面给出重写equals方法的最佳实践： \n1. 参数命名为otherObject，稍后会将它转换成另一个叫做other的变量。 \n2. 用==判断比较的两个对象引用是否相等，如果引用相等那么表示是同一个对象，那么当然相等。 \n3. 如果otherObject为null，直接返回false。 \n4. 比较this和otherObject是否是同一个类：如果equals的语义在每个子类中有所改变，就使用getClass()判断；如果所有的子类都有统一的定义，那么使用instanceof判断。 \n5. 将otherObject转换成对应类的变量。 \n6. 最后对对象的属性进行比较。使用==比较基本类型，使用equals比较对象。如果都相等则返回true，否则返回false。注意如果是在子类中定义equals，则要包含 super.equals(other)。\n\n那么根据刚才的最佳实践，我们来重新写一下上面的Parent类的equals方法：\n\n```java\n@Override\npublic boolean equals(Object otherObject) {\n    // 用==判断比较的两个对象引用是否相等，如果引用相等那么表示是同一个对象，那么当然相等。\n    if (this == otherObject) {\n        return true;\n    }\n    // 如果otherObject为null，直接返回false。\n    if (otherObject == null) {\n        return false;\n    }\n    // 比较this和otherObject是否是同一个类\n    // 以下两种写法二选一\n    // 如果equals的语义在每个子类中有所改变，就使用getClass()判断\n    if (getClass() != otherObject.getClass()) {\n        return false;\n    }\n\n    // 如果所有的子类都有统一的定义，那么使用instanceof判断\n    if (!(otherObject instanceof Parent)) {\n        return false;\n    }\n\n    // 将otherObject转换成对应类的变量。\n    Parent otherParent = (Parent) otherObject;\n\n    // 最后对对象的属性进行比较。使用==比较基本类型，使用equals比较对象。如果都相等则返回true，否则返回false。\n    if (otherParent.getName().equals(this.getName()) \n        && otherParent.getAge() == this.getAge()) {\n        return true;\n    }\n    return false;\n}\n```\n\n最后再提醒一下不要忘记，API中的最后有一句话，一般来说重写equals方法，就要重写hashCode方法，以便保持hashCode方法的通用约定，即相等的对象必须具有相等的hashcode。\n\n### 6、clone()\n\n该方法源码如下： \nprotected native Object clone() throws CloneNotSupportedException;\n\n其实文档讲的还是蛮清楚的，我们再次强调一下，clone()的正确调用是需要实现Cloneable接口，如果没有实现Cloneable接口，子类直接调用Object类的clone()方法，则会抛出CloneNotSupportedException异常。 \n来看一下Cloneable的源码：\n\n```java\npublic interface Cloneable {\n}\n```\n\n\n可以发现，Cloneable接口仅是一个表示接口，它本身不包含任何方法，用来指示Object.clone()可以合法的被子类所调用。\n\n使用clone方法的优点是速度快，而且灵活。速度快是因为clone方法最终会调用Object.clone()方法，这是一个native方法，本质是内存块复制，所以在速度上比使用new创建对象要快。灵活是因为可以在运行时动态的获取对象的类型以及状态，从而创建一个对象。\n\n但是clone创建对象的缺点也很明显：实现深拷贝较为困难，需要整个类继承的所有类以及所有的属性都很好的实现clone方法。另外就是需要处理CloneNotSupportedException异常。\n\n因此，我们如果想使用clone方法的话，需要非常谨慎。事实上，更建议的不是实现Cloneable接口，而是编写拷贝构造器。\n\n### 7、toString()\n\n该方法源码如下：\n\n```java\npublic String toString() {\n    return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n}\n```\n\n打印某个对象时，默认是调用toString方法。不过从源码我们可以看到，默认的toString返回的内容可读性并不好，所以通常都要重写toString，输出需要的实例信息，比如某些属性的值。\n\n### 8、notify()\n\n该方法源码如下： \npublic final native void notify(); \n这个方法是用于多线程操作的，我们先来看一下同样也是用于多线程的另外几个方法。\n\n### 9、notifyAll()\n\n通过查看API，我们知道这个notifyAll()和刚才的notify()差不多，只是notify()是随机唤醒一个等待的线程，而notifyAll()是唤醒正在等待对象监视器的所有线程。\n\n该方法源码如下： \n\n```java\npublic final native void notifyAll();\n```\n\n### 10、wait(long)\n\n方法源码如下： \n\n```java\npublic final native void wait(long timeout) throws InterruptedException;\n```\n\n### 11、wait(long, int)\n\n再来看一下源码：\n\n```java\npublic final void wait(long timeout, int nanos) throws InterruptedException {\n    if (timeout < 0) {\n        throw new IllegalArgumentException(\"timeout value is negative\");\n    }\n\n    if (nanos < 0 || nanos > 999999) {\n        throw new IllegalArgumentException(\n                            \"nanosecond timeout value out of range\");\n    }\n\n    if (nanos > 0) {\n        timeout++;\n    }\n\n    wait(timeout);\n}\n```\n\n\n### 12、wait()\n\n源码如下：\n\n```java\npublic final void wait() throws InterruptedException {\n    wait(0);\n}\n```\n\n以上这几个方法，notify，notifyAll，wait，都是public final native的，不可以被子类重写，且都是本地方法。这几个方法提供了java线程间等待、挂起等协同机制，是java多线程的基础。这里我们就先大致看一下源码，等后面研究到多线程的时候再来仔细解读它们。\n\n### 13、finalize()\n\n源码如下： \n\n```java\nprotected void finalize() throws Throwable { }\n```\n\n​\t该方法用于垃圾回收，一般由 JVM 自动调用，一般不需要程序员去手动调用该方法。这里我们就只是先看一下API怎么讲，后面细究 JVM 的时候再详细描述。\n\n---------------------\n\n\n\n\n\n","tags":["Java","源码阅读"]},{"title":"Java位运算","url":"/2017/08/03/Java位运算/","content":"\n### 一、 相关基础概念\n\n在开始java位运算的知识之前，我们先来了解几个基础的概念，机器数，真值，原码，反码，补码。\n\n#### 1.机器数\n\n​\t\t我们知道无论是代码还是数值，在计算机中最后都转换成以二进制的形式存在的，而一个数值在计算机中的二进制表示形式，就是这个数的机器数。机器数是有符号位的，在计算机中用一个二进制数的最高位存放符号，正数为0，负数为1，如下实例（按原码表示）：\n\n十进制的＋5，计算机字长为8位，其二进制就是00000101\n\n十进制的 －5，计算机字长为8位，其二进制就是10000101(这里用的是原码)\n\n其中00000101和10000101就是机器数\n\n#### 2.真值\n\n​\t\t由于机器数的第一位是符号位，所以其形式值就不等于其真值的数值，也就是说10000101表示的是－5而不是133（10000101的十进制是131，前提是不算最高位为符号位），因此－5才是机器数的真值。\n\n#### 3.原码\n\n​\t\t原码是一种计算机中对数字的二进制定点表示方法。原码表示法在数值前面增加了一位符号位（即最高位为符号位）：正数该位为0，负数该位为1，其余位表示数值的大小。\n\n［＋5］=[00000101]（原码）\n\n［ -  5］=[10000101]（原码）\n\n因为第一位是符号位，因此8位二进制的取值范围就是［1111 1111，0111 1111］也就是［-127,127］\n\n#### 4.反码\n\n​\t\t反码是数值存储的一种，但是由于补码更能有效表现数字在计算机中的形式，所以多数计算机一般都不采用反码表示数，反码的表示方法如下:\n\n正数的反码是其本身\n\n负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.\n\n［＋5］=[00000101]（原码）＝ ［00000101］（反码）\n\n［ -  5］=[10000101]（原码）＝ ［11111010］（反码）\n\n#### 5.补码\n\n​\t\t在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。补码的表示方法是:\n\n正数的补码就是其本身\n\n负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)\n\n［＋5］=[00000101]（原码）＝ ［00000101］（反码）＝［00000101］（补码）\n\n［ -  5］=[10000101]（原码）＝ ［11111010］（反码）＝［11111011］（补码）\n\n#### 6.小结\n\n​\t\t计算机中的符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。而在计算机系统中，数值一律用补码来表示和存储。\n\n### 二、 Java位运算\n\n位移操作：(只针对 int类型的数据有效，java中，一个int的长度始终是32位，也就是4个字节,它操作的都是该整数的二进制数).也可作用于以下类型，即 byte，short，char，long(它们都是整数形式)。当为这四种类型时，JVM先把它们转换成int型再进行操作。\n\n#### 7.左移（<<）\n\nm<<n的含义:把整数m表示的二进制数左移n位,高位移出n位都舍弃，低位补0.  (此时将会出现正数变成负数的可能)，如下实例：\n\n5<<2 ：把十进制的数值5左移两位,按如下步骤计算，\n\n把5转位16位的二进制机器数：00000000 00000000 00000000 00000101\n\n按左移原理，将二进制数左移两位：00000000 00000000 00000000 00010100\n\n左移后结果为20\n\n5<<29:把十进制的数值5左移29位,按如下步骤计算，\n\n把5转位16位的二进制机器数：00000000 00000000 00000000 00000101\n\n按左移原理，将二进制数左移29位：10100000 00000000 00000000  00000000\n\n左移后高位是1，结果显然是负数\n\n小结：m<<n即在数字没有溢出的前提下，对于正数和负数，左移n位都相当于m乘以2的n次方.\n\n#### 8.右移（>>）\n\n m>>n的含义:把整数m表示的二进制数右移n位,m为正数，高位全部补0；m为负数，高位全部补1,实例如下：\n\n5>>2 ：把十进制的数值5右移两位,按如下步骤计算，\n\n把5转位16位的二进制机器数：00000000 00000000 00000000 00000101\n\n按右移原理，将二进制数左移两位：00000000 00000000 00000000 00000001\n\n右移后结果为1\n\n-5>>2：把十进制的数值-5右移两位,按如下步骤计算，\n\n把-5转位16位的二进制机器数：11111111 11111111 11111111 11111011\n\n按右移原理，将二进制数右移两位：11111111 11111111 11111111 11111110\n\n右移后结果为-2\n\n小结：\n\n m>>n即相当于m除以2的n次方，得到的为整数时，即为结果。如果结果为小数，此时会出现两种情况：\n\n如果m为正数，得到的商会无条件 的舍弃小数位；\n\n如果m为负数，舍弃小数部分，然后把整数部分加+1得到位移后的值。\n\n#### 9.无符号右移（>>>）\n\nm>>>n：整数m表示的二进制右移n位，不论正负数，高位都补0,实例如下：\n\n5>>>2 ：把十进制的数值5右移两位,按如下步骤计算，\n\n把5转位16位的二进制机器数：00000000 00000000 00000000 00000101\n\n按右移原理，将二进制数左移两位：00000000 00000000 00000000 00000001\n\n右移后结果为1\n\n-5>>>2：把十进制的数值-5右移两位,按如下步骤计算，\n\n把-5转位16位的二进制机器数：11111111 11111111 11111111 11111011\n\n按右移原理，将二进制数右移两位：00111111 11111111 11111111 11111110\n\n右移后结果为正数\n\n#### 10.按位非操作（～）\n\n~ 按位取反操作符，对每个二进制位的内容求反，即1变成0，0变成1实例如下\n\n把-5转位16位的二进制机器数：11111111 11111111 11111111 11111011\n\n～(-5) 取反结果：00000000 00000000 00000000 00000100 \n\n转为十进制，结果为4\n\n#### 11.按位与操作（&）\n\n& 位与操作符，对应的二进制位进行与操作，两个都为1才为1，其他情况均为0，原理如下:\n\n1&0=0\n\n0&0=0\n\n1&1=1\n\n0&1=0\n\n实例：－5 & 4\n\n-5的二进制形式为： 11111111 11111111 11111111 11111011\n\n 4的二进制形式为：  00000000 00000000 00000000 00000100\n\n——————————————————————————————\n\n逻辑与运算结果：     00000000 00000000 00000000 00000000\n\n最终结果为0。\n\n#### 12.按位或操作（｜）\n\n| 位或操作符，对应的二进制位进行或操作，两个都为0才为0，其他情况均为1，原理如下：\n\n1|0=1\n\n0|0=0\n\n1|1=1\n\n0|1=1\n\n实例：-5 ｜ 4\n\n -5的二进制形式为：11111111 11111111 11111111 11111011\n\n  4的二进制形式为：00000000 00000000 00000000 00000100\n\n————————————————————————————\n\n逻辑或运算结果：    11111111 11111111 11111111 11111111\n\n最终结果为-1。\n\n利用或的原理我们可以把字节转换为整数，-64&0xFF=192，其中0xFF表示整数255。\n\n#### 13.按位异或操作（ ^ ）\n\n^ 异或操作符，相同位值为0 否则为1，原理如下：\n\n1^1=0\n\n1^0=1\n\n0^1=1\n\n0^0=0\n\n实例：-5 ^  4\n\n -5的二进制形式为：11111111 11111111 11111111 11111011\n\n  4的二进制形式为：00000000 00000000 00000000 00000100\n\n————————————————————————————\n\n逻辑异或运算结果：    11111111 11111111 11111111 11111111\n\n最终结果为-1。\n\n其实利用逻辑异或操作有个作用就是可以比较两个数值是否相等，即利用1^1=0,0^0=0的原理，如5^5==0。\n\n#### 14.总结\n\n​\t\t通过上面的分析，我们对java的位运算也算有了比较全面的了解，那么我们的程序通过位运算又有什么优势呢？其实通过位运算确实会比我们直接的程序代码运算会快很多，因为位运算直接运算的是计算机底层的二进制机器操作指令，而我们的程序代码运算最终也是要转成计算机可识别的二进制操作指令才能执行，位运算可以理解为省了中间转换的操作，处理器可以直接操作。事实是我们在某些源码经常能看见如下代码：\n\n```java\npublic static final int OP_CONNECT = 1 << 3;\npublic static final int OP_ACCEPT = 1 << 4;\n```\n\n","tags":["java"]}]