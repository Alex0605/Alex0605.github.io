[{"title":"Android知识(四)--图片信息之ExifInterface","url":"/2018/03/01/Android知识-四-图片信息之ExifInterface/","content":"\n### 1、Exif-ExifInterface简介 \n\n​\tExif是一种图像文件格式，它的数据存储与JPEG格式是完全相同的。实际上Exif格式就是在JPEG格式头部插入了数码照片的信息，包括拍摄时的光圈、快门、白平衡、ISO、焦距、日期时间等各种和拍摄条件以及相机品牌、型号、色彩编码、拍摄时录制的声音以及GPS全球定位系统数据、缩略图等。你可以利用任何可以查看JPEG文件的看图软件浏览Exif格式的照片，但并不是所有的图形程序都能处理Exif信息。今天这篇文章就来讲讲Android中操作Exif。\n\n### 2、ExifInterface中的功能简单进行介绍 \n\n​\tAndroid开发中，在对图片进行展示、编辑、发送等操作时经常会涉及Exif的操作，Android中操作Exif主要是通过ExifInterface，ExifInterface看上去是一个接口，其实是一个类，位于Android.media.ExifInterface的位置。进入ExifInterface类，发现方法很少，主要就是三个方面：读取、写入、缩略图。\n\n### 3、ExifInterface进行读取操作\n\n​\tExif信息在文件头中是以二进制的形式存储的，存储的字段名称和字段值格式都是固定的。我测试的Android23（6.0）版本中，总共有26个Exif字段，其中TAG_SUBSECTIME被加上了@hide注解，也就是还剩25个，我写了个demo，获取这25个字段的值，看看都是什么样的格式。\n\n```java\nExifInterface exifInterface = new ExifInterface(filePath);\n\nString orientation = exifInterface.getAttribute(ExifInterface.TAG_ORIENTATION);\nString dateTime = exifInterface.getAttribute(ExifInterface.TAG_DATETIME);\nString make = exifInterface.getAttribute(ExifInterface.TAG_MAKE);\nString model = exifInterface.getAttribute(ExifInterface.TAG_MODEL);\nString flash = exifInterface.getAttribute(ExifInterface.TAG_FLASH);\nString imageLength = exifInterface.getAttribute(ExifInterface.TAG_IMAGE_LENGTH);\nString imageWidth = exifInterface.getAttribute(ExifInterface.TAG_IMAGE_WIDTH);\nString latitude = exifInterface.getAttribute(ExifInterface.TAG_GPS_LATITUDE);\nString longitude = exifInterface.getAttribute(ExifInterface.TAG_GPS_LONGITUDE);\nString latitudeRef = exifInterface.getAttribute(ExifInterface.TAG_GPS_LATITUDE_REF);\nString longitudeRef = exifInterface.getAttribute(ExifInterface.TAG_GPS_LONGITUDE_REF);\nString exposureTime = exifInterface.getAttribute(ExifInterface.TAG_EXPOSURE_TIME);\nString aperture = exifInterface.getAttribute(ExifInterface.TAG_APERTURE);\nString isoSpeedRatings = exifInterface.getAttribute(ExifInterface.TAG_ISO);\nString dateTimeDigitized = exifInterface.getAttribute(ExifInterface.TAG_DATETIME_DIGITIZED);\nString subSecTime = exifInterface.getAttribute(ExifInterface.TAG_SUBSEC_TIME);\nString subSecTimeOrig = exifInterface.getAttribute(ExifInterface.TAG_SUBSEC_TIME_ORIG);\nString subSecTimeDig = exifInterface.getAttribute(ExifInterface.TAG_SUBSEC_TIME_DIG);\nString altitude = exifInterface.getAttribute(ExifInterface.TAG_GPS_ALTITUDE);\nString altitudeRef = exifInterface.getAttribute(ExifInterface.TAG_GPS_ALTITUDE_REF);\nString gpsTimeStamp = exifInterface.getAttribute(ExifInterface.TAG_GPS_TIMESTAMP);\nString gpsDateStamp = exifInterface.getAttribute(ExifInterface.TAG_GPS_DATESTAMP);\nString whiteBalance = exifInterface.getAttribute(ExifInterface.TAG_WHITE_BALANCE);\nString focalLength = exifInterface.getAttribute(ExifInterface.TAG_FOCAL_LENGTH);\nString processingMethod = exifInterface.getAttribute(ExifInterface.TAG_GPS_PROCESSING_METHOD);\n\nLog.e(\"TAG\", \"## orientation=\" + orientation);\nLog.e(\"TAG\", \"## dateTime=\" + dateTime);\nLog.e(\"TAG\", \"## make=\" + make);\nLog.e(\"TAG\", \"## model=\" + model);\nLog.e(\"TAG\", \"## flash=\" + flash);\nLog.e(\"TAG\", \"## imageLength=\" + imageLength);\nLog.e(\"TAG\", \"## imageWidth=\" + imageWidth);\nLog.e(\"TAG\", \"## latitude=\" + latitude);\nLog.e(\"TAG\", \"## longitude=\" + longitude);\nLog.e(\"TAG\", \"## latitudeRef=\" + latitudeRef);\nLog.e(\"TAG\", \"## longitudeRef=\" + longitudeRef);\nLog.e(\"TAG\", \"## exposureTime=\" + exposureTime);\nLog.e(\"TAG\", \"## aperture=\" + aperture);\nLog.e(\"TAG\", \"## isoSpeedRatings=\" + isoSpeedRatings);\nLog.e(\"TAG\", \"## dateTimeDigitized=\" + dateTimeDigitized);\nLog.e(\"TAG\", \"## subSecTime=\" + subSecTime);\nLog.e(\"TAG\", \"## subSecTimeOrig=\" + subSecTimeOrig);\nLog.e(\"TAG\", \"## subSecTimeDig=\" + subSecTimeDig);\nLog.e(\"TAG\", \"## altitude=\" + altitude);\nLog.e(\"TAG\", \"## altitudeRef=\" + altitudeRef);\nLog.e(\"TAG\", \"## gpsTimeStamp=\" + gpsTimeStamp);\nLog.e(\"TAG\", \"## gpsDateStamp=\" + gpsDateStamp);\nLog.e(\"TAG\", \"## whiteBalance=\" + whiteBalance);\nLog.e(\"TAG\", \"## focalLength=\" + focalLength);\nLog.e(\"TAG\", \"## processingMethod=\" + processingMethod);\n```\n\n打印的结果\n\n```java\nE/TAG: ## orientation=0\nE/TAG: ## dateTime=2016:05:23 17:30:11\nE/TAG: ## make=Xiaomi\nE/TAG: ## model=Mi-4c\nE/TAG: ## flash=16\nE/TAG: ## imageLength=4160\nE/TAG: ## imageWidth=3120\nE/TAG: ## latitude=31/1,58/1,253560/10000\nE/TAG: ## longitude=118/1,44/1,491207/10000\nE/TAG: ## latitudeRef=N\nE/TAG: ## longitudeRef=E\nE/TAG: ## exposureTime=0.050\nE/TAG: ## aperture=2.0\nE/TAG: ## iso=636\nE/TAG: ## dateTimeDigitized=2016:05:23 17:30:11\nE/TAG: ## subSecTime=379693\nE/TAG: ## subSecTimeOrig=379693\nE/TAG: ## subSecTimeDig=379693\nE/TAG: ## altitude=0/1000\nE/TAG: ## altitudeRef=0\nE/TAG: ## gpsTimeStamp=9:30:8\nE/TAG: ## gpsDateStamp=2016:05:23\nE/TAG: ## whiteBalance=0\nE/TAG: ## focalLength=412/100\nE/TAG: ## processingMethod=NETWORK\n```\n\n这25个字段分别是代表什么呢？\n\n```java\nExifInterface.TAG_ORIENTATION //旋转角度，整形表示，在ExifInterface中有常量对应表示\nExifInterface.TAG_DATETIME //拍摄时间，取决于设备设置的时间\nExifInterface.TAG_MAKE //设备品牌\nExifInterface.TAG_MODEL //设备型号，整形表示，在ExifInterface中有常量对应表示\nExifInterface.TAG_FLASH //闪光灯\nExifInterface.TAG_IMAGE_LENGTH //图片高度\nExifInterface.TAG_IMAGE_WIDTH //图片宽度\nExifInterface.TAG_GPS_LATITUDE //纬度\nExifInterface.TAG_GPS_LONGITUDE //经度\nExifInterface.TAG_GPS_LATITUDE_REF //纬度名（N or S）\nExifInterface.TAG_GPS_LONGITUDE_REF //经度名（E or W）\nExifInterface.TAG_EXPOSURE_TIME //曝光时间\nExifInterface.TAG_APERTURE //光圈值\nExifInterface.TAG_ISO //ISO感光度\nExifInterface.TAG_DATETIME_DIGITIZED //数字化时间\nExifInterface.TAG_SUBSEC_TIME //\nExifInterface.TAG_SUBSEC_TIME_ORIG //\nExifInterface.TAG_SUBSEC_TIME_DIG //\nExifInterface.TAG_GPS_ALTITUDE //海拔高度\nExifInterface.TAG_GPS_ALTITUDE_REF //海拔高度\nExifInterface.TAG_GPS_TIMESTAMP //时间戳\nExifInterface.TAG_GPS_DATESTAMP //日期戳\nExifInterface.TAG_WHITE_BALANCE //白平衡\nExifInterface.TAG_FOCAL_LENGTH //焦距\nExifInterface.TAG_GPS_PROCESSING_METHOD //用于定位查找的全球定位系统处理方法。\n```\n\n其中TAG_SUBSEC_TIME 、TAG_SUBSEC_TIME_ORIG 、TAG_SUBSEC_TIME_DIG 没有加注释，我也没查清楚具体是什么意思，但是看log，三个值是一样的。有知道的朋友可以跟我说下，谢谢！\n\n细心的朋友会发现，上面所有的取值都是用的一个方法：exifInterface.getAttribute(String tag)，其实ExifInterface还提供了其它方法。\n\n```java\nexifInterface.getAltitude(long default); //返回海拔高度，单位米，如果exif的tag不存在，返回默认值。 \nexifInterface.getAttributeDouble(String tag, Double default) //返回double值，传入默认值 \nexifInterface.getAttributeInt(String tag, int default) //返回int值，传入默认值 \nexifInterface.getLatLong(float[] value) //返回纬度和经度，数组第一个是纬度，第二个是经度\n```\n\n### 4、ExifInterface进行写入操作\n\n相对读取，写入就简单很多了。\n\n```java\nExifInterface exifInterface = new ExifInterface(filePath);\nexifInterface.setAttribute(ExifInterface.TAG_GPS_ALTITUDE,\"1/1000\");\nexifInterface.setAttribute(ExifInterface.TAG_ORIENTATION,\"6\");\nexifInterface.setAttribute(ExifInterface.TAG_IMAGE_WIDTH,\"2000\");\nexifInterface.saveAttributes();\n```\n\n代码很简答，但有一点需要说下，setAttributes只是设置属性值，没有保存，saveAttributes才真正保存，但是这个方法比较耗时，不要每set一次都save，全部set完后，再统一save一次。 \n\n有一点很尴尬，saveAttributes()这个方法内部会遍历保存所有的值，哪怕你只改变了其中一个值。\n\n### 5、ExifInterface获取缩略图\n\ngetThumbnail()这个方法可以生成一个缩略图，返回一个字节数组，得到字节数组就可以轻松生成Bitmap。\n\n但是在调用这个方法前，最好先调用exifInterface.hasThumbnail()判断一下是否有缩略图。\n\ngetThumbnail()这个方法调用的是native方法，所以具体的实现就看不到了，我也不知道生成的缩略图的分辨率是多少。到这里，ExifInterface的使用介绍以及完毕。\n\n### 6、在ExifInterface获取的信息中进行添加到图片\n\n#### 步骤一\n\n我们在布局文件中activity_main.xml中的代码，创建一个控件\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:id=\"@+id/activity_main\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n\ttools:context=\"com.yoyoyt.exifinterfacedemo.MainActivity\">\n    <ImageView\n        android:id=\"@+id/imageview\"\n        android:layout_width=\"500dp\"\n        android:layout_height=\"300dp\"/>\n</RelativeLayout>\n```\n#### 步骤二\n\n我们在MainActivity中找的控制，并获取信息，将信息添加到图片上面。并显示在控件上，具体代码如下：\n\n```java\npackage com.zalex.exifinterfacedemo;\n\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.Rect;\nimport android.graphics.Typeface;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.ExifInterface;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.support.v7.app.AppCompatActivity;\nimport android.util.Log;\nimport android.widget.ImageView;\nimport android.widget.Toast;\n\npublic class MainActivity extends AppCompatActivity {\n   \n        //获取加载图片的路径\nString path = Environment.getExternalStorageDirectory().getPath() + \"/DCIM/Camera/IMG_20160927_135402.jpg\";\nprivate String width;\nprivate String height;\nprivate Bitmap bitmap;\nprivate Bitmap imgTemp;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    //找到控件的id\n    ImageView iv= (ImageView) findViewById(R.id.imageview);\n    bitmap = BitmapFactory.decodeFile(path);//        iv.setImageBitmap(bitmap);\n         //android读取图片EXIF信息\n    try {\n        ExifInterface exifInterface=new ExifInterface(path);\n      //         执行保存\n            exifInterface.saveAttributes();\n            //获取图片的方向\n            String orientation = exifInterface.getAttribute(ExifInterface.TAG_ORIENTATION);\n            //获取图片的时间\n            String dateTime = exifInterface.getAttribute(ExifInterface.TAG_DATETIME);\n            String make = exifInterface.getAttribute(ExifInterface.TAG_MAKE);\n            String model = exifInterface.getAttribute(ExifInterface.TAG_MODEL);\n            String flash = exifInterface.getAttribute(ExifInterface.TAG_FLASH);\n             height = exifInterface.getAttribute(ExifInterface.TAG_IMAGE_LENGTH);\n             width = exifInterface.getAttribute(ExifInterface.TAG_IMAGE_WIDTH);\n            String latitude = exifInterface.getAttribute(ExifInterface.TAG_GPS_LATITUDE);\n            String longitude = exifInterface.getAttribute(ExifInterface.TAG_GPS_LONGITUDE);\n        StringBuilder sb = new StringBuilder();\n        sb.append(longitude)\n                .append(latitude);\n\n        Log.e(\"TAG\", \"## orientation=\" + orientation);\n        Log.e(\"TAG\", \"## dateTime=\" + dateTime);\n        Log.e(\"TAG\", \"## make=\" + make);\n        Log.e(\"TAG\", \"## model=\" + model);\n        Log.e(\"TAG\", \"## flash=\" + flash);\n        Log.e(\"TAG\", \"## imageLength=\" + height);\n        Log.e(\"TAG\", \"## imageWidth=\" + width);\n        Log.e(\"TAG\", \"## latitude=\" + latitude);\n        Log.e(\"TAG\", \"## longitude=\" + longitude);\n        String driving_name=\"驾校名称:东方时尚驾校\";\n        String coach=\"教练员姓名:张三\";\n        String lerner=\"学员姓名:李四\";\n        String time=\"采集时间:2016\";\n        String car_number=\"车牌号:京RF8900786\";\n        String longt=\"102.00\";\n        String lat=\"35.5\";\n        String car_speed=\"车辆行驶速度:20km/h\";\n\n        Toast.makeText(MainActivity.this,sb, Toast.LENGTH_LONG).show();\n        Drawable drawable = createDrawable(driving_name,coach,lerner,time,car_number,longt,lat,car_speed);\n        iv.setBackgroundDrawable(drawable);\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n}\n\n// 穿件带字母的标记图片\nprivate Drawable createDrawable(String driving_name, String coach, String lerner, String time, String car_number, String longt, String lat, String car_speed) {\n    imgTemp = Bitmap.createBitmap(Integer.valueOf(width), Integer.valueOf(height), Bitmap.Config.ARGB_8888);\n    Canvas canvas = new Canvas(imgTemp);\n    Paint paint = new Paint(); // 建立画笔\n    paint.setDither(true);\n    paint.setFilterBitmap(true);\n    Rect src = new Rect(0, 0,Integer.valueOf(width), Integer.valueOf(height));\n    Rect dst = new Rect(0, 0, Integer.valueOf(width), Integer.valueOf(height));\n    canvas.drawBitmap(bitmap, src, dst, paint);\n\n    Paint textPaint = new Paint(Paint.ANTI_ALIAS_FLAG\n            | Paint.DEV_KERN_TEXT_FLAG);\n    textPaint.setTextSize(100.0f);\n    textPaint.setTypeface(Typeface.DEFAULT_BOLD); // 采用默认的宽度\n    textPaint.setColor(Color.WHITE);\n\n    canvas.drawText(driving_name,Integer.valueOf(width)/100, Integer.valueOf(height)/8,\n            textPaint);\n    canvas.drawText(coach,0, (Integer.valueOf(height)/8)+100,textPaint);\n    canvas.drawText(lerner,0,(Integer.valueOf(height)/8)+200,textPaint);\n    canvas.drawText(time,0,(Integer.valueOf(height)/8)+300,textPaint);\n    canvas.drawText(car_number,0,(Integer.valueOf(height)/8)+400,textPaint);\n    canvas.drawText(longt,0,(Integer.valueOf(height)/8)+500,textPaint);\n    canvas.drawText(lat,0,(Integer.valueOf(height)/8)+600,textPaint);\n    canvas.drawText(car_speed,0,(Integer.valueOf(height)/8)+700,textPaint);\n    canvas.save(Canvas.ALL_SAVE_FLAG);\n    canvas.restore();\n\n    return (Drawable) new BitmapDrawable(getResources(), imgTemp);\n\n}\n}\n```\n\n#### 步骤三\n\n最后，我们在配置文件中进行添加权限\n\n```xml\n <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/>\n <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"/>\n <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n```\n\n","tags":["Android"]},{"title":"Android知识(三)--RecyclerView深入解析","url":"/2018/02/27/Android知识-三-RecyclerView深入解析/","content":"\n1、简介\n\n​\t本文将从RecyclerView实现原理并结合源码详细分析这个强大的控件\n\n2、基本使用\n\n​\tRecyclerView的基本使用并不复杂，只需要提供一个RecyclerView.Apdater的实现用于处理数据集与ItemView的绑定关系，和一个RecyclerView.LayoutManager的实现用于测量并布局ItemView。\n\n3、绘制流程\n\n​\t众所周知，android控件的绘制可以分为3个步骤：[measure、layout、draw](https://alex0605.github.io/2018/02/25/Android%E7%9F%A5%E8%AF%86-%E4%BA%8C-View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/)。RecyclerView的绘制自然也经这3个步骤。但是，RecyclerView将它的measure与layout过程委托给了RecyclerView.LayoutManager来处理，并且，它对子控件的measure及layout过程是逐个处理的，也就是说，执行完成一个子控件的measure及layout过程再去执行下一个。下面看下这段代码：\n\n```java\nprotected void onMeasure(int widthSpec, int heightSpec) {\n    ...\n    if (mLayout.mAutoMeasure) {\n        final int widthMode = MeasureSpec.getMode(widthSpec);\n        final int heightMode = MeasureSpec.getMode(heightSpec);\n        final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY\n                && heightMode == MeasureSpec.EXACTLY;\n        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n        if (skipMeasure || mAdapter == null) {\n            return;\n        }\n        ...\n        dispatchLayoutStep2();\n        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);\n        ...\n    } else {\n        ...\n    }\n}\n```\n\n这是RecyclerView的测量方法，再看下dispatchLayoutStep2()方法：\n\n```java\nprivate void dispatchLayoutStep2() {\n    ...\n    mLayout.onLayoutChildren(mRecycler, mState);\n    ...\n}\n```\n\n​\t上面的mLayout就是一个RecyclerView.LayoutManager实例。通过以上代码（和方法名称），不难推断出，RecyclerView的measure及layout过程委托给了RecyclerView.LayoutManager。接着看onLayoutChildren方法，在兼容包中提供了3个RecyclerView.LayoutManager的实现，这里我就只以LinearLayoutManager来举例说明：\n\n```java\npublic void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n    // layout algorithm:\n    // 1) by checking children and other variables, find an anchor coordinate and an anchor\n    //  item position.\n    // 2) fill towards start, stacking from bottom\n    // 3) fill towards end, stacking from top\n    // 4) scroll to fulfill requirements like stack from bottom.\n    ...\n    mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;\n    // calculate anchor position and coordinate\n    updateAnchorInfoForLayout(recycler, state, mAnchorInfo);\n    ...\n    if (mAnchorInfo.mLayoutFromEnd) {\n        ...\n    } else {\n        // fill towards end\n        updateLayoutStateToFillEnd(mAnchorInfo);\n        mLayoutState.mExtra = extraForEnd;\n        fill(recycler, mLayoutState, state, false);\n        endOffset = mLayoutState.mOffset;\n        final int lastElement = mLayoutState.mCurrentPosition;\n        if (mLayoutState.mAvailable > 0) {\n            extraForStart += mLayoutState.mAvailable;\n        }\n        // fill towards start\n        updateLayoutStateToFillStart(mAnchorInfo);\n        mLayoutState.mExtra = extraForStart;\n        mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;\n        fill(recycler, mLayoutState, state, false);\n        startOffset = mLayoutState.mOffset;\n        ...\n    }\n    ...\n}\n```\n\n​\t源码中的注释部分我并没有略去，它已经解释了此处的逻辑了。这里我以垂直布局来说明，mAnchorInfo为布局锚点信息，包含了子控件在Y轴上起始绘制偏移量（coordinate），ItemView在Adapter中的索引位置（position）和布局方向（mLayoutFromEnd）——这里是指start、end方向。这部分代码的功能就是：确定布局锚点，以此为起点向开始和结束方向填充ItemView，如图所示：\n\n![recyclerview_layout](Android知识-三-RecyclerView深入解析/recyclerview_layout.png)\n\n​\t在上一段代码中，fill()方法的作用就是填充ItemView，而图（3）说明了，在上段代码中fill()方法调用2次的原因。虽然图（3）是更为普遍的情况，而且在实现填充ItemView算法时，也是按图（3）所示来实现的，但是mAnchorInfo在赋值过程(updateAnchorInfoForLayout)中，只会出现图（1）、图（2）所示情况。现在来看下fill()方法：\n\n```java\nint fill(RecyclerView.Recycler recycler, LayoutState layoutState,\n        RecyclerView.State state, boolean stopOnFocusable) {\n    ...\n    int remainingSpace = layoutState.mAvailable + layoutState.mExtra;\n    LayoutChunkResult layoutChunkResult = new LayoutChunkResult();\n    while (...&&layoutState.hasMore(state)) {\n        ...\n        layoutChunk(recycler, state, layoutState, layoutChunkResult);\n        ...\n        if (...) {\n            layoutState.mAvailable -= layoutChunkResult.mConsumed;\n            remainingSpace -= layoutChunkResult.mConsumed;\n        }\n        if (layoutState.mScrollingOffset != LayoutState.SCOLLING_OFFSET_NaN) {\n            layoutState.mScrollingOffset += layoutChunkResult.mConsumed;\n            if (layoutState.mAvailable < 0) {\n                layoutState.mScrollingOffset += layoutState.mAvailable;\n            }\n            recycleByLayoutState(recycler, layoutState);\n        }\n    }\n    ...\n}\n```\n\n下面是layoutChunk方法：\n\n```java\nvoid layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,\n        LayoutState layoutState, LayoutChunkResult result) {\n    View view = layoutState.next(recycler);\n    ...\n    if (layoutState.mScrapList == null) {\n        if (mShouldReverseLayout == (layoutState.mLayoutDirection\n                == LayoutState.LAYOUT_START)) {\n            addView(view);\n        } else {\n            addView(view, 0);\n        }\n    }\n    ...\n    measureChildWithMargins(view, 0, 0);\n    ...\n    // We calculate everything with View's bounding box (which includes decor and margins)\n    // To calculate correct layout position, we subtract margins.\n    layoutDecorated(view, left + params.leftMargin, top + params.topMargin,\n            right - params.rightMargin, bottom - params.bottomMargin);\n    ...\n}\n```\n\n​\t这里的addView()方法，其实就是ViewGroup的addView()方法；measureChildWithMargins()方法看名字就知道是用于测量子控件大小的，这里我先跳过这个方法的解释，放在后面来做，目前就简单地理解为测量子控件大小就好了。下面是layoutDecoreated()方法：\n\n```java\npublic void layoutDecorated(...) {\n    ...\n    child.layout(...);\n}\n```\n\n总结上面代码，在RecyclerView的measure及layout阶段，填充ItemView的算法为：向父容器增加子控件，测量子控件大小，布局子控件，布局锚点向当前布局方向平移子控件大小，重复上诉步骤至RecyclerView可绘制空间消耗完毕或子控件已全部填充。 \n　　这样所有的子控件的measure及layout过程就完成了。回到RecyclerView的onMeasure方法，执行mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec)这行代码的作用就是根据子控件的大小，设置RecyclerView的大小。至此，RecyclerView的measure和layout实际上已经完成了。 \n\n​\t但是，你有可能已经发现上面过程中的问题了：如何确定RecyclerView的可绘制空间？不过，如果你熟悉android控件的绘制机制的话，这就不是问题。其实，这里的可绘制空间，可以简单地理解为父容器的大小；更准确的描述是，父容器对RecyclerView的布局大小的要求，可以通过MeasureSpec.getSize()方法获得——这里不包括滑动情况，滑动情况会在后文描述。需要特别说明的是在23.2.0版本之前，RecyclerView是不支持WRAP_CONTENT的。先看下RecyclerView的onLayout()方法：\n\n```java\nprotected void onLayout(boolean changed, int l, int t, int r, int b) {\n    ...\n    dispatchLayout();\n    ...\n}\n```\n\n这是dispatchLayout方法：\n\n```java\nvoid dispatchLayout() {\n    ...\n    if (mState.mLayoutStep == State.STEP_START) {\n        dispatchLayoutStep1();\n        ...\n        dispatchLayoutStep2();\n    }\n    dispatchLayoutStep3();\n    ...\n}\n```\n\n​\t可以看出，这里也会执行子控件的measure及layout过程。结合onMeasure方法对skipMeasure的判断可以看出，如果要支持WRAP_CONTENT，那么子控件的measure及layout就会提前在RecyclerView的测量方法中执行完成，也就是说，先确定了子控件的大小及位置后，再由此设置RecyclerView的大小；如果是其它情况(测量模式为EXACTLY)，子控件的measure及layout过程就会延迟至RecyclerView的layout过程（RecyclerView.onLayout()）中执行。\n\n​\t再看onMeasure方法中的mLayout.mAutoMeasure，它表示，RecyclerView的measure及layout过程是否要委托给RecyclerView.LayoutManager，在兼容包中提供的３种RecyclerView.LayoutManager的这个属性默认都是为true的。好了，以上就是RecyclerView的measure及layout过程，下面来看下它的draw过程。\n\n​\tRecyclerView的draw过程可以分为２部分来看：RecyclerView负责绘制所有decoration；ItemView的绘制由ViewGroup处理，这里的绘制是android常规绘制逻辑，本文就不再阐述了。下面来看看RecyclerView的draw()和onDraw()方法：\n\n```java\n@Override\npublic void draw(Canvas c) {\n    super.draw(c);\n    final int count = mItemDecorations.size();\n    for (int i = 0; i < count; i++) {\n        mItemDecorations.get(i).onDrawOver(c, this, mState);\n    }\n    ...\n}\n@Override\npublic void onDraw(Canvas c) {\n    super.onDraw(c);\n    final int count = mItemDecorations.size();\n    for (int i = 0; i < count; i++) {\n        mItemDecorations.get(i).onDraw(c, this, mState);\n    }\n}\n```\n\n​\t可以看出对于decoration的绘制代码上十分简单。但是这里，我必须要抱怨一下RecyclerView.ItemDecoration的设计，它实在是太过于灵活了，虽然理论上我们可以使用它在RecyclerView内的任何地方绘制你想要的任何东西——到这一步，RecyclerView的大小位置已经确定的哦。但是过于灵活，太难使用，以至往往使我们无从下手。 好了，题外话就不多说了，来看看decoration的绘制吧。还记得上面提到过的measureChildWithMargins()方法吗？先来看看它：\n\n```java\npublic void measureChildWithMargins(View child, int widthUsed, int heightUsed) {\n        final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n    final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);\n    widthUsed += insets.left + insets.right;\n    heightUsed += insets.top + insets.bottom;\n\n    final int widthSpec = ...\n    final int heightSpec = ...\n    if (shouldMeasureChild(child, widthSpec, heightSpec, lp)) {\n        child.measure(widthSpec, heightSpec);\n    }\n}\n```\n这里是getItemDecorInsetsForChild()方法：\n\n```java\nRect getItemDecorInsetsForChild(View child) {\n    ...\n    final Rect insets = lp.mDecorInsets;\n    insets.set(0, 0, 0, 0);\n    final int decorCount = mItemDecorations.size();\n    for (int i = 0; i < decorCount; i++) {\n        mTempRect.set(0, 0, 0, 0);\n        mItemDecorations.get(i).getItemOffsets(mTempRect, child, this, mState);\n        insets.left += mTempRect.left;\n        insets.top += mTempRect.top;\n        insets.right += mTempRect.right;\n        insets.bottom += mTempRect.bottom;\n    }\n    lp.mInsetsDirty = false;\n    return insets;\n}\n```\n\n​\t方法getItemOffsets()就是我们在实现一个RecyclerView.ItemDecoration时可以重写的方法，通过mTempRect的大小，可以为每个ItemView设置位置偏移量，这个偏移量最终会参与计算ItemView的大小，也就是说ItemView的大小是包含这个位置偏移量的。我们在重写getItemOffsets()时，可以指定任意数值的偏移量：\n\n![itemdecoration](Android知识-三-RecyclerView深入解析/itemdecoration.png)\n\n4个方向的位置偏移量对应mTempRect的4个属性(left,top,right,bottom)，我以top offset的值在垂直线性布局中的应用来举例说明下。如果top offset等于0，那么ItemView之间就没有空隙；如果top offset大于0，那么ItemView之前就会有一个间隙；如果top offset小于0，那么ItemView之间就会有重叠的区域。 \n\n​\t当然，我们在实现RecyclerView.ItemDecoration时，并不一定要重写getItemOffsets()，同样的对于RecyclerView.ItemDecoration.onDraw()或RecyclerView.ItemDecoration.onDrawOver()方法也不是一定要重写，而且，这个绘制方法和我们所设置的位置偏移量没有任何联系。下面我来实现一个RecyclerView.ItemDecoration来加深下这里的理解：我将在垂直线性布局下，在ItemView间绘制一条5个像素宽、只有ItemView一半长、与ItemView居中对齐的红色分割线，这条分割线在ItemView内部top位置。\n\n```java\n@Override\npublic void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {\n  Paint paint = new Paint();\n  paint.setColor(Color.RED);\n  for (int i = 0; i < parent.getLayoutManager().getChildCount(); i++) {\n    final View child = parent.getChildAt(i);\n    float left = child.getLeft() + (child.getRight() - child.getLeft()) / 4;\n    float top = child.getTop();\n    float right = left + (child.getRight() - child.getLeft()) / 2;\n    float bottom = top + 5;\n    c.drawRect(left,top,right,bottom,paint);\n  }\n}\n@Override\npublic void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {\n  outRect.set(0, 0, 0, 0);\n}\n```\n\n代码不是很严谨，大家姑且一看吧，当然这里getItemOffsets()方法可以省略的。 \n\n​\t以上就是RecyclerView的整个绘制流程了，值得注意的地方也就是在23.2.0中RecyclerView支持WRAP_CONTENT属性了；还有就是ItemView的填充算法fill()算是一个亮点吧。接下来，我将分析ReyclerView的滑动流程。\n\n4、滑动流程\n\n​\tRecyclerView的滑动过程可以分为2个阶段：手指在屏幕上移动，使RecyclerView滑动的过程，可以称为scroll；手指离开屏幕，RecyclerView继续滑动一段距离的过程，可以称为fling。现在先看看RecyclerView的触屏事件处理onTouchEvent()方法：\n\n```java\npublic boolean onTouchEvent(MotionEvent e) {\n\t...\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n\t...\n    switch (action) {\n    ...\n        case MotionEvent.ACTION_MOVE: {\n        ...\n            final int x = (int) (MotionEventCompat.getX(e, index) + 0.5f);\n            final int y = (int) (MotionEventCompat.getY(e, index) + 0.5f);\n            int dx = mLastTouchX - x;\n            int dy = mLastTouchY - y;\n        ...\n            if (mScrollState != SCROLL_STATE_DRAGGING) {\n            ...\n                if (canScrollVertically && Math.abs(dy) > mTouchSlop) {\n                    if (dy > 0) {\n                        dy -= mTouchSlop;\n                    } else {\n                        dy += mTouchSlop;\n                    }\n                    startScroll = true;\n                }\n                if (startScroll) {\n                    setScrollState(SCROLL_STATE_DRAGGING);\n                }\n            }\n            if (mScrollState == SCROLL_STATE_DRAGGING) {\n                mLastTouchX = x - mScrollOffset[0];\n                mLastTouchY = y - mScrollOffset[1];\n                if (scrollByInternal(\n                        canScrollHorizontally ? dx : 0,\n                        canScrollVertically ? dy : 0,\n                        vtev)) {\n                    getParent().requestDisallowInterceptTouchEvent(true);\n                }\n            }\n        } break;\n    \t...\n        case MotionEvent.ACTION_UP: {\n        ...\n            final float yvel = canScrollVertically ?\n                    -VelocityTrackerCompat.getYVelocity(mVelocityTracker, mScrollPointerId) : 0;\n            if (!((xvel != 0 || yvel != 0) && fling((int) xvel, (int) yvel))) {\n                setScrollState(SCROLL_STATE_IDLE);\n            }\n            resetTouch();\n        } break;\n    \t...\n    }\n\t...\n}\n```\n\n​\t这里我以垂直方向的滑动来说明。当RecyclerView接收到ACTION_MOVE事件后，会先计算出手指移动距离（dy），并与滑动阀值（mTouchSlop）比较，当大于此阀值时将滑动状态设置为SCROLL_STATE_DRAGGING，而后调用scrollByInternal()方法，使RecyclerView滑动，这样RecyclerView的滑动的第一阶段scroll就完成了；当接收到ACTION_UP事件时，会根据之前的滑动距离与时间计算出一个初速度yvel，这步计算是由VelocityTracker实现的，然后再以此初速度，调用方法fling()，完成RecyclerView滑动的第二阶段fling。显然滑动过程中关键的方法就2个：scrollByInternal()与fling()。接下来同样以垂直线性布局来说明。先来说明scrollByInternal()，跟踪进入后，会发现它最终会调用到LinearLayoutManager.scrollBy()方法，这个过程很简单，我就不列出源码了，但是分析到这里先暂停下，去看看fling()方法：\n\n```java\npublic boolean fling(int velocityX, int velocityY) {\n\t...\n    mViewFlinger.fling(velocityX, velocityY);\n\t...\n}\n```\n\n​\t有用的就这一行，其它乱七八糟的不看也罢。mViewFlinger是一个Runnable的实现ViewFlinger的对象，就是它来控件着ReyclerView的fling过程的算法的。下面来看下类ViewFlinger的一段代码：\n\n```java\nvoid postOnAnimation() {\n    if (mEatRunOnAnimationRequest) {\n        mReSchedulePostAnimationCallback = true;\n    } else {\n        removeCallbacks(this);\n        ViewCompat.postOnAnimation(RecyclerView.this, this);\n    }\n}\npublic void fling(int velocityX, int velocityY) {\n    setScrollState(SCROLL_STATE_SETTLING);\n    mLastFlingX = mLastFlingY = 0;\n    mScroller.fling(0, 0, velocityX, velocityY,\n            Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    postOnAnimation();\n}\n```\n\n​\t可以看到，其实RecyclerView的fling是借助Scroller实现的；然后postOnAnimation()方法的作用就是在将来的某个时刻会执行我们给定的一个Runnable对象，在这里就是这个mViewFlinger对象，这部分原理我就不再深入分析了，它已经不属于本文的范围了。并且，关于Scroller的作用及原理，本文也不会作过多解释。对于这两点各位可以自行查阅，有很多文章对于作过详细阐述的。接下来看看ViewFlinger.run()方法：\n\n```java\npublic void run() {\n    ...\n    if (scroller.computeScrollOffset()) {\n        final int x = scroller.getCurrX();\n        final int y = scroller.getCurrY();\n        final int dx = x - mLastFlingX;\n        final int dy = y - mLastFlingY;\n        ...\n        if (mAdapter != null) {\n        ...\n            if (dy != 0) {\n                vresult = mLayout.scrollVerticallyBy(dy, mRecycler, mState);\n                overscrollY = dy - vresult;\n            }\n        ...\n        }\n        ...\n        if (!awakenScrollBars()) {\n            invalidate();//刷新界面\n        }\n        ...\n        if (scroller.isFinished() || !fullyConsumedAny) {\n            setScrollState(SCROLL_STATE_IDLE);\n        } else {\n            postOnAnimation();\n        }\n    }\n    ...\n}\n```\n\n​\t本段代码中有个方法mLayout.scrollVerticallyBy()，跟踪进入你会发现它最终也会走到LinearLayoutManager.scrollBy()，这样虽说RecyclerView的滑动可以分为两阶段，但是它们的实现最终其实是一样的。这里我先解释下上段代码。第一，dy表示滑动偏移量，它是由Scroller根据时间偏移量（Scroller.fling()开始时间到当前时刻）计算出的，当然如果是RecyclerView的scroll阶段，这个偏移量也就是手指滑动距离。第二，上段代码会多次执行，至到Scroller判断滑动结束或已经滑动到边界。再多说一下，postOnAnimation()保证了RecyclerView的滑动是流畅，这里涉及到著名的“android 16ms”机制，简单来说理想状态下，上段代码会以16毫秒一次的速度执行，这样其实，Scroller每次计算的滑动偏移量是很小的一部分，而RecyclerView就会根据这个偏移量，确定是平移ItemView，还是除了平移还需要再创建新ItemView。\n\n![recyclerview_scroll](Android知识-三-RecyclerView深入解析/recyclerview_scroll.png)\n\n现在就来看看LinearLayoutManager.scrollBy()方法：\n\n```java\nint scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) {\n    ...\n    final int absDy = Math.abs(dy);\n    updateLayoutState(layoutDirection, absDy, true, state);\n    final int consumed = mLayoutState.mScrollingOffset\n            + fill(recycler, mLayoutState, state, false);\n    ...\n    final int scrolled = absDy > consumed ? layoutDirection * consumed : dy;\n    mOrientationHelper.offsetChildren(-scrolled);\n    ...\n}\n```\n\n​\t如上文所讲到的fill()方法，作用就是向可绘制区间填充ItemView，那么在这里，可绘制区间就是滑动偏移量！再看方法mOrientationHelper.offsetChildren()作用就是平移ItemView。好了整个滑动过程就分析完成了，当然RecyclerView的滑动还有个特性叫平滑滑动（smooth scroll），其实它的实现就是一个fling滑动，所以就不再赘述了。\n\n5、Recycler\n\n　Recycler的作用就是重用ItemView。在填充ItemView的时候，ItemView是从它获取的；滑出屏幕的ItemView是由它回收的。对于不同状态的ItemView存储在了不同的集合中，比如有scrapped、cached、exCached、recycled，当然这些集合并不是都定义在同一个类里。 \n\n​\t回到之前的layoutChunk方法中，有行代码layoutState.next(recycler)，它的作用自然就是获取ItemView，我们进入这个方法查看，最终它会调用到RecyclerView.Recycler.getViewForPosition()方法：\n\n```java\nView getViewForPosition(int position, boolean dryRun) {\n\t...\n    // 0) If there is a changed scrap, try to find from there\n    if (mState.isPreLayout()) {\n        holder = getChangedScrapViewForPosition(position);\n        fromScrap = holder != null;\n    }\n    // 1) Find from scrap by position\n    if (holder == null) {\n        holder = getScrapViewForPosition(position, INVALID_TYPE, dryRun);\n    ...\n    }\n    if (holder == null) {\n    ...\n        // 2) Find from scrap via stable ids, if exists\n        if (mAdapter.hasStableIds()) {\n            holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);\n        ...\n        }\n        if (holder == null && mViewCacheExtension != null) {\n            final View view = mViewCacheExtension\n                    .getViewForPositionAndType(this, position, type);\n            if (view != null) {\n                holder = getChildViewHolder(view);\n            ...\n            }\n        }\n        if (holder == null) {\n        ...\n            holder = getRecycledViewPool().getRecycledView(type);\n        ...\n        }\n        if (holder == null) {\n            holder = mAdapter.createViewHolder(RecyclerView.this, type);\n        ...\n        }\n    }\n\t...\n    boolean bound = false;\n    if (mState.isPreLayout() && holder.isBound()) {\n        // do not update unless we absolutely have to.\n        holder.mPreLayoutPosition = position;\n    } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {\n    ...\n        mAdapter.bindViewHolder(holder, offsetPosition);\n    ...\n    }\n\t...\n}\n```\n\n​\t这个方法比较长，我先解释下它的逻辑吧。根据列表位置获取ItemView，先后从scrapped、cached、exCached、recycled集合中查找相应的ItemView，如果没有找到，就创建（Adapter.createViewHolder()），最后与数据集绑定。其中scrapped、cached和exCached集合定义在RecyclerView.Recycler中，分别表示将要在RecyclerView中删除的ItemView、一级缓存ItemView和二级缓存ItemView，cached集合的大小默认为２，exCached是需要我们通过RecyclerView.ViewCacheExtension自己实现的，默认没有；recycled集合其实是一个Map，定义在RecyclerView.RecycledViewPool中，将ItemView以ItemType分类保存了下来，这里算是RecyclerView设计上的亮点，通过RecyclerView.RecycledViewPool可以实现在不同的RecyclerView之间共享ItemView，只要为这些不同RecyclerView设置同一个RecyclerView.RecycledViewPool就可以了。 \n\n​\t上面解释了ItemView从不同集合中获取的方式，那么RecyclerView又是在什么时候向这些集合中添加ItemView的呢？下面我逐个介绍下。 scrapped集合中存储的其实是正在执行REMOVE操作的ItemView，这部分会在后文进一步描述。 在fill()方法的循环体中有行代码recycleByLayoutState(recycler, layoutState);，最终这个方法会执行到RecyclerView.Recycler.recycleViewHolderInternal()方法：\n\n```java\nvoid recycleViewHolderInternal(ViewHolder holder) {\n    ...\n    if (forceRecycle || holder.isRecyclable()) {\n        if (!holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED\n                | ViewHolder.FLAG_UPDATE)) {\n            // Retire oldest cached view\n            final int cachedViewSize = mCachedViews.size();\n            if (cachedViewSize == mViewCacheMax && cachedViewSize > 0) {\n                recycleCachedViewAt(0);\n            }\n            if (cachedViewSize < mViewCacheMax) {\n                mCachedViews.add(holder);\n                cached = true;\n            }\n        }\n        if (!cached) {\n            addViewHolderToRecycledViewPool(holder);\n            recycled = true;\n        }\n    }\n    ...\n}\n```\n\n​\t这个方法的逻辑是这样的：首先判断集合cached是否満了，如果已満就从cached集合中移出一个到recycled集合中去，再把新的ItemView添加到cached集合；如果不満就将ItemView直接添加到cached集合。 \n\n​\t最后exCached集合是我们自己创建的，所以添加删除元素也要我们自己实现。\n\n6、数据集、动画\n\n　　RecyclerView定义了4种针对数据集的操作，分别是ADD、REMOVE、UPDATE、MOVE，封装在了AdapterHelper.UpdateOp类中，并且所有操作由一个大小为30的对象池管理着。当我们要对数据集作任何操作时，都会从这个对象池中取出一个UpdateOp对象，放入一个等待队列中，最后调用RecyclerView.RecyclerViewDataObserver.triggerUpdateProcessor()方法，根据这个等待队列中的信息，对所有子控件重新测量、布局并绘制且执行动画。以上就是我们调用Adapter.notifyItemXXX()系列方法后发生的事。 \n\n​\t显然当我们对某个ItemView做操作时，它很有可以会影响到其它ItemView。下面我以REMOVE为例来梳理下这个流程。 \n\n![recyclerview_annomation_data](Android知识-三-RecyclerView深入解析/recyclerview_annomation_data.png)\n\n首先调用Adapter.notifyItemRemove()，追溯到方法RecyclerView.RecyclerViewDataObserver.onItemRangeRemoved()：\n\n```java\npublic void onItemRangeRemoved(int positionStart, int itemCount) {\n    assertNotInLayoutOrScroll(null);\n    if (mAdapterHelper.onItemRangeRemoved(positionStart, itemCount)) {\n        triggerUpdateProcessor();\n    }\n}\n```\n\n​\t这里的mAdapterHelper.onItemRangeRemoved()就是向之前提及的等待队列添加一个类型为REMOVE的UpdateOp对象， triggerUpdateProcessor()方法就是调用View.requestLayout()方法，这会导致界面重新布局，也就是说方法RecyclerView.onLayout()会随后调用，这之后的流程就和在绘制流程一节中所描述的一致了。但是动画在哪是执行的呢？查看之前所列出的onLayout()方法发现dispatchLayoutStepX方法共有3个，前文只解释了dispatchLayoutStep2()的作用，这里就其它2个方法作进一步说明。不过dispatchLayoutStep1()没有过多要说明的东西，它的作用只是初始化数据，需要详细说明的是dispatchLayoutStep3()方法：\n\n```java\nprivate void dispatchLayoutStep3() {\n    ...\n    if (mState.mRunSimpleAnimations) {\n        // Step 3: Find out where things are now, and process change animations.\n        ...\n        // Step 4: Process view info lists and trigger animations\n        mViewInfoStore.process(mViewInfoProcessCallback);\n    }\n    ...\n}\n```\n\n​\t代码注释已经说明得很清楚了，这里我没有列出step 3相关的代码是因为这部分只是初始化或赋值一些执行动画需要的中间数据，process()方法最终会执行到RecyclerView.animateDisappearance()方法：\n\n```java\nprivate void animateDisappearance(...) {\n    addAnimatingView(holder);\n    holder.setIsRecyclable(false);\n    if (mItemAnimator.animateDisappearance(holder, preLayoutInfo, postLayoutInfo)) {\n        postAnimationRunner();\n    }\n}\n```\n\n​\t这里的animateDisappearance()会把一个动画与ItemView绑定，并添加到待执行队列中， postAnimationRunner()调用后就会执行这个队列中的动画，注意方法addAnimatingView()：\n\n```java\nprivate void addAnimatingView(ViewHolder viewHolder) {\n    final View view = viewHolder.itemView;\n    ...\n    mChildHelper.addView(view, true);\n    ...\n}\n```\n\n​\t这里最终会向ChildHelper中的一个名为mHiddenViews的集合添加给定的ItemView，那么这个mHiddenViews又是什么东西？上节中的getViewForPosition()方法中有个getScrapViewForPosition()，作用是从scrapped集合中获取ItemView：\n\n```java\nViewHolder getScrapViewForPosition(int position, int type, boolean dryRun) {\n    ...\n    View view = mChildHelper.findHiddenNonRemovedView(position, type);\n    ...\n}\n```\n\n接下来是findHiddenNonRemovedView()方法：\n\n```java\nView findHiddenNonRemovedView(int position, int type) {\n    final int count = mHiddenViews.size();\n    for (int i = 0; i < count; i++) {\n        final View view = mHiddenViews.get(i);\n        RecyclerView.ViewHolder holder = mCallback.getChildViewHolder(view);\n        if (holder.getLayoutPosition() == position && !holder.isInvalid() && !holder.isRemoved()\n                && (type == RecyclerView.INVALID_TYPE || holder.getItemViewType() == type)) {\n            return view;\n        }\n    }\n    return null;\n}\n```\n\n看到这里就之前所讲的scrapped集合联系起来了，虽然绕了个圈。所以这里就论证我之前对于scrapped集合的理解。 \n\n7、pre&post layout\n\n​\t在RecyclerView中存在一个叫“预布局”的阶段，当然这个是我自己作的翻译，本来叫pre layout，与之对应的还有个叫post layout的阶段，它们分别发生在真正的子控件测量&布局的前后。其中pre layout阶段的作用是记录数据集改变前的子控件信息，post layout阶段的作用是记录数据集改变后的子控件信息及触发动画。\n\n```java\nvoid dispatchLayout() {\n    ...\n    if (mState.mLayoutStep == State.STEP_START) {\n        dispatchLayoutStep1();\n       ...\n        dispatchLayoutStep2();\n    }\n    dispatchLayoutStep3();\n    ...\n}\n```\n\n方法dispatchLayout()会在RecyclerView.onLayout()中被调用，其中dispatchLayoutStep1就是pre layout，dispatchLayoutStep3就是post layout，而dispatchLayoutStep2自然就是处理真正测量&布局的了。 \n　　首先来看看pre layout时都记录了什么内容：\n\n```java\nprivate void dispatchLayoutStep1() {\n    ...\n    if (mState.mRunSimpleAnimations) {\n        // Step 0: Find out where all non-removed items are, pre-layout\n        int count = mChildHelper.getChildCount();\n        for (int i = 0; i < count; ++i) {\n            final ViewHolder holder = ...\n            ...\n            final ItemHolderInfo animationInfo = mItemAnimator\n                    .recordPreLayoutInformation(...);\n            mViewInfoStore.addToPreLayout(holder, animationInfo);\n            ...\n        }\n    }\n    ...\n}\n```\n\n类ItemHolderInfo中封闭了对应ItemView的边界信息，即ItemView的left、top、right、bottom值。对象mViewInfoStore的作用正如源码注释：\n\n```java\n  /**\n   * Keeps data about views to be used for animations\n   */\n  final ViewInfoStore mViewInfoStore = new ViewInfoStore();\n```\n\n再来看看addToPreLayout()方法：\n\n```java\nvoid addToPreLayout(ViewHolder holder, ItemHolderInfo info) {\n    InfoRecord record = mLayoutHolderMap.get(holder);\n    if (record == null) {\n        record = InfoRecord.obtain();\n        mLayoutHolderMap.put(holder, record);\n    }\n    record.preInfo = info;\n    record.flags |= FLAG_PRE;\n}\n```\n\n由上可已看出RecyclerView将pre layout阶段的ItemView信息存放在了ViewInfoStore中的mLayoutHolderMap集合中。 \n　　接下来我们看看post layout阶段：\n\n```java\nprivate void dispatchLayoutStep3() {\n    ...\n    if (mState.mRunSimpleAnimations) {\n        // Step 3: Find out where things are now, and process change animations.\n        ...\n        for (int i = mChildHelper.getChildCount() - 1; i >= 0; i--) {\n            ...\n            final ItemHolderInfo animationInfo = mItemAnimator\n                    .recordPostLayoutInformation(mState, holder);\n            ...\n            if (...) {\n                ...\n                animateChange(oldChangeViewHolder, holder, preInfo, postInfo,\n                                oldDisappearing, newDisappearing);\n            } else {\n                mViewInfoStore.addToPostLayout(holder, animationInfo);\n            }\n        }\n        // Step 4: Process view info lists and trigger animations\n        mViewInfoStore.process(mViewInfoProcessCallback);\n    }\n    ...\n}\n```\n\n这是addToPostLayout()方法：\n\n```java\nvoid addToPostLayout(ViewHolder holder, ItemHolderInfo info) {\n    InfoRecord record = mLayoutHolderMap.get(holder);\n    if (record == null) {\n        record = InfoRecord.obtain();\n        mLayoutHolderMap.put(holder, record);\n    }\n    record.postInfo = info;\n    record.flags |= FLAG_POST;\n}\n```\n\n与pre layout阶段相同RecyclerView也是将post layout阶段的ItemView信息存放在mViewInfoStore的mLayoutHolderMap集合中，并且不难看出，同一个ItemView（或者叫ViewHolder）的pre layout信息与post layout信息封装在了同一个InfoRecord中，分别叫InfoRecord.preInfo与InforRecord.postInfo，**这样InfoRecord就保存着同一个ItemView在数据集变化前后的信息，我们可以根据此信息定义动画的开始和结束状态。** \n\n![pre_post_layout](Android知识-三-RecyclerView深入解析/pre_post_layout.png)\n\n​\t如上图所示，当我们插入A时，在完成了上文所诉过程后，以ItemView2为例，通过比较它的preInfo与postInfo——都为非空，源码中是以标志位的形式实现的，就可以知道它将执行MOVE操作；而A自然就是ADD操作。下面是ViewInfoStore.ProcessCallback实现中的其中一个方法，它会在mViewInfoStore.process()方法中被调用：\n\n```java\npublic void processPersistent(...) {\n        ...\n        if (mDataSetHasChangedAfterLayout) {\n            ...\n        } else if (mItemAnimator.animatePersistence(viewHolder, preInfo, postInfo)) {\n            postAnimationRunner();\n        }\n    }\n```\n\n我们知道，RecyclerView中ItemAnimator的默认实现是DefaultItemAnimator，这里我就只以默认实现来说明，这是animatePersistence()方法：\n\n```java\npublic boolean animatePersistence(...) {\n    if (preInfo.left != postInfo.left || preInfo.top != postInfo.top) {\n        ...\n        return animateMove(viewHolder,\n                preInfo.left, preInfo.top, postInfo.left, postInfo.top);\n    }\n    dispatchMoveFinished(viewHolder);\n    return false;\n}\n```\n\n当然这个方法在DefaultItemAnimator的父类SimpleItemAnimator中，通过比较preInfo与postInfo的left和top属性分别确定ItemView在水平或垂直方向是否要执行MOVE操作，而上面的方法postAnimationRunner()就是用来触发动画执行的。 \n　　通过前文我们知道，RecyclerView中定义了4种针对数据集的操作（也可以称为针对ItemView的操作），分别是ADD、REMOVE、UPDATE、MOVE，RecyclerView就是通过比较preInfo与postInfo来确定ItemView要执行哪种操作的，上文我描述了MOVE情况，这个比较过程是在方法ViewInfoStore.process()中实现的，其它情况我就不再赘述了，各位不妨自己去看看。 \n　　在DefaultItemAnimator中实现了上面4种操作下的动画。当postAnimationRunner()执行后，会触发DefaultItemAnimator.runPendingAnimations()方法的调用，这个方法过长，我这里只作下解释便可。4种操作对应的动画是有先后顺序的，remove–>move&change–>add，之所以有这样的顺序，不难看出是为了不让ItemView之间有重叠的区域，这个顺序是由ViewCompat.postOnAnimationDelayed()方法通过控制延时来实现的。在DefaultItemAnimator中，REMOVE和ADD对应的是淡入淡出动画（改变透明度），MOVE对应的是平移动画；UPDATE相对来说要复杂一些，是因为它不再是记录同一个ItemView的变化情况，而是记录2个ItemView的信息来作比较，pre layout阶段的信息来自“oldChangeViewHolder”，post layout阶段的信息来自“holder”，这两个对象在dispatchLayoutStep3方法中可以找到，而且，这2个ItemView的动画是同时执行的，所以它对应的动画是：“oldHolder”淡出且向“newHolder”平移，同时“newHolder”淡入。特别说明，前文有提过一个叫scrapped的集合，其实它除了保存REMOVE操作的ItemView，还保存着UPDATE操作中的“oldHolder”！ \n　　以上就是RecyclerView默认动画的具体实现逻辑了，总结下来就是：当数据集发生变化时，会导致RecyclerView重新测量&布局子控件，我们记录下这个变化前后的RecyclerView的快照（preInfo与postInfo），通过比较这2个快照，从而确定子控件要执行什么操作，最后再实现不同操作下对应的动画就好了。通常我们会调用notifyItemXXX()系列方法来通知RecyclerView数据集变化，这些方法之所以比notifyDataSetChanged()高效的原因就是它们不会让整个RecyclerView重新绘制，而是只重绘具体的子控件，并且通过动画连接子控件的前后状态，这样也就实现了在Material design中所讲的“Visual continuity”效果。\n\n8、子控件的测量与布局\n\n这一节将对preInfo与postInfo是如果确定（赋值）的，作进一步描述。 \n　　从前文我们知道，子控件的测量与布局其实在RecyclerView的测量阶段（onMeasure）就执行完了，这样做是为了支持WRAP_CONTENT，具体的方法呢就是dispatchLayoutStep1()与dispatchLayoutStep2()，同样这两个方法也会出现在RecyclerView的布局阶段（onLayout），但并不是说它们就会被调用，这里的调用逻辑是由RecyclerView.State类控制的，它定义了RecyclerView的整个测量布局过程，分为3步STEP_START、STEP_LAYOUT、STEP_ANIMATIONS，具体流程是：初始状态是STEP_START；如果RecyclerView当前在STEP_START阶段dispatchLayoutStep1()会执行，记录下preInfo，将状态改为STEP_LAYOUT；如果RecyclerView在STEP_LAYOUT阶段dispatchLayoutStep2()会执行，测量布局子控件，将状态改为STEP_ANIMATIONS；如果RecyclerView在STEP_ANIMATIONS阶段dispatchLayoutStep3()会执行，记录下postInfo，触发动画，将状态改为STEP_START。每次数据集更改都会执行上述3步。 \n　　在测量布局子控件的过程中，最重要的莫过于确定布局锚点了，以LinearLayoutManager垂直布局为例，在onLayoutChildren()方法中，会调用updateAnchorInfoForLayout()方法来确定布局锚点：\n\n```java\nprivate void updateAnchorInfoForLayout(...) {\n    if (updateAnchorFromPendingData(state, anchorInfo)) {\n        ...\n        return;\n    }\n    if (updateAnchorFromChildren(recycler, state, anchorInfo)) {\n        ...\n        return;\n    }\n    ...\n    anchorInfo.assignCoordinateFromPadding();\n    anchorInfo.mPosition = mStackFromEnd ? state.getItemCount() - 1 : 0;\n}\n```\n\n​\t这里布局锚点的确定方法有3种依据。首先，如果是第一次布局（没有ItemView），这种情况已经在前文有过描述了，这里就不再说明；剩余的2种分别是“滑动位置”与“子控件”，这2种情况都是发生在已经有ItemView时的，而且这里的“滑动位置”是指由方法scrollToPosition()确认的，并赋给了mPendingScrollPosition变量。现在先来看看“滑动位置”updateAnchorFromPendingData()方法：\n\n```java\nprivate boolean updateAnchorFromPendingData(...) {\n    ...\n    // if child is visible, try to make it a reference child and ensure it is fully visible.\n    // if child is not visible, align it depending on its virtual position.\n    anchorInfo.mPosition = mPendingScrollPosition;\n    ...\n    if (mPendingScrollPositionOffset == INVALID_OFFSET) {\n        View child = findViewByPosition(mPendingScrollPosition);\n        if (child != null) {\n            ...\n        } else { // item is not visible.\n            ...\n        }\n        return true;\n    }\n    ...\n    return true;\n}\n```\n\n布局锚点中的mCoordinate与mPosition，在前文描述为起始绘制偏移量与索引位置，再直白点就是屏幕位置与数据集位置，就是告诉RecyclerView从屏幕的mCoordinate位置开始填充子控件，与子控件绑定的数据从数据集的mPosition位置开始取得。上面这个方法中确定“屏幕位置”分为2种情况，就是对应于mPendingScrollPosition是否存在子控件，mCoordinate值的确定我就不再讲述了，无非是一边界判断的语句。 \n　　下面来看看“子控件”依据的情况，这是updateAnchorFromChildren()：\n\n```java\nprivate boolean updateAnchorFromChildren(...) {\n    ...\n    View referenceChild = anchorInfo.mLayoutFromEnd\n            ? findReferenceChildClosestToEnd(recycler, state)\n            : findReferenceChildClosestToStart(recycler, state);\n    if (referenceChild != null) {\n        anchorInfo.assignFromView(referenceChild);\n        ...\n        return true;\n    }\n    return false;\n}\n```\n\n​\t这种情况也并不复杂，就是找到最外边的一个子控件，以它的位置信息来确定布局锚点，就是方法assignFromView()，我也就不再列出来了。以上就是详细的布局锚点确认过程了。 ","tags":["Android"]},{"title":"Android知识(二)--View的绘制流程","url":"/2018/02/25/Android知识-二-View的绘制流程/","content":"\n### 1、View 绘制依赖关系简介\n\n#### 1.1、概述\n\n![view_draw](Android知识-二-View的绘制流程/view_draw.png)\n\n​\t如上图所示：DecorView是一个应用窗口的根容器，它本质上是一个FrameLayout。DecorView有唯一一个子View，它是一个垂直LinearLayout，包含两个子元素，一个是TitleView（ActionBar的容器），另一个是ContentView（窗口内容的容器）。关于ContentView，它是一个FrameLayout（android.R.id.content)，我们平常用的setContentView就是设置它的子View。上图还表达了每个Activity都与一个Window（具体来说是PhoneWindow）相关联，用户界面则由Window所承载。\n\n#### 1.2、window\n\n​\tWindow即窗口，这个概念在Android Framework中的实现为android.view.Window这个抽象类，这个抽象类是对Android系统中的窗口的抽象。在介绍这个类之前，我们先来看看究竟什么是窗口呢？\n\n实际上，窗口是一个宏观的思想，它是屏幕上用于绘制各种UI元素及响应用户输入事件的一个矩形区域。通常具备以下两个特点：\n\n- 独立绘制，不与其它界面相互影响；\n- 不会触发其它界面的输入事件；\n\n​\t在Android系统中，窗口是独占一个Surface实例的显示区域，每个窗口的Surface由WindowManagerService分配。我们可以把Surface看作一块画布，应用可以通过Canvas或OpenGL在其上面作画。画好之后，通过SurfaceFlinger将多块Surface按照特定的顺序（即Z-order）进行混合，而后输出到FrameBuffer中，这样用户界面就得以显示。\n\nandroid.view.Window这个抽象类可以看做Android中对窗口这一宏观概念所做的约定，而PhoneWindow这个类是Framework为我们提供的Android窗口概念的具体实现。接下来我们先来介绍一下android.view.Window这个抽象类。\n\n这个抽象类包含了三个核心组件：\n\n- WindowManager.LayoutParams: 窗口的布局参数；\n- Callback: 窗口的回调接口，通常由Activity实现；\n- ViewTree: 窗口所承载的控件树。\n\n下面我们来看一下Android中Window的具体实现（也是唯一实现）——PhoneWindow。\n\n#### 1.3、PhoneWindow\n\n​\t前面我们提到了，PhoneWindow这个类是Framework为我们提供的Android窗口的具体实现。我们平时调用setContentView()方法设置Activity的用户界面时，实际上就完成了对所关联的PhoneWindow的ViewTree的设置。我们还可以通过Activity类的requestWindowFeature()方法来定制Activity关联PhoneWindow的外观，这个方法实际上做的是把我们所请求的窗口外观特性存储到了PhoneWindow的mFeatures成员中，在窗口绘制阶段生成外观模板时，会根据mFeatures的值绘制特定外观。\n\n#### 1.4、setContentView()\n\n​\t在分析setContentView()方法前，我们需要明确：这个方法只是完成了Activity的ContentView的创建，而并没有执行View的绘制流程。\n​\t当我们自定义Activity继承自android.app.Activity时候，调用的setContentView()方法是Activity类的，源码如下：\n\n```java\npublic void setContentView(@LayoutRes int layoutResID) {   \n  getWindow().setContentView(layoutResID);   \n  . . .\n}\n```\n\ngetWindow()方法会返回Activity所关联的PhoneWindow，也就是说，实际上调用到了PhoneWindow的setContentView()方法，源码如下：\n\n```java\n@Override\npublic void setContentView(int layoutResID) {\n  if (mContentParent == null) {\n    // mContentParent即为上面提到的ContentView的父容器，若为空则调用installDecor()生成\n    installDecor();\n  } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n    // 具有FEATURE_CONTENT_TRANSITIONS特性表示开启了Transition\n    // mContentParent不为null，则移除decorView的所有子View\n    mContentParent.removeAllViews();\n  }\n  if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n    // 开启了Transition，做相应的处理，我们不讨论这种情况\n    // 感兴趣的同学可以参考源码\n    . . .\n  } else {\n    // 一般情况会来到这里，调用mLayoutInflater.inflate()方法来填充布局\n    // 填充布局也就是把我们设置的ContentView加入到mContentParent中\n    mLayoutInflater.inflate(layoutResID, mContentParent);\n  }\n  . . .\n  // cb即为该Window所关联的Activity\n  final Callback cb = getCallback();\n  if (cb != null && !isDestroyed()) {\n    // 调用onContentChanged()回调方法通知Activity窗口内容发生了改变\n    cb.onContentChanged();\n  }\n. . .\n}　\n```\n\n​\t在上面我们看到了，PhoneWindow的setContentView()方法中调用了LayoutInflater的inflate()方法来填充布局，这个方法的源码如下：\n\n```java\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {\n  return inflate(resource, root, root != null);\n}\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n  final Resources res = getContext().getResources();\n  . . .\n  final XmlResourceParser parser = res.getLayout(resource);\n  try {\n    return inflate(parser, root, attachToRoot);\n  } finally {\n    parser.close();\n  }\n}\n```\n\n​\t在PhoneWindow的setContentView()方法中传入了decorView作为LayoutInflater.inflate()的root参数，我们可以看到，通过层层调用，最终调用的是inflate(XmlPullParser, ViewGroup, boolean)方法来填充布局。这个方法的源码如下：\n\n```java\npublic View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n  synchronized (mConstructorArgs) {\n    . . .\n    final Context inflaterContext = mContext;\n    final AttributeSet attrs = Xml.asAttributeSet(parser);\n    Context lastContext = (Context) mConstructorArgs[0];\n    mConstructorArgs[0] = inflaterContext;\n    View result = root;\n    try {\n      // Look for the root node.\n      int type;\n      // 一直读取xml文件，直到遇到开始标记\n      while ((type = parser.next()) != XmlPullParser.START_TAG &&\n          type != XmlPullParser.END_DOCUMENT) {\n        // Empty\n       }\n      // 最先遇到的不是开始标记，报错\n      if (type != XmlPullParser.START_TAG) {\n        throw new InflateException(parser.getPositionDescription()+ \": No start tag found!\");\n      }\n      final String name = parser.getName();\n      . . .\n      // 单独处理<merge>标签，不熟悉的同学请参考官方文档的说明\n      if (TAG_MERGE.equals(name)) {\n        // 若包含<merge>标签，父容器（即root参数）不可为空且attachRoot须为true，否则报错\n        if (root == null || !attachToRoot) {\n          throw new InflateException(\"<merge/> can be used only with a valid ViewGroup root and attachToRoot=true\");\n        }\n        // 递归地填充布局\n        rInflate(parser, root, inflaterContext, attrs, false);\n     } else {\n        // temp为xml布局文件的根View\n        final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n        ViewGroup.LayoutParams params = null;\n        if (root != null) {\n          . . .\n          // 获取父容器的布局参数（LayoutParams）\n          params = root.generateLayoutParams(attrs);\n          if (!attachToRoot) {\n            // 若attachToRoot参数为false，则我们只会将父容器的布局参数设置给根View\n            temp.setLayoutParams(params);\n          }\n        }\n        // 递归加载根View的所有子View\n        rInflateChildren(parser, temp, attrs, true);\n        . . .\n        if (root != null && attachToRoot) {\n          // 若父容器不为空且attachToRoot为true，则将父容器作为根View的父View包裹上来\n          root.addView(temp, params);\n        }\n        // 若root为空或是attachToRoot为false，则以根View作为返回值\n        if (root == null || !attachToRoot) {\n           result = temp;\n        }\n      }\n    } catch (XmlPullParserException e) {\n      . . .\n    } catch (Exception e) {\n      . . .\n    } finally {\n      . . .\n    }\n    return result;\n  }\n}\n```\n\n​\t在上面的源码中，首先对于布局文件中的<merge>标签进行单独处理，调用rInflate()方法来递归填充布局。这个方法的源码如下：\n\n```java\npublic void rInflate(XmlPullParser parser, View parent, Context context,\n    AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {\n    // 获取当前标记的深度，根标记的深度为0\n    final int depth = parser.getDepth();\n    int type;\n    while (((type = parser.next()) != XmlPullParser.END_TAG ||\n        parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {\n      // 不是开始标记则继续下一次迭代\n      if (type != XmlPullParser.START_TAG) {\n        continue;\n      }\n      final String name = parser.getName();\n      // 对一些特殊标记做单独处理\n      if (TAG_REQUEST_FOCUS.equals(name)) {\n        parseRequestFocus(parser, parent);\n      } else if (TAG_TAG.equals(name)) {\n        parseViewTag(parser, parent, attrs);\n      } else if (TAG_INCLUDE.equals(name)) {\n        if (parser.getDepth() == 0) {\n          throw new InflateException(\"<include /> cannot be the root element\");\n        }\n        // 对<include>做处理\n        parseInclude(parser, context, parent, attrs);\n      } else if (TAG_MERGE.equals(name)) {\n        throw new InflateException(\"<merge /> must be the root element\");\n      } else {\n        // 对一般标记的处理\n        final View view = createViewFromTag(parent, name, context, attrs);\n        final ViewGroup viewGroup = (ViewGroup) parent;\n        final ViewGroup.LayoutParams params=viewGroup.generateLayoutParams(attrs);\n        // 递归地加载子View\n        rInflateChildren(parser, view, attrs, true);\n        viewGroup.addView(view, params);\n      }\n    }\n    if (finishInflate) {\n      parent.onFinishInflate();\n    }\n}\n```\n\n我们可以看到，上面的inflate()和rInflate()方法中都调用了rInflateChildren()方法，这个方法的源码如下：\n\n```java\nfinal void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {\n    rInflate(parser, parent, parent.getContext(), attrs, finishInflate);\n}\n```\n\n​\t从源码中我们可以知道，rInflateChildren()方法实际上调用了rInflate()方法。\n\n​\t到这里，setContentView()的整体执行流程我们就分析完了，至此我们已经完成了Activity的ContentView的创建与设置工作。接下来，我们开始进入正题，分析View的绘制流程。\n\n#### 1.5、ViewRoot\n\n​\t在介绍View的绘制前，首先我们需要知道是谁负责执行View绘制的整个流程。实际上，View的绘制是由ViewRoot来负责的。每个应用程序窗口的decorView都有一个与之关联的ViewRoot对象，这种关联关系是由WindowManager来维护的。那么decorView与ViewRoot的关联关系是在什么时候建立的呢？答案是Activity启动时，ActivityThread.handleResumeActivity()方法中建立了它们两者的关联关系。这里我们不具体分析它们建立关联的时机与方式，感兴趣的同学可以参考相关源码。下面我们直入主题，分析一下ViewRoot是如何完成View的绘制的。\n\n#### 1.6、View绘制的起点\n\n​\t当建立好了decorView与ViewRoot的关联后，ViewRoot类的requestLayout()方法会被调用，以完成应用程序用户界面的初次布局。实际被调用的是ViewRootImpl类的requestLayout()方法，这个方法的源码如下：\n\n```java\n@Override\npublic void requestLayout() {\n  if (!mHandlingLayoutInLayoutRequest) {\n    // 检查发起布局请求的线程是否为主线程 \n    checkThread();\n    mLayoutRequested = true;\n    scheduleTraversals();\n  }\n}\n```\n\n上面的方法中调用了scheduleTraversals()方法来调度一次完成的绘制流程，该方法会向主线程发送一个“遍历”消息，最终会导致ViewRootImpl的performTraversals()方法被调用。下面，我们以performTraversals()为起点，来分析View的整个绘制流程。\n\n### 2、View 树的绘图流程\n\n#### 2.1、绘制流程概述\n\n​\t当 Activity 接收到焦点的时候，它会被请求绘制布局,该请求由 Android framework 处理.绘制是从根节点开始，对布局树进行 measure 和 draw。整个 View 树的绘图流程在`ViewRoot.java`类的`performTraversals()`函数展开，该函数所做 的工作可简单概况可以分为以下三个阶段(即View的整个绘制流程)：\n\n- measure: 判断是否需要重新计算View的大小，需要的话则计算；\n- layout: 判断是否需要重新计算View的位置，需要的话则计算；\n- draw: 判断是否需要重新绘制View，需要的话则重绘制。\n\n![view_mechanism_flow](Android知识-二-View的绘制流程/view_mechanism_flow.png)\n\nView 绘制流程函数调用链:\n\n![view_draw_method_chain](Android知识-二-View的绘制流程/view_draw_method_chain.png)\n\n​\t**注意：用户主动调用 request，只会出发 measure 和 layout 过程，而不会执行 draw 过程**\n\n从整体上来看 Measure 和 Layout 两个步骤的执行：\n\n#### 2.2、measure阶段\n\n​\t此阶段的目的是计算出控件树中的各个控件要显示其内容的话，需要多大尺寸。起点是ViewRootImpl的measureHierarchy()方法，这个方法的源码如下\n\n```java\nprivate boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res,\n    final int desiredWindowWidth, final int desiredWindowHeight) {\n  // 传入的desiredWindowXxx为窗口尺寸\n  int childWidthMeasureSpec;\n  int childHeightMeasureSpec;\n  boolean windowSizeMayChange = false;\n  . . .\n  boolean goodMeasure = false;\n  if (!goodMeasure) {\n        childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);\n        childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);\n        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n        if (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) {\n         \twindowSizeMayChange = true;\n        }\n  }\n  return windowSizeMayChange;\n}\n```\n\n​\t上面的代码中调用getRootMeasureSpec()方法来获取根MeasureSpec，这个根MeasureSpec代表了对decorView的宽高的约束信息。继续分析之前，我们先来简单地介绍下MeasureSpec的概念。\n​\tMeasureSpec是一个32位整数，由SpecMode和SpecSize两部分组成，其中，高2位为SpecMode，低30位为SpecSize。SpecMode为测量模式，SpecSize为相应测量模式下的测量尺寸。View（包括普通View和ViewGroup）的SpecMode由本View的LayoutParams结合父View的MeasureSpec生成。SpecMode的取值可为以下三种：\n\n- EXACTLY: 对子View提出了一个确切的建议尺寸（SpecSize）；\n- AT_MOST: 子View的大小不得超过SpecSize；\n- UNSPECIFIED: 对子View的尺寸不作限制，通常用于系统内部。\n\n传入performMeasure()方法的MeasureSpec的SpecMode为EXACTLY，SpecSize为窗口尺寸。\nperformMeasure()方法的源码如下：\n\n```java\nprivate void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {\n      . . .\n      try {\n        \tmView.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n      } finally {\n        \t. . .\n      }\n}\n```\n\n上面代码中的mView即为decorView，也就是说会转向对View.measure()方法的调用，这个方法的源码如下：\n\n```java\n  /**\n  * 调用这个方法来算出一个View应该为多大。参数为父View对其宽高的约束信息。\n  * 实际的测量工作在onMeasure()方法中进行\n  */\n  public final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n      . . .\n      // 判断是否需要重新布局\n\n      // 若mPrivateFlags中包含PFLAG_FORCE_LAYOUT标记，则强制重新布局\n      // 比如调用View.requestLayout()会在mPrivateFlags中加入此标记\n      final boolean forceLayout = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;\n      final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec\n          || heightMeasureSpec != mOldHeightMeasureSpec;\n      final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY\n          && MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;\n      final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)\n          && getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);\n      final boolean needsLayout = specChanged\n          && (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);\n\n      // 需要重新布局 \n      if (forceLayout || needsLayout) {\n            . . .\n            // 先尝试从缓从中获取，若forceLayout为true或是缓存中不存在或是\n            // 忽略缓存，则调用onMeasure()重新进行测量工作\n            int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);\n            if (cacheIndex < 0 || sIgnoreMeasureCache) {\n                  // measure ourselves, this should set the measured dimension flag back\n                  onMeasure(widthMeasureSpec, heightMeasureSpec);\n                  . . .\n            } else {\n                  // 缓存命中，直接从缓存中取值即可，不必再测量\n                  long value = mMeasureCache.valueAt(cacheIndex);\n                  // Casting a long to int drops the high 32 bits, no mask needed\n                  setMeasuredDimensionRaw((int) (value >> 32), (int) value);\n                  . . .\n            }\n            . . .\n      }\n      mOldWidthMeasureSpec = widthMeasureSpec;\n      mOldHeightMeasureSpec = heightMeasureSpec;\n      mMeasureCache.put(key, ((long) mMeasuredWidth) << 32 |\n          (long) mMeasuredHeight & 0xffffffffL); // suppress sign extension\n}\n```\n\n​\tFrameLayout是ViewGroup的子类，后者有一个View[]类型的成员变量mChildren，代表了其子View集合。通过getChildAt(i)能获取指定索引处的子View，通过getChildCount()可以获得子View的总数。\n\n​\t在上面的源码中，首先调用measureChildWithMargins()方法对所有子View进行了一遍测量，并计算出所有子View的最大宽度和最大高度。而后将得到的最大高度和宽度加上padding，这里的padding包括了父View的padding和前景区域的padding。然后会检查是否设置了最小宽高，并与其比较，将两者中较大的设为最终的最大宽高。最后，若设置了前景图像，我们还要检查前景图像的最小宽高。\n\n​\t经过了以上一系列步骤后，我们就得到了maxHeight和maxWidth的最终值，表示当前容器View用这个尺寸就能够正常显示其所有子View（同时考虑了padding和margin）。而后我们需要调用resolveSizeAndState()方法来结合传来的MeasureSpec来获取最终的测量宽高，并保存到mMeasuredWidth与mMeasuredHeight成员变量中。\n\n​\t从以上代码的执行流程中，我们可以看到，容器View通过measureChildWithMargins()方法对所有子View进行测量后，才能得到自身的测量结果。也就是说，对于ViewGroup及其子类来说，要先完成子View的测量，再进行自身的测量（考虑进padding等）。\n接下来我们来看下ViewGroup的measureChildWithMargins()方法的实现：\n\n```java\npublic static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) {\n  final int specMode = MeasureSpec.getMode(measureSpec);\n  final int specSize = MeasureSpec.getSize(measureSpec);\n  final int result;\n  switch (specMode) {\n    case MeasureSpec.AT_MOST:\n      if (specSize < size) {\n        // 父View给定的最大尺寸小于完全显示内容所需尺寸\n        // 则在测量结果上加上MEASURED_STATE_TOO_SMALL\n        result = specSize | MEASURED_STATE_TOO_SMALL;\n      } else {\n       result = size;\n      }\n      break;\n    case MeasureSpec.EXACTLY:\n      // 若specMode为EXACTLY，则不考虑size，result直接赋值为specSize\n      result = specSize;\n      break;\n    case MeasureSpec.UNSPECIFIED:\n    default:\n      result = size;\n  }\n  return result | (childMeasuredState & MEASURED_STATE_MASK);\n}\n```\n\n对于普通View，会调用View类的onMeasure()方法来进行实际的测量工作，该方法的源码如下：\n\n```java\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n        getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n}\n```\n\n​\t对于普通View（非ViewgGroup）来说，只需完成自身的测量工作即可。以上代码中通过setMeasuredDimension()方法设置测量的结果，具体来说是以getDefaultSize()方法的返回值来作为测量结果。getDefaultSize()方法的源码如下：\n\n```java\npublic static int getDefaultSize(int size, int measureSpec) {\n  int result = size;\n  int specMode = MeasureSpec.getMode(measureSpec);\n  int specSize = MeasureSpec.getSize(measureSpec);\n  switch (specMode) {\n    case MeasureSpec.UNSPECIFIED:\n      result = size;\n      break;\n    case MeasureSpec.AT_MOST:\n    case MeasureSpec.EXACTLY:\n      result = specSize;\n      break;\n  }\n  return result;\n}\n```\n\n​\t由以上代码我们可以看到，View的getDefaultSize()方法对于AT_MOST和EXACTLY这两种情况都返回了SpecSize作为result。所以若我们的自定义View直接继承了View类，我们就要自己对wrap_content (对应了AT_MOST)这种情况进行处理，否则对自定义View指定wrap_content就和match_parent效果一样了。\n\n#### 2.2、layout阶段\n\nlayout阶段的基本思想也是由根View开始，递归地完成整个控件树的布局（layout）工作。\n\nView.layout()\n\n​\t我们把对decorView的layout()方法的调用作为布局整个控件树的起点，实际上调用的是View类的layout()方法，源码如下：\n\n```java\npublic void layout(int l, int t, int r, int b) {\n    // l为本View左边缘与父View左边缘的距离\n    // t为本View上边缘与父View上边缘的距离\n    // r为本View右边缘与父View左边缘的距离\n    // b为本View下边缘与父View上边缘的距离\n    . . .\n    boolean changed=isLayoutModeOptical(mParent)?setOpticalFrame(l, t, r, b):setFrame(l, t, r, b);\n    if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {\n        onLayout(changed, l, t, r, b);\n        . . .\n    }\n    . . .\n}\n```\n\n​\t这个方法会调用setFrame()方法来设置View的mLeft、mTop、mRight和mBottom四个参数，这四个参数描述了View相对其父View的位置（分别赋值为l, t, r, b），在setFrame()方法中会判断View的位置是否发生了改变，若发生了改变，则需要对子View进行重新布局，对子View的局部是通过onLayout()方法实现了。由于普通View（ 非ViewGroup）不含子View，所以View类的onLayout()方法为空。因此接下来，我们看看ViewGroup类的onLayout()方法的实现。\n\nViewGroup.onLayout()\n\n​\t实际上ViewGroup类的onLayout()方法是abstract，这是因为不同的布局管理器有着不同的布局方式。\n这里我们以decorView，也就是FrameLayout的onLayout()方法为例，分析ViewGroup的布局过程：\n\n```java\n@Override\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n    layoutChildren(left, top, right, bottom, false /* no force left gravity */);\n}\n\nprivate void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) {\n    final int count = getChildCount();\n    final int parentLeft = getPaddingLeftWithForeground();\n    final int parentRight = right - left - getPaddingRightWithForeground();\n    final int parentTop = getPaddingTopWithForeground();\n    final int parentBottom = bottom - top - getPaddingBottomWithForeground();\n    for (int i = 0; i < count; i++) {\n        final View child = getChildAt(i);\n        if (child.getVisibility() != GONE) {\n            final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n            final int width = child.getMeasuredWidth();\n            final int height = child.getMeasuredHeight();\n            int childLeft;\n            int childTop;\n            int gravity = lp.gravity;\n            if (gravity == -1) {\n                gravity = DEFAULT_CHILD_GRAVITY;\n            }\n            final int layoutDirection = getLayoutDirection();\n            final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);\n            final int verticalGravity = gravity & Gravity.VERTICAL_GRAVITY_MASK;\n            switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {\n                case Gravity.CENTER_HORIZONTAL:\n                    childLeft = parentLeft + (parentRight - parentLeft - width) / 2 +\n                            lp.leftMargin - lp.rightMargin;\n                    break;\n                case Gravity.RIGHT:\n                    if (!forceLeftGravity) {\n                        childLeft = parentRight - width - lp.rightMargin;\n                        break;\n                    }\n                case Gravity.LEFT:\n                default:\n                    childLeft = parentLeft + lp.leftMargin;\n\n            }\n            switch (verticalGravity) {\n                case Gravity.TOP:\n                    childTop = parentTop + lp.topMargin;\n                    break;\n                case Gravity.CENTER_VERTICAL:\n                    childTop = parentTop + (parentBottom - parentTop - height) / 2 +\n                            lp.topMargin - lp.bottomMargin;\n                    break;\n                case Gravity.BOTTOM:\n                    childTop = parentBottom - height - lp.bottomMargin;\n                    break;\n                default:\n                    childTop = parentTop + lp.topMargin;\n            }\n            child.layout(childLeft, childTop, childLeft + width, childTop + height);\n        }\n    }\n}\n```\n\n在上面的方法中，parentLeft表示当前View为其子View显示区域指定的一个左边界，也就是子View显示区域的左边缘到父View的左边缘的距离，parentRight、parentTop、parentBottom的含义同理。确定了子View的显示区域后，接下来，用一个for循环来完成子View的布局。\n在确保子View的可见性不为GONE的情况下才会对其进行布局。首先会获取子View的LayoutParams、layoutDirection等一系列参数。上面代码中的childLeft代表了最终子View的左边缘距父View左边缘的距离，childTop代表了子View的上边缘距父View的上边缘的距离。会根据子View的layout_gravity的取值对childLeft和childTop做出不同的调整。最后会调用child.layout()方法对子View的位置参数进行设置，这时便转到了View.layout()方法的调用，若子View是容器View，则会递归地对其子View进行布局。\n\n到这里，layout阶段的大致流程我们就分析完了，这个阶段主要就是根据上一阶段得到的View的测量宽高来确定View的最终显示位置。显然，经过了measure阶段和layout阶段，我们已经确定好了View的大小和位置，那么接下来就可以开始绘制View了。\n\n#### 2.3、draw阶段\n\n- View.draw(Canvas canvas)： 由于 ViewGroup 并没有复写此方法，因此，所有的视图最终都是调用 View 的 draw 方法进行绘制的。在自定义的视图中，也不应该复写该方法，而是复写 `onDraw(Canvas)` 方法进行绘制，如果自定义的视图确实要复写该方法，那么请先调用 `super.draw(canvas)`完成系统的绘制，然后再进行自定义的绘制。\n- View.onDraw()：\n  View 的`onDraw（Canvas）`默认是空实现，自定义绘制过程需要复写的方法，绘制自身的内容。\n- dispatchDraw() 发起对子视图的绘制。View 中默认是空实现，ViewGroup 复写了`dispatchDraw()`来对其子视图进行绘制。该方法我们不用去管，自定义的 ViewGroup 不应该对`dispatchDraw()`进行复写。\n\n对于本阶段的分析，我们以decorView.draw()作为分析的起点，也就是View.draw()方法，它的源码如下：\n\n```java\npublic void draw(Canvas canvas) {\n    . . .\n    // 绘制背景，只有dirtyOpaque为false时才进行绘制，下同\n    int saveCount;\n    if (!dirtyOpaque) {\n        drawBackground(canvas);\n    }\n     . . .\n    // 绘制自身内容\n    if (!dirtyOpaque) onDraw(canvas);\n    // 绘制子View\n    dispatchDraw(canvas);\n    . . .\n    // 绘制滚动条等\n    onDrawForeground(canvas);\n}\n```\n\n​\t简单起见，在上面的代码中我们省略了实现滑动时渐变边框效果相关的逻辑。实际上，View类的onDraw()方法为空，因为每个View绘制自身的方式都不尽相同，对于decorView来说，由于它是容器View，所以它本身并没有什么要绘制的。dispatchDraw()方法用于绘制子View，显然普通View（非ViewGroup）并不能包含子View，所以View类中这个方法的实现为空。\n\nViewGroup类的dispatchDraw()方法中会依次调用drawChild()方法来绘制子View，drawChild()方法的源码如下：\n\n```java\nprotected boolean drawChild(Canvas canvas, View child, long drawingTime) {\n  return child.draw(canvas, this, drawingTime);\n}\n```\n\n​\t这个方法调用了View.draw(Canvas, ViewGroup，long)方法来对子View进行绘制。在draw(Canvas, ViewGroup, long)方法中，首先对canvas进行了一系列变换，以变换到将要被绘制的View的坐标系下。完成对canvas的变换后，便会调用View.draw(Canvas)方法进行实际的绘制工作，此时传入的canvas为经过变换的，在将被绘制View的坐标系下的canvas。\n\n进入到View.draw(Canvas)方法后，会向之前介绍的一样，执行以下几步：\n\n- 绘制背景;\n\n- 通过onDraw()绘制自身内容;\n\n- 通过dispatchDraw()绘制子View;\n\n- 绘制滚动条\n\n  \n\n![](Android知识-二-View的绘制流程/draw_method_flow.png)\n\n[**Measure、Layout、Draw详解**](http://www.cnblogs.com/jycboy/p/6066654.html)\n\n","tags":["Android"]},{"title":"Android知识(一)--View事件传递","url":"/2018/02/24/Android知识(一)-View事件传递/","content":"\n### 1、View事件基础知识\n\n　　(1) 所有 Touch 事件都被封装成了 MotionEvent 对象，包括 Touch 的位置、时间、历史记录以及第几个手指(多指触摸)等；\n\n　　(2) 事件类型分为 ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_POINTER_DOWN, ACTION_POINTER_UP, ACTION_CANCEL，每个事件都是以 ACTION_DOWN 开始 ACTION_UP 结束；\n\n　　(3) 对事件的处理包括三类，分别为传递——dispatchTouchEvent()函数、拦截——onInterceptTouchEvent()函数、消费——onTouchEvent()函数和 OnTouchListener；\n\n　　(4)、事件一定是先到达父控件上；\n\n　　(5)、父控件和父类不是一回事，这两个概念初学者很容易混淆。\n\n### 2、View事件模型\n\n​\t所谓的事件模型就是：控件→子控件\n\n​\t事件模型主要涉及到3个概念：事件的分发、事件的拦截、事件的响应。\n\n#### ​\t2.1、事件分发主要分为以下三种情况\n\n​\t\tA、首先会先调用自身的onInterceptTouchEvent方法，调用此方法的目的是为了，先让自己这个控件判断下是否需要把此事件拦截下来，如果拦截下来，那么就代表自己这个控件需要处理这个事件，所以此时会调用自身onTouchEvent来对这个事件进行响应。\n\n​\t\tB、如果不拦截下来，那么才会有后续的事件向下传递的流程。将这个事件传递给子控件。现在子控件接收到了这个事件，上文提过，一个事件到达一个View或者ViewGroup，就会最先调用这个控件的dispatchTouchEvent，所以此时，事件到达子控件的dispatchTouchEvent方法，如果这个控件仍然是一个ViewGroup的类型，那么事件继续分发的逻辑依然遵循A流程的逻辑。\n\n​\t\tC、如果这个子控件只是一个View，而不是ViewGroup，那么此时，事件分发的逻辑略有不同。由于View没有onInterceptTouchEvent的方法，所以当一个事件到达这个View的dispatchTouchEvent的时候，dispatchTouchEvent就调用不到onInterceptTouchEvent，它会直接调用onTouchEvent的方法，直接让这个View来响应此事件。\n\n#### ​\t2.2、事件响应\n\n![event_respose](Android知识-View事件传递/event_respose.jpg)\n\n​        如上图所示，如果ViewGroupB拦截了事件，那么此时事件就会由ViewGroupB来响应，调用ViewGroupB中的onTouchEvent，此时ViewGroupB中的onTouchEvent的返回值有两种可能，一种是true，一种是false，如果返回true，则代表ViewGroupB消费了此事件，事件此时终止。如果返回的值是false，那么此时这个事件会回传给父控件，调用到父控件的onTouchEvent方法，由父控件来进行响应，那父控件的onTouchEvent也是同样的逻辑。要么消费事件，要么回传给父控件的父控件。\n　　此时，就可以得出我们通常所说的两个方向：\n　　(1)、事件传递的方向：父控件→子控件\n　　(2)、事件响应的方向：子控件→父控件\t\n\n​\t当然，仅仅是这个结论是无法满足我们实际开发的需要，我们需要更细致的分析。这里有一个细节上的问题需要注意，就是事件分为Down事件、Move事件、Up事件，任何一种事件都遵循事件传递和响应的逻辑原则，很多开发者常常会认为Down-Move-Up连在一起才是一个事件的产生，这种想法是不对的。\n事件的起点是由Down事件开始的，然后产生一系列的Move事件，最后通常以Up事件结束。当Down事件产生的时候，会由父控件传递给子控件，Move事件也由父控件传递给子控件，Up事件也由父控件传递给子控件。它们都遵循同样的传递事件的逻辑流程。不过Down事件最终响应的结果，会影响到后续事件的执行。这句话是什么意思呢？\n\n#### ​\t2.3 、事件拦截\n\n​\t如果Down事件传递到了子View上，但是子View的onTouchEvent对于这个Down事件的处理是return了一个false，这样的结果就是会造成父View的onTouchEvent的调用，同时还有另外一个后果，那就是后续的Move事件、Up事件就都传递不到子View上。所以，如果一个View要处理滑动事件，也就是Move事件的话，那么它一定不能在onTouchEvent中，对Down事件return false。\n\n　　如果Down事件到了父View上，父View需要调用自身的onInterceptTouchEvent判断是否对这个Down事件进行拦截，如果拦截，return了true，那么这个事件就会到父View的onTouchEvent中进行响应。如果此时父View的onTouchEvent也返回了true，那么代表这个父View响应了Down事件。不过这里有一点不太一样的地方是，事件传递到父View的onTouchEvent方法是因为自身的onInterceptTouchEvent方法判断拦截导致的，而不是由子View回传回来的，在这种情况下，当Move事件、Up事件传递到父View的时候，它当然不会传递给子View，并且，也不再调用自身的onInterceptTouchEvent方法。\n\n#### \t2.4 、事件冲突的解决\n\n　　理解事件传递的基本逻辑，对于工作过程中解决滑动事件冲突非常有帮助。比如我们此时有一个父控件ViewPager，这个ViewPager其中一个Item是ScrollView，此时会发生什么问题呢？当ViewPager滑动到ScrollView这个条目的时候，再左右滑动，发现ViewPager再也左右滑动不了了。这是为什么呢？我们结合图6一起来分析一下。\n\n\n　　(1)、我们都知道ViewPager是能够横向滑动的控件，而ScrollView是纵向滑动的控件，当Down事件产生的时候，此时会由ViewPager传递给ScrollView，ViewPager没有对Down事件拦截，ScrollView也不会对这个Down事件进行拦截，所以事件就会传递给ScrollView的孩子，也就是类似于图6中的子View，子View如果没有对Down事件响应，那么最后会到ScrollView中的onTouchEvent，而ScrollView的onTouchEvent对于这个Down事件返回了true，代表ScrollView消费了这个Down事件。\n\n\n　　(2)、接下来开始滑动手指，产生一系列的Move事件。Move事件也是由ViewPager传递给ScrollView。由于Down事件是被ScrollView的onTouchEvent中消费的，所以Move事件就不会传递给ScrollView的子控件了。一系列的Move事件也是在ScrollView的onTouchEvent中被执行。\n\n\n　　(3)、最后的Up事件也是由ScrollView中的onTouchEvent消费。\n\n\n　　从上述1至3的步骤中，我们看出来无论是Down事件、Move事件还是Up事件，最后全部都是被ScrollView所消费。从头到尾ViewPager的onTouchEvent都没有得到执行。而ViewPager之所以能够左右滑动，正是因为ViewPager的onTouchEvent里面的代码逻辑产生的效果。ViewPager的onTouchEvent没有执行，这个ViewPager当然就不能够左右滑动了。所以解决上述问题，就是在于如何让ViewPager中的onTouchEvent方法执行。\n我们可以自定义一个MyViewPager继承ViewPager，重写onInterceptTouchEvent方法，如果我们在onInterceptTouchEvent方法中直接野蛮地return一个true，此时就代表无论是Down事件、Move事件，还是Up事件，全部都拦截下来了，拦截在MyViewPager中，我们可以认为是图6中的ViewGroupB，既然拦截下来了所有事件，那么所有事件就会传递到MyViewPager的onTouchEvent，所以此时，这个MyViewPager一定可以左右滑动。\n\n　　但是，由此会引发另外一个问题，就是这个ScrollView不能上下滑动了。这又是为什么呢？因为ScrollView能够上下滑动的代码逻辑在ScrollView中的onTouchEvent方法内，而此时事件又全部被MyViewPager拦截了下来，ScrollView完全得不到事件，onTouchEvent方法得不到执行，自然不能上下滑动。所以我们需要修改MyViewPager中的onInterceptTouchEvent的逻辑。\n\n\n　　ViewPager只对左右滑动感兴趣，而ScrollView对上下滑动这个动作感兴趣，所以我们只需要在MyViewPager的onInterceptTouchEvent中，根据多个Move事件，判断是左右滑动还是上下滑动，如果是左右滑动，return true将事件拦截下来，如果是上下滑动，return false将事件传递给ScrollView，这样就能解决问题了。\n所以，对于Down事件，我们一般都不进行拦截，判断是否拦截得根据一些列的Move事件才能得出具体的条件是否成立。\n\n#### \t2.5、Cancel事件的产生：\n\n　　刚才我们说了事件一般有三个，Down、Move、Up，这三个事件比较好理解。其实还有一种事件就是Cancel事件。它代表什么含义呢？\n还是回到图6，如果一个Down事件产生了，这个Down事件从ViewGroupA传递到ViewGroupB，最终到达子View，被子View的onTouchEvent消费，return了true，那么此时Down事件就终止了。接下来后续的Move事件也会从ViewGroupA传递给ViewGroupB，也就是说ViewGroupA和ViewGroupB会比子View更先拿到Move事件，那既然ViewGroupA和ViewGroupB比子View更先拿到Move事件，那么他们当中的任何一个都有可能在某一个Move事件中，把这个Move事件给拦截下来，一旦Move事件被拦截下来了，子View肯定就拿不到这个Move事件了，不过，此时子View会产生一个新的事件，就是Cancel事件。\n\n\n　　所以一个正常的事件序列是 Down→Move→Up,这样才被认为是一个正常的事件序列。如果一个View响应的Down事件，可是却被没有正常结尾，Move事件或者Up事件被拦截了，此时非正常结尾的情况就会给子View产生一个新的事件Cancel。\n\n#### \t2.7、子控件可以影响父控件是否拦截的行为\n\n　　子控件是可以干预父控件是否拦截事件的结果。通过在子View中dispatchTouchEvent中增加一行代码即可。getParent().requestDisallowInterceptTouchEvent(true);这行代码就可以请求父控件不要拦截事件。\n\n\n　　很多人可能不太明白这句话的意思，既然事件一定是先到达父控件，然后才到达子View，那也就是getParent().requestDisallowInterceptTouchEvent(true);这句话是在父控件是否拦截判断结束之后才调用，怎么能改变父控件是否拦截的结果呢，这里存在一个执行先后顺序的疑惑。\n　　\n\n　　其实是这样的，getParent().requestDisallowInterceptTouchEvent(true);达到的效果不是修改父控件对本次事件是否拦截的结果，而影响的是后续事件。比如子View在Down事件中调用了getParent().requestDisallowInterceptTouchEvent(true);这行代码，那么在后续Move事件、Up事件产生到达父控件的时候，父控件就不会再拦截了。所以getParent().requestDisallowInterceptTouchEvent(true);只会影响Move事件和Up事件，影响不到Down事件。","tags":["Android"]},{"title":"Nexus 搭建私有maven仓库","url":"/2018/02/11/Nexus-搭建私有maven仓库/","content":"\n### 一、什么是Maven,Gradle?\n\n​\tMaven 是一个项目管理和自动构建工具。Maven 包集中存放的地方，就是 Maven 仓库。这些仓库，可以是放在本地，也可以放在某个远程服务器上。 可以是私有仓库，也可以是公开的。下开发用的库列表：\n\n```groovy\nmavenCentral();\njcenter()\nmaven {\n     url 'file:///Users/my-user-name/Documents/Android/repo/'\n}\nmaven {\n     url 'http://localhost:8081/nexus/content/repositories/releases/'\n}\n```\n\nAndroid Studio Gradle 主要支持两个 Maven 中央库：mavenCentral 和 jcenter。\n\nmavenCentral 是最早的 maven 中央仓库\njcenter 是 Android Studio 0.8 版本起的默认 maven 中央仓库\n第三个是我的本机的仓库\n第四个是笔者部署在内网服务器的私有仓库\n\n​\tGradle 是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML\n\n### 二、使用Nexus搭建maven私服\n\n1.Nexus 下载安装：\n\n​\t官网下载地址：http://www.sonatype.org/nexus/go/，我的开发环境是Windows，我下载的是Nexus Repository Manager OSS 2.xx下面的 All platforms nexus-2.14.10-01-bundle.zip压缩文件。\n\n2.Nexus 启动：\n\n​\t下载完成之后，解压后进入\\nexus-2.14.10-01-bundle\\bin\\jsw\\，根据操作系统类型选择文件夹，我选的是windows-x86-32文件夹，进入后可看到如下所示bat文件。 \n\n![start_select](Nexus-搭建私有maven仓库/start_select.png)\n\n​\t双击console-nexus.bat运行。再浏览器中输入[http://127.0.0.1:8081/nexus/，](http://127.0.0.1:8081/nexus/)出现下图所示就代表nexus已经启动成功了。\n\n![nexus_home](Nexus-搭建私有maven仓库/nexus_home.png)\n\n​\t8081是默认的端口号，要修改端口号，进入\\conf\\打开nexus.properties文件，修改application-port属性值就可以了。 \n默认的用户名和密码分别是：admin和admin123。点击右上角的log in 登录后如图所示： \n点击左侧的 repositories 查看现有的仓库列表： \n\n![maven_type](Nexus-搭建私有maven仓库/maven_type.png)\n\n3.Nexus仓库：\n这里的仓库分了四种类型\n\nhosted(宿主仓库):用来部署自己,第三方或者公共仓库的构件\n\nproxy(代理仓库):代理远程仓库\n\nvirtual(虚拟仓库):默认提供了一个 Central M1虚拟仓库 用来将maven 2适配为maven 1\n\ngroup(仓库组):统一管理多个仓库\n\n\n\nPublic Repositories: 仓库组\n\n3rd party: 无法从公共仓库获得的第三方发布版本的构件仓库\n\nApache Snapshots: 用了代理ApacheMaven仓库快照版本的构件仓库\n\nCentral: 用来代理maven中央仓库中发布版本构件的仓库\n\nCentral M1 shadow: 用于提供中央仓库中M1格式的发布版本的构件镜像仓库\n\nCodehaus Snapshots: 用来代理CodehausMaven 仓库的快照版本构件的仓库\n\nReleases: 用来部署管理内部的发布版本构件的宿主类型仓库\n\nSnapshots:用来部署管理内部的快照版本构件的宿主类型仓库\n\n4.建立Nexus宿主仓库\n\n​\t新建一个内部仓库，步骤为Repositories –> Add –> Hosted Repository，在页面的下半部分输入框中填入Repository ID和Repository Name即可，另外把Deployment Policy设置为Allow Redeploy，点击save就创建完成了。这里我点击添加宿主类型的仓库，在仓库列表的下方会出现新增仓库的配置，如下所示： \n\n![1001](Nexus-搭建私有maven仓库/1001.png)\n\n​\t建立好新的仓库之后需要配置一下相关账号信息.在安全选项下选择用户选项,可以看到三个默认的账号,分别是管理员账号,部署账号和Nexus账号.正常访问仓库内容的时候是不需要这三个账户的,一般也就是把部署账号暴露出去,方便仓库项目维护人员部署项目使用.所以这里可以用默认的Deployment账户(记得重置下密码).也可以新建一个账号来使用,新建的时候可以通过add role management来控制该账号的权限。 \n​\t点击新建的仓库的url可以直接如今仓库的路劲，因为现在还没有部署项目，所以是空的仓库。","tags":["Git","Maven"]},{"title":"Git命令速查手册","url":"/2018/01/29/Git命令速查手册/","content":"\n### 1、初始化仓库\n\n```java\ngit init\n```\n\n### 2、将文件添加到仓库\n\n```java\ngit add 文件名 # 将工作区的某个文件添加到暂存区   \n\ngit add -u # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，不处理untracked的文件\n\ngit add -A # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，包括untracked的文件\n\ngit add . # 将当前工作区的所有文件都加入暂存区\n\ngit add -i # 进入交互界面模式，按需添加文件到缓存区\n```\n\n\n\n### 3、将暂存区文件提交到本地仓库\n\n```\ngit commit -m \"提交说明\" # 将暂存区内容提交到本地仓库\n\ngit commit -a -m \"提交说明\" # 跳过缓存区操作，直接把工作区内容提交到本地仓库\n```\n\n\n\n### 4、查看仓库当前状态\n\n```\ngit status\n```\n\n\n\n### 5、比较文件异同\n\n```\ngit diff # 工作区与暂存区的差异\n\ngit diff 分支名 #工作区与某分支的差异，远程分支这样写：remotes/origin/分支名\n\ngit diff HEAD  # 工作区与HEAD指针指向的内容差异\n\ngit diff 提交id 文件路径 # 工作区某文件当前版本与历史版本的差异\n\ngit diff --stage # 工作区文件与上次提交的差异(1.6 版本前用 --cached)\n\ngit diff 版本TAG # 查看从某个版本后都改动内容\n\ngit diff 分支A 分支B # 比较从分支A和分支B的差异(也支持比较两个TAG)\n\ngit diff 分支A...分支B # 比较两分支在分开后各自的改动\n\n\\# 另外：如果只想统计哪些文件被改动，多少行被改动，可以添加 --stat 参数\n```\n\n\n\n### 6、查看历史记录\n\n```\ngit log # 查看所有commit记录(SHA-A校验和，作者名称，邮箱，提交时间，提交说明)\n\ngit log -p -次数 # 查看最近多少次的提交记录\n\ngit log --stat # 简略显示每次提交的内容更改\n\ngit log --name-only # 仅显示已修改的文件清单\n\ngit log --name-status # 显示新增，修改，删除的文件清单\n\ngit log --oneline # 让提交记录以精简的一行输出\n\ngit log –graph –all --online # 图形展示分支的合并历史\n\ngit log --author=作者  # 查询作者的提交记录(和grep同时使用要加一个--all--match参数)\n\ngit log --grep=过滤信息 # 列出提交信息中包含过滤信息的提交记录\n\ngit log -S查询内容 # 和--grep类似，S和查询内容间没有空格\n\ngit log fileName # 查看某文件的修改记录，找背锅专用\n```\n\n\n\n### 7、代码回滚\n\n```\ngit reset HEAD^ # 恢复成上次提交的版本\n\ngit reset HEAD^^ # 恢复成上上次提交的版本，就是多个^，以此类推或用~次数\n\ngit reflog\n\ngit reset --hard 版本号\n\n--soft：只是改变HEAD指针指向，缓存区和工作区不变；\n\n--mixed：修改HEAD指针指向，暂存区内容丢失，工作区不变；\n\n--hard：修改HEAD指针指向，暂存区内容丢失，工作区恢复以前状态；\n```\n\n\n\n### 8、同步远程仓库\n\n```\ngit push -u origin master\n```\n\n\n\n### 9、删除版本库文件\n\n```\ngit rm 文件名\n```\n\n\n\n### 10、版本库里的版本替换工作区的版本\n\n```\ngit checkout -- test.txt\n```\n\n\n\n### 11、本地仓库内容推送到远程仓库\n\n```\ngit remote add origin git@github.com:帐号名/仓库名.git\n```\n\n\n\n### 12、从远程仓库克隆项目到本地\n\n```\ngit clone git@github.com:git帐号名/仓库名.git\n```\n\n\n\n### 13、创建分支\n\n```\ngit checkout -b dev\n\n-b表示创建并切换分支\n\n上面一条命令相当于下面的二条：\n\ngit branch dev //创建分支\n\ngit checkout dev //切换分支\n```\n\n\n\n### 14、查看分支\n\n```\ngit branch\n```\n\n\n\n### 15、合并分支\n\n```\ngit merge dev\n\n//用于合并指定分支到当前分支\n\ngit merge --no-ff -m \"merge with no-ff\" dev\n\n//加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并\n```\n\n\n\n### 16、删除分支\n\n```\ngit branch -d dev\n```\n\n\n\n### 17、查看分支合并图\n\n```\ngit log --graph --pretty=oneline --abbrev-commit\n```\n\n\n\n### 18、查看远程库信息\n\n```\ngit remote\n\n// -v 显示更详细的信息\n```\n\n\n\n### 19、git相关配置\n\n\\\n\n```\n# 安装完Git后第一件要做的事，设置用户信息(global可换成local在单独项目生效)：\n\ngit config --global user.name \"用户名\" # 设置用户名\n\ngit config --global user.email \"用户邮箱\"   #设置邮箱\n\ngit config --global user.name   # 查看用户名是否配置成功\n\ngit config --global user.email   # 查看邮箱是否配置\n\n\\# 其他查看配置相关\n\ngit config --global --list  # 查看全局设置相关参数列表\n\ngit config --local --list # 查看本地设置相关参数列表\n\ngit config --system --list # 查看系统配置参数列表\n\ngit config --list  # 查看所有Git的配置(全局+本地+系统)\n\ngit config --global color.ui true //显示git相关颜色\n```\n\n\n\n### 20、撤消某次提交\n\n```\ngit revert HEAD # 撤销最近的一个提交\n\ngit revert 版本号 # 撤销某次commit\n```\n\n\n\n### 21、拉取远程分支到本地仓库\n\n```\ngit checkout -b 本地分支 远程分支 # 会在本地新建分支，并自动切换到该分支\n\ngit fetch origin 远程分支:本地分支 # 会在本地新建分支，但不会自动切换，还需checkout\n\ngit branch --set-upstream 本地分支 远程分支 # 建立本地分支与远程分支的链接\n```\n\n\n\n### 22、标签命令\n\n```\ngit tag 标签 //打标签命令，默认为HEAD\n\ngit tag //显示所有标签\n\ngit tag 标签 版本号 //给某个commit版本添加标签\n\ngit show 标签 //显示某个标签的详细信息\n```\n\n\n\n### 23、同步远程仓库更新\n\n```\ngit fetch  origin master\n\n//从远程获取最新的到本地，首先从远程的origin的master主分支下载最新的版本到origin/master分支上，然后比较本地的master分支和origin/master分支的差别，最后进行合并。\n\ngit fetch比git pull更加安全\n```\n\n","tags":["Git"]},{"title":"机器学习入门（一）","url":"/2018/01/25/机器学习入门（一）/","content":"\n\n\n# 机器学习入门\n\n## 一、定义\n\n使用算法解析数据，从中学习，然后对世界上的某件事情做出决定或预测\n\n机器学习是人工智能的一个分支。人工智能致力于创造出比人类更能完成复杂任务的机器。这些任务通常涉及判断、策略和认知推理，这些技能最初被认为是机器的“禁区”。虽然这听起来很简单，但这些技能的范围非常大——语言处理、图像识别、规划等等。\n\n## 二、分类\n\n1、监督学习\n\n监督学习涉及一组标记数据。计算机可以使用特定的模式来识别每种标记类型的新样本。监督学习的两种主要类型是分类和回归。在分类中，机器被训练成将一个组划分为特定的类。分类的一个简单例子是电子邮件帐户上的垃圾邮件过滤器。过滤器分析你以前标记为垃圾邮件的电子邮件，并将它们与新邮件进行比较。如果它们匹配一定的百分比，这些新邮件将被标记为垃圾邮件并发送到适当的文件夹。那些比较不相似的电子邮件被归类为正常邮件并发送到你的邮箱。\n      第二种监督学习是回归。在回归中，机器使用先前的(标记的)数据来预测未来。天气应用是回归的好例子。使用气象事件的历史数据(即平均气温、湿度和降水量)，你的手机天气应用程序可以查看当前天气，并在未来的时间内对天气进行预测。\n\n2、非监督学习\n      \n\n在无监督学习中，数据是无标签的。由于大多数真实世界的数据都没有标签，这些算法特别有用。无监督学习分为聚类和降维。聚类用于根据属性和行为对象进行分组。这与分类不同，因为这些组不是你提供的。聚类的一个例子是将一个组划分成不同的子组(例如，基于年龄和婚姻状况)，然后应用到有针对性的营销方案中。降维通过找到共同点来减少数据集的变量。大多数大数据可视化使用降维来识别趋势和规则。\n\n3、强化学习\n      \n\n强化学习使用机器的个人历史和经验来做出决定。强化学习的经典应用是玩游戏。与监督和非监督学习不同，强化学习不涉及提供“正确的”答案或输出。相反，它只关注性能。这反映了人类是如何根据积极和消极的结果学习的。很快就学会了不要重复这一动作。同样的道理，一台下棋的电脑可以学会不把它的国王移到对手的棋子可以进入的空间。然后，国际象棋的这一基本教训就可以被扩展和推断出来，直到机器能够打(并最终击败)人类顶级玩家为止。","tags":["人工智能","机器学习"]},{"title":"Android Studio Gradle详解","url":"/2018/01/18/Android-Studio-Gradle详解/","content":"\n## 1、AppExtension类及其属性\n### 1.1 基础介绍\n&emsp; &emsp;可能大部分人看到AppExtension类会感觉到非常的陌生，其实我们在app中的build.gradle中填写配置信息的时候，经常看到它，它是什么呢？\n&emsp; &emsp;如果你按ctrl+鼠标左键对着android{},点击进去就知道了，其实android{…}表示的就是AppExtension这个类。\n下图是AppExtension 继承关系\n![app](https://github.com/Alex0605/Alex0605.github.io/blob/master/img/gradle_lib.png)\n&emsp; &emsp;除了AppExtension之外还有2个类与之相似，LibraryExtension和TestExtension\n&emsp; &emsp;如果是module项目作为lib使用，那么lib下的build.gradle中的android对应的是LibraryExtension\n\n### 1.2 AppExtension的属性\n* aaptOptions：aapt是一个可以将资源文件编译成二进制文件的工具。aaptOptions表示  aapt工具设置的可选项参数。 \n* adbExecutable：adb从编译sdk时执行\n*  adbOptions：adb的可选项参数 \n*  applicationVariants：应用变体列表 \n*  buildToolsVersion：构建工具版本(必要的) \n*  buildTypes：构建类型(一般是release和debug，还可以自定义) \n*  compileOptions：编译可选项参数 \n*  compileSdkVersion：编译sdk版本(必要的) \n*  dataBinding：Data Binding可选项参数(关于DataBinding的使用) \n*  defualtConfig：默认配置，对于所有的打包项目 \n*  defualtPublishConfig：默认是release。\n*   dexOptions：Dex可选项参数。 \n*  externalNativeBuild：native编译支持。\n*  flavorDimensionList：\n*  generatePureSplits：是否拆成多个APK \n*  jacoco：JaCoCo可选项参数 \n*  lintOptions：Lint工具可选项参数\n*   ndkDirectory：ndk目录(一般在local.properties中) \n*  packagingOptions：packaging的可选参数 \n*  productFlavors：项目所有flavor \n*  publishNonDefualt：不仅仅使用默认的publish artifacts。可参defualtPublishConfig。              \n*  resourcePrefix：创建新资源时使用的前缀。 \n*  sdkDirectory：sdk目录(一般在local.properties中) \n*  signingConfigs：签名文件的可选项参数 \n*  sourceSets：资源文件目录指定(Android中有自己的AndroidSourceSets，这个一般用于assets，jin等目录) splits：splits类型。\n*   testBuildType：测试构建类型\n*   testOptions：测试可选项参数 \n*  testVariants：测试变体 \n*  unitTestVariants：单元测试变体 \n*  variantFilter：变体过滤器,加粗的表示DSL语言的闭包,如：\n```\nbuildTypes { }\n```\n\n\n### 1.3 AppExtension的闭包\n&emsp; &emsp;与app中build.gradle中android{}一样，代码中由AppExtension类表示。其他的配置闭包也一样。\n1、aaptOptions{}代码由AaptOptions类表示。\n\n```\nAaptOptions的属性：\nadditionalParameters:额外参数，List类型。\ncruncherEnabled：如果PNG图片是否可以大量快速的处理，boolean类型。 true表示可以。\ncruncherProcesses:快速处理，可能需要更多的内存和CPU。int类型。默认0，值越大处理越快，需要的内存和CPU也越大。\nfailOnMissingConfigEntry:如果没有找到一个配置，就返回一个错误。Boolean值，默认false。\nignoreAssetsPattern：忽略Assets模块。\nmoCompress：拓展文件不会打包进apk中。\n \n用法(详细用法可能需要去看看文档了)：\naaptOptions{\n    cruncherEnabled true//快速处理PNG图片\n}\n```\n\n2、adbOption{}\n```\nadbOptions{}对应的是AdbOptions\nAdbOptions的属性：\ninstallOptions：apk安装的可选参数。\ntimeOutInMs：使用adb的超时时间。\n```\n3、buildTypes{}\n```\nbuildTypes{}对应的是BuildType类\n \nbuildTypes的属性：\n \napplicationIdSuffix：应用id后缀(给Applica)\nconsumerProguardFiles：混淆文件包含在arr包中。\ndebuggable：是否生成一个debug的apk\nembedMicroApp：可穿戴设备app是否可以使用这个编译类型\njavaCompileOption：Java编译配置参数\njniDebuggable：这个编译类型的配置是否可以与debuggable的native代码生成一个apk\nmanifestPlaceholders：清单占位符\nminifyEnabled：是否缩小\nmultiDexEnabled：是否拆成多个Dex\nmultiDexKeepFile：指定文本文件编译进主Dex文件中\nmultiDexKeepProguard：指定混淆文件编译进主Dex文件中\nname：build type的名字\nproguardFiles：混淆文件\npseudoLocalesEnabled：是否生成伪现场apk(如果没有提供混淆规则文件，则设置默认的混淆规则文件（SDK/tools/proguard/proguard-android.txt）)\nrenderscriptDebuggable：使用RenderScript编译器的优化级别。\nshrinkResources：是否去除未利用的资源，默认false，表示不去除。\nsigningConfig：签名配置\ntestCoverageEnabled：测试覆盖率是否被激活。\nuseJack：过时\nversionNameSuffix：版本名称后缀\n zipAlignEnable：是否使用zipalign工具压缩。\n \n------------------------------------------------------\n \nbuildType的方法：\n \nbuildConfigField(type,name,value)：添加一个变量生成BuildConfig类。\nconsumeProguardFile(proguardFile)：添加一个混淆文件进arr包。\nconsumeProguardFile(proguardFiles)：添加混淆文件进arr包。\nexternalNativeBuild(action)：配置本地的build选项。\ninitWith：复制这个build类型的所有属性。\nproguardFile(proguardFile)：添加一个新的混淆配置文件。\nproguradFiles(files):添加新的混淆文件\nresValue(type,name,value)：添加一个新的生成资源\nsetProguardFiles(proguardFileIterable):设置一个混淆配置文件。\n------------------------------------------------------------\nbuildType用法：\n \n  buildTypes {\n        release {\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            shrinkResources true\n            zipAlignEnabled true\n            debuggable false\n            //...\n        }\n \n        debug{\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            shrinkResources true\n            zipAlignEnabled true\n            debuggable true\n            //...\n        }\n    }\n```\n\n\n4、compileOptions{}\n```\ncompileOptions{}对应的是CompileOptions\n\nCompileOptions的属性：\nencoding：Java源文件的编码格式\nincremental：是否应该使用Java编写的Gradle新的增量模型\nsourceCompatibility：指定编译编译.java文件的jdk版本\ntargetCompatibility：确保class文件与targetCompatibility指定版本，或者更新的java虚拟机兼容\n```\n5、dataBinding{}\n```\ndataBinding{}对应的是DataBindingOptions\n \n \nDataBindingOptions的属性：\n \naddDefualtAdapters：是否添加一个默认的data binding适配器。默认true。\nenabled：是否使用data binding\nversion：data binding使用版本\n \n \ndataBinding的使用：\n \ndataBinding{\n    enabled true\n}\n```\n\n\n6、defualtConfig{}\n```\ndefaultConfig{}是所有flavor都共有的配置。\n \n英文解释：The default configuration, inherited by all product flavors (if any are defined).\n \n \ndefaultConfig的使用：\n \n defaultConfig {\n        applicationId \"com.example.zhang.demo\"\n        minSdkVersion 15\n        targetSdkVersion 25\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n}\n```\n7、dexOptions{}\n```\ndexOptions{}对应的是DexOptions\n \nDexOptions属性:\n \nadditionalParameters：给dx添加一系列附加的参数\njavaMaxHeapSize：当调用dx时指定-Xmx值。\njumboMode：使用jumbo(庞大的)模式\nkeepRuntimeAnnotatedClasses：保持所有类中的运行时的注解在主Dex中。\nmaxProcessCount：可以使用Dex的最大并发进程数。默认为4。\noptimize：运行在dx编译器是否有optimize标记。\npreDexLibraries：是否预先dex库，它可以改善增量的生成，但是在clear build可能会变慢\nthreadCount：当dx运行时使用的线程的数量。默认4个。\n \n \ndexOptions{}的用法：\n \ndexOptions {\n    preDexLibraries  false\n    javaMaxHeapSize \"4g\"\n}\n```\n\n8、externalNativeBuild{}\n```\nexternalNativeBuild{}对应的是ExternalNativeBuild\n \nExternalNativeBuild的属性：\n \ncmake：CMake工具编译选项。\nndkBuild：ndk-build选项。\n \n \n在externalNativeBuild{}中有2个模块，cmake{}和ndkBuild{}模块\n \n------------------------------------------------\ncmake{}对应的是CmakeOptions\n \nCmakeOption的属性：\npath：你的CmakeLists.txt编译脚本的相对路径。\n \n--------------------------------------------------\nndkBuild{}对应的是NdkBuildOptions\n \nNdkBuildOptions的属性：\npath:你的Android.mk文件的相对路径。\n \n--------------------------------------------------\n \n \nexternalNativeBuild{}的用法：\n \nexternalNativeBuild{\n    ndkBuild{\n        path file(\"src\\\\main\\\\jni\\\\Android.mk\")\n    }\n \n    cmake {\n        path \"src/main/cpp/CMakeLists.txt\"\n    }\n}\n```\n\n9、jacoco{}\n```\njacoco{}对应于JacocoOptions\n \nJacocoOptions的属性：\n1.version：过时\n \n英文原文：\nnote: this property is deprecated and will be removed in a future version of the plugin.\n\n```\n10、lintOptions{}\n```\nlintOptions{}对应于LintOptions\n \n \nLintOptions的属性：\nabortOnError：如果发现错误，lint工具是否应该退出这个程序。true表示退出。\nabsolutePaths：是否在输出错误的时候，lint应该展示出全路径。默认是相对路径，也就是默认false。\ncheck：精确的检查(搜集)问题的集合，默认情况下，任何问题都可以通过LintOptions.getEnable()启用，没有问题可以通过LintOptions.getDisable()使之无效。\ncheckAllWarnings：是否检查所有警告，包括那些默认关闭。\ndisable：通过id's来压制这个问题，允许修改\nenable：通过id's来处理这个问题，循序修改，他会将添加id，并返回一个集合。\nexplainIssues：返回lint是否包含错误问题的解释(注意：HTML和XML报告会无条件的去做，忽略这个设置)。\nhtmlOutput：html输出方式。\nhtmlReport：我们应该是否写一个HTML报告，默认true， 这个使用场景由LintOptions.getHtmlOutput()控制。\nignoreWarings：lint仅仅检查错误，忽略警告。\nlintConfig：默认配置文件作为备份。\nnoLines：lint在输出错误日志的时候，是否包含行数。默认true。\nquiet：lint是否应该quiet(安静)。如：报告文件写入路径，不写消息。\nseverityOverrides：An optional map of severity overrides. The map maps from issue id's to the corresponding severity to use, which must be \"fatal\", \"error\", \"warning\", or \"ignore\".\nshowAll：lint是否包含所有的输出。\ntextOutput：文本输出方式。\ntextReport：是否是文本报告写入，默认false。\nwarningAsErrors：lint是否把警告当做错误来处理。\nxmlOutput：XML输出方式。\nxmlReport：XML格式写入报告，默认true。\n \n------------------------------------------------\n \nLintOptions的方法：\n \ncheck(id)：检查这个id的问题的集合\ncheck(ids)：\ndisable(id)：将id添加到不用启动的问题集\ndisable(ids)：\nenable(id)：将id添加到启动的问题集\nenable(ids)\nerror(id)：将id添加到错误的问题集\nerror(ids)\nfatal(id)：将id添加到fatal级别的问题集\nfatal(ids)\nignore(id)：将id添加到ignore级别的问题集\nignore(ids)\nwaring(id)：将id添加到waring级别的问题集\nwaring(ids)\n \n------------------------------------------------\n \nlintOptions{}的一般用法：\n \nlintOptions {\n    abortOnError false\n}\n```\n\n\n11、packagingOptions{}\n```\npackagingOptions{}对应的是PackagingOptions\nPackaging options有三组路径：first-picks，merges和excludes:\npackagingOptions{}的用法：\npackagingOptions {\n    pickFirsts = [] // Not really needed because the default is empty.\n    merges = []     // Not really needed because the default is empty.\n    excludes = []\n}\n```\n\n\n12、productFlavors{}\n```\nproductFlavors{}对应的是ProductFlavors\n \nProductFlavors的属性：\n \napplicationId：应用程序ID。\napplicationIdSuffix：应用程序ID后缀。\nconsumerProguardFiles：混淆规则文件被包含在aar包中。\ndimension：flavor名称的尺寸。\nexternalNativeBuild：详情见externalNativeBuild{}\nflavorDeminsion：过时\ngeneratedDensities：过时\njackOption：jack配置可选项。\njavaCompileOptions：Java编译配置参数\nmanifestPlaceholders：manifest占位符\nmultiDexEnabled：是否进行dex拆分\nmultiDexKeepFile：文本文件编译进主dex文件中。\nmultiDexKeepProgroud：文本文件作为混淆规则编译进主dex文件中\nndk：ndk配置\nproguardFiles:混淆文件\nsigningConfig：这个flavor的签名配置信息\ntestApplicationId：测试应用ID\ntestFunctionalTest：\ntestHandleProfiling：\ntestInstrumentationRunner：\ntestInstrumentionRunnerArguments：\nuseJack：过时\nverctorDrawables：生成矢量图支持\nversionCode：版本号\nversionName:版本名\nversionNameSuffix：版本名后缀\nwearAppUnbundled：是否对嵌入式穿戴app进行拆分模式。如果true，那么这个app将在应用市场被分发为穿戴设备的app。\n \nproductFlavor{}的用法：\nproductFlavors {\n \n        googlePlay {\n        }\n \n        xiaomi {\n        }\n}\n//所有打包配置（批量处理打包渠道--> manifestPlaceholders：设置打包渠道）\nproductFlavors.all {\n    //平台id\n    flavor -> flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]\n}\n```\n\n13、signingConfig{}\n\n```\nsigningConfig{}对应的是SigningConfig\n \nSigningConfig的属性：\n \nkeyAlias：签名使用key的别名\nKeyPassword：签名使用的key的密码\nstoreFile：store签名文件\nstorePassword：store签名密码\nstoreType：store签名类型\nSigningEnabled：是否使用jar签名(又名v1签名)。\nv2SigningEnabled：是否使用apk签名(又名v2签名)。\n \n \nsigningConfig{}的用法：\n \nsigningConfigs {\n    config {\n        keyAlias '...'\n        keyPassword '...'\n        storeFile file('C:/../Key.jks')\n        storePassword '...'\n    }\n}\n```\n14、sourceSets{}\n```\nsourceSets{}对应的AndroidSourceSet\n \nAndroidSourceSet的属性：\n \naidl：aidl目录\nassets：assets目录\ncompileConfiguraName：编译配置资源目录。\njava：java代码目录（需要编译成.class文件）\njni：jni资源目录\njniLibs：jni库目录\nmanifest：AndroidManifest.xml资源文件\nname：source set名称。\npackageConfigurationName：运行时配置的资源集。\nprovidedConfigurationName：仅仅编译时配置的资源集。\nrenderscript：RenderScript脚本资源目录\nres：Android资源目录\nresource：java资源被复制到输出到javaresource目录\n \nAndroidSourceSet的方法：\n1.setRoot(path)：资源集的根目录，所有的资源都在这个跟目录下。\n \nsourceSets{}的使用：\nsourceSets {\n    //在main目录中\n    main {\n        //assets目录设置\n        assets.srcDirs = ['assets']\n        //jni目录设置\n        jni.srcDirs 'src/main/jni'\n        //jni库设置\n        jniLibs.srcDir 'src/main/jniLibs'\n    }\n}\n```\n15、splits{}\n```\nsplits{}对应的是Splites\n \nSplits的属性：\n \nabi：ABI设置\nabiFilters：用于多个apk的ABI筛选列表\ndensity：密度设置\ndensityFilters：用于多个apk的密度筛选列表\nlanguage：语言设置。\nlanguageFilters：用于多个apk的语言筛选列表\n \n-----------------------------------------------------\n \n \nSpiltes对应有三个模块，abi{},density{},language{}\n \n \nabi{}对应的是AbiSplitOptions\n \nAbiSplitsOptions的属性：\napplicableFilters：返回此范围的所有适用筛选器的列表。\nenable：是否在这个范围分裂\nuniversalApk：是否创建所有可用的ABIs一个APK。\n \n \nAbiSplitesOptions的方法：\nexclude(excludes)：排除一些值。\ninclude(include)：包含一些值。\nreset()：重新设置split配置。\n \n----------------------------------------------------------\n \ndensity{}对应的是DensitySplitOptions\n \nDensitySplitOptions的属性：\napplicableFilters：返回此范围的所有适用筛选器的列表。\nauto：编译系统是否确定分割“language-*”文件夹中的资源。\ncompatibleScreen：兼容屏幕列表\nenable：是否拆分\n \n \nDensitySplitOptions的方法：\n1.exclude(exclude):排除一些值\n2.include(include):包含一些值\n3.reset()：重新设置split配置。\n \n \n-------------------------------------------------------\n \nlanguage{}对应的是LanguageSplitOptions\n \nLanguageSplitOptions的属性：\n1.enable：如果true，就是拆分language\n \n \nLanguageSplitOptions的方法：\n1.include(include)：包含一个模型。\n \n \n---------------------------------------------------------\n \nsplits{}的用法：\n \nsplits {\n    density {\n        enable true\n        exclude 'ldpi', 'mdpi'\n        compatibleScreens 'normal', 'large', 'xlarge'\n    }\n} \n \n生成结果：\napp-hdpi-release.apk\napp-universal-release.apk\napp-xhdpi-release.apk\napp-xxhdpi-release.apk\napp-xxxhdpi-release.apk\n \nsplits {\n    abi {\n      enable true\n      reset()\n      include 'x86', 'armeabi-v7a', 'mips'\n      universalApk true\n    }\n}\n这个就是生成不同手机架构的app\n```\n\n\n16、testOptions{}\n```\ntestOptions{}对应的是TestOptions\n \nTestOptions的属性：\n1.reportDir：报告目录\n2.resultDir：结果目录\n3.unitTests：单元测试配置参数\n \nTestOptions包含unitTests{}\n \n-------------------------------------------------------\n \nunitTests{}对应的是UnitTestOptions\n \nUnitTestOptions的属性：\n1.returnDefaultValues：无论unmocked方法从android.jar中抛出异常或是默认值（0或null）。\n \n \nUnitTestOtions的方法：\nall(configClosure)：配置所有单元测试任务。\n \n-------------------------------------------------\n \ntestOptions{}的使用：\n \ntestOptions {\n    resultsDir = \"$project.buildDir/foo/results\"\n}\n```\n### 1.4 AppExtension的方法\n- flavorDimensions(dimension):指定flavor名称\n- useLibraray(name)：请求使用一个lib库\n- useLibrary(name,required)：与上面解释一样。\n\n### 1.5 参考文档\n[1、BuildType官方文档](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.BuildType.html)\n\n[2、DataBinding详细用法](https://blog.csdn.net/qq_33689414/article/details/52205703)\n\n[3、Android Studio2.2 配置NDK](https://blog.csdn.net/jdh99/article/details/51765441)\n\n[4、Android studio 2.2 使用cmake编译NDK](https://blog.csdn.net/lmw21848/article/details/52183584)\n\n[5、Android Studio官方文档之使用Lint](https://blog.csdn.net/yishon_android/article/details/51864699)\n\n[6、PackagingOptions官方文档](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.PackagingOptions.html)\n\n[7、ProductFlavor官方文档](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.ProductFlavor.html)\n\n[8、APK-splite官方文档](http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits)\n\n[9、Splite官方文档](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.Splits.html)\n\n[10、AaptOptions官方](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.AaptOptions.html)","tags":["Android","Gradle"]}]