<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="江南E客的Blog">
    <meta name="keyword" content="腾讯">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        JDK源码阅读系列(二)--String类 - 江南E客的Blog | Z.Alex&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 你的努力要配的上你的野心 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.png">
        </div>
        <div class="name">
            <i>Z.Alex</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、String的定义"><span class="toc-text">1、String的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、字段属性"><span class="toc-text">2、字段属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、构造函数"><span class="toc-text">3、构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、长度和是否为空函数"><span class="toc-text">4、长度和是否为空函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、charAt、codePointAt类型函数"><span class="toc-text">5、charAt、codePointAt类型函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6、getChar、getBytes类型函数"><span class="toc-text">6、getChar、getBytes类型函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7、equal类函数-是否相等"><span class="toc-text">7、equal类函数(是否相等)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8、regionMatchs-方法"><span class="toc-text">8、regionMatchs()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9、compareTo类函数和CaseInsensitiveComparator静态内部类"><span class="toc-text">9、compareTo类函数和CaseInsensitiveComparator静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10、startWith、endWith类函数"><span class="toc-text">10、startWith、endWith类函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11、hashCode-函数"><span class="toc-text">11、hashCode()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12、indexOf、lastIndexOf类函数"><span class="toc-text">12、indexOf、lastIndexOf类函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13、substring-函数"><span class="toc-text">13、substring()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14、concat-函数"><span class="toc-text">14、concat()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15、replace、replaceAll类函数"><span class="toc-text">15、replace、replaceAll类函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16、matches-和contains-函数"><span class="toc-text">16、matches()和contains()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17、split-函数"><span class="toc-text">17、split()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18、join-函数"><span class="toc-text">18、join()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19、trim-函数"><span class="toc-text">19、trim()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20、toString-函数"><span class="toc-text">20、toString()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21、toCharArray-函数"><span class="toc-text">21、toCharArray()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22、toLowerCase-、toUpperCase-函数"><span class="toc-text">22、toLowerCase()、toUpperCase()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23、format-函数"><span class="toc-text">23、format()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24、valueOf类函数"><span class="toc-text">24、valueOf类函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25、intern-函数"><span class="toc-text">25、intern()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26、相关问题"><span class="toc-text">26、相关问题</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 你的努力要配的上你的野心 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        JDK源码阅读系列(二)--String类
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2017-10-19 20:28:13</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#Java" title="Java">Java</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#源码阅读" title="源码阅读">源码阅读</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <h4 id="1、String的定义"><a href="#1、String的定义" class="headerlink" title="1、String的定义"></a>1、String的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br></pre></td></tr></table></figure>
<p>重要点：</p>
<ul>
<li>String是一个final类，既不能被继承的类</li>
<li>String类实现了java.io.Serializable接口，可以实现序列化</li>
<li>String类实现了Comparable<string>，可以用于比较大小（按顺序比较单个字符的ASCII码）</string></li>
<li>String类实现了 CharSequence 接口，表示是一个有序字符的序列，因为String的本质是一个char类型数组</li>
</ul>
<h4 id="2、字段属性"><a href="#2、字段属性" class="headerlink" title="2、字段属性"></a>2、字段属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来存字符串,字符串的本质，是一个final的char型数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];                                         </span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存字符串的哈希</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash;  <span class="comment">// Default to 0                                </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现序列化的标识</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br></pre></td></tr></table></figure>
<p>重要点：</p>
<ul>
<li>private final char value[]<code>这是String字符串的本质，是一个字符集合，而且是</code>final的，是不可变的。</li>
</ul>
<h4 id="3、构造函数"><a href="#3、构造函数" class="headerlink" title="3、构造函数"></a>3、构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 01</span></span><br><span class="line"><span class="comment">* 这是一个经常会使用的String的无参构造函数.</span></span><br><span class="line"><span class="comment">* 默认将""空字符串的value赋值给实例对象的value，也是空字符</span></span><br><span class="line"><span class="comment">* 相当于深拷贝了空字符串""</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 02</span></span><br><span class="line"><span class="comment">* 这是一个有参构造函数，参数为一个String对象</span></span><br><span class="line"><span class="comment">* 将形参的value和hash赋值给实例对象作为初始化</span></span><br><span class="line"><span class="comment">* 相当于深拷贝了一个形参String对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 03</span></span><br><span class="line"><span class="comment">* 这是一个有参构造函数，参数为一个char字符数组</span></span><br><span class="line"><span class="comment">* 虽然我不知道为什么要Arrays.copyOf去拷贝，而不直接this.value = value;</span></span><br><span class="line"><span class="comment">* 意义就是通过字符数组去构建一个新的String对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 04</span></span><br><span class="line"><span class="comment">* 这是一个有参构造函数，参数为char字符数组,offset(起始位置，偏移量),count(个数)</span></span><br><span class="line"><span class="comment">* 作用就是在char数组的基础上，从offset位置开始计数count个，构成一个新的String的字符串</span></span><br><span class="line"><span class="comment">* 意义就类似于截取count个长度的字符集合构成一个新的String对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;        <span class="comment">//如果起始位置小于0，抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;     <span class="comment">//如果个数小于0，抛异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt;= value.length) &#123;      <span class="comment">//在count = 0的前提下，如果offset&lt;=len，则返回""</span></span><br><span class="line">            <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="comment">//如果起始位置&gt;字符数组长度 - 个数,则无法截取到count个字符，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt; value.length - count) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重点，从offset开始，截取到offset+count位置(不包括offset+count位置)</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 05</span></span><br><span class="line"><span class="comment">* 这是一个有参构造函数，参数为int字符数组,offset(起始位置，偏移量),count(个数)</span></span><br><span class="line"><span class="comment">* 作用跟04构造函数差不多，但是传入的不是char字符数组，而是int数组。</span></span><br><span class="line"><span class="comment">* 而int数组的元素则是字符对应的ASCII整数值</span></span><br><span class="line"><span class="comment">* 例子：new String(new int[]&#123;97,98,99&#125;,0,3);   output: abc</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">int</span>[] codePoints, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt;= codePoints.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt; codePoints.length - count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">    &#125;  </span><br><span class="line">	<span class="comment">//以上都是为了处理offset和count的正确性，如果有错，则抛异常</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> end = offset + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass 1: Compute precise size of char[]</span></span><br><span class="line">    <span class="keyword">int</span> n = count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = codePoints[i];</span><br><span class="line">        <span class="keyword">if</span> (Character.isBmpCodePoint(c))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Character.isValidCodePoint(c))</span><br><span class="line">            n++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Integer.toString(c));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//上面关于BMP什么的，我暂时也没看懂，猜想关于验证int数据的正确性，通过上面的测试就进入下面的算法</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// Pass 2: Allocate and fill in char[]</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">char</span>[] v = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset, j = <span class="number">0</span>; i &lt; end; i++, j++) &#123;  <span class="comment">//从offset开始，到offset + count</span></span><br><span class="line">        <span class="keyword">int</span> c = codePoints[i];</span><br><span class="line">        <span class="keyword">if</span> (Character.isBmpCodePoint(c))</span><br><span class="line">            v[j] = (<span class="keyword">char</span>)c;   <span class="comment">//将Int类型显式缩窄转换为char类型</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Character.toSurrogates(c, v, j++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.value = v; <span class="comment">//最后将得到的v赋值给String对象的value，完成初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****这里把被标记为过时的构造函数去掉了***/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 06</span></span><br><span class="line"><span class="comment">* 这是一个有参构造函数，参数为byte数组,offset(起始位置，偏移量),长度，和字符编码格式</span></span><br><span class="line"><span class="comment">* 就是传入一个byte数组，从offset开始截取length个长度，其字符编码格式为charsetName，如UTF-8</span></span><br><span class="line"><span class="comment">* 例子：new String(bytes, 2, 3, "UTF-8");</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charsetName"</span>);</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value = StringCoding.decode(charsetName, bytes, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 07</span></span><br><span class="line"><span class="comment">* 类似06</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, Charset charset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (charset == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charset"</span>);</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value =  StringCoding.decode(charset, bytes, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 08</span></span><br><span class="line"><span class="comment">* 这是一个有参构造函数，参数为byte数组和字符集编码</span></span><br><span class="line"><span class="comment">* 用charsetName的方式构建byte数组成一个String对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], String charsetName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(bytes, <span class="number">0</span>, bytes.length, charsetName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 09</span></span><br><span class="line"><span class="comment">* 类似08</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], Charset charset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(bytes, <span class="number">0</span>, bytes.length, charset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 10</span></span><br><span class="line"><span class="comment">* 这是一个有参构造函数，参数为byte数组,offset(起始位置，偏移量),length(个数)</span></span><br><span class="line"><span class="comment">* 通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value = StringCoding.decode(bytes, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 11</span></span><br><span class="line"><span class="comment">* 这是一个有参构造函数，参数为byte数组</span></span><br><span class="line"><span class="comment">* 通过使用平台默认字符集编码解码传入的byte数组，构造成一个String对象，不需要截取</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 12</span></span><br><span class="line"><span class="comment">* 有参构造函数，参数为StringBuffer类型</span></span><br><span class="line"><span class="comment">* 就是将StringBuffer构建成一个新的String,比较特别的就是这个方法有synchronized锁</span></span><br><span class="line"><span class="comment">* 同一时间只允许一个线程对这个buffer构建成String对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length()); <span class="comment">//使用拷贝的方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 13</span></span><br><span class="line"><span class="comment">* 有参构造函数，参数为StringBuilder</span></span><br><span class="line"><span class="comment">* 同12差不多，只不过是StringBuilder的版本，差别就是没有实现线程安全</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 14</span></span><br><span class="line"><span class="comment">* 这个构造函数比较特殊，有用的参数只有char数组value,是一个不对外公开的构造函数，没有访问修饰符</span></span><br><span class="line"><span class="comment">* 加入这个share的只是为了区分于String(char[] value)方法，用于重载，功能类似于03，我也在03表示过疑惑。</span></span><br><span class="line"><span class="comment">* 为什么提供这个方法呢，因为性能好，不需要拷贝。为什么不对外提供呢？因为对外提供会打破value为不变数组的限制。</span></span><br><span class="line"><span class="comment">* 如果对外提供这个方法让String与外部的value产生关联，如果修改外不的value，会影响String的value。所以不能</span></span><br><span class="line"><span class="comment">* 对外提供</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;</span><br><span class="line">    <span class="comment">// assert share : "unshared not supported";</span></span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码展示了总共14种构造方法，忽略了两种被标记为过时的构造方法：</p>
<ul>
<li>可以构造空字符串对象,既””</li>
<li>可以根据String,StringBuilder,StringBuffer构造字符串对象</li>
<li>可以根据char数组，其子数组构造字符串对象</li>
<li>可以根据int数组，其子数组构造字符串对象</li>
<li>可以根据某个字符集编码对byte数组，其子数组解码并构造字符串对象</li>
</ul>
<h4 id="4、长度和是否为空函数"><a href="#4、长度和是否为空函数" class="headerlink" title="4、长度和是否为空函数"></a>4、长度和是否为空函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;       <span class="comment">//所以String的长度就是一个value的长度</span></span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;  <span class="comment">//当char数组的长度为0，则代表String为"",空字符串</span></span><br><span class="line">    <span class="keyword">return</span> value.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、charAt、codePointAt类型函数"><a href="#5、charAt、codePointAt类型函数" class="headerlink" title="5、charAt、codePointAt类型函数"></a>5、charAt、codePointAt类型函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 返回String对象的char数组index位置的元素</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;   <span class="comment">//index不允许小于0，不允许大于等于String的长度</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> value[index]; <span class="comment">//返回</span></span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回String对象的char数组index位置的元素的ASSIC码(int类型)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Character.codePointAtImpl(value, index, value.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回index位置元素的前一个元素的ASSIC码(int型)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointBefore</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = index - <span class="number">1</span>;  <span class="comment">//获得index前一个元素的索引位置</span></span><br><span class="line">       <span class="keyword">if</span> ((i &lt; <span class="number">0</span>) || (i &gt;= value.length)) &#123; <span class="comment">//所以，index不能等于0，因为i = 0 - 1 = -1</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Character.codePointBeforeImpl(value, index, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 方法返回的是代码点个数，是实际上的字符个数,功能类似于length()</span></span><br><span class="line"><span class="comment">* 对于正常的String来说，length方法和codePointCount没有区别，都是返回字符个数。</span></span><br><span class="line"><span class="comment">* 但当String是Unicode类型时则有区别了。</span></span><br><span class="line"><span class="comment">* 例如：String str = “/uD835/uDD6B” (即使 'Z' ), length() = 2 ,codePointCount() = 1 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointCount</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span> || endIndex &gt; value.length || beginIndex &gt; endIndex) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 也是相对Unicode字符集而言的，从index索引位置算起，偏移codePointOffset个位置，返回偏移后的位置是多少</span></span><br><span class="line"><span class="comment">* 例如，index = 2 ,codePointOffset = 3 ，maybe返回 5 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">offsetByCodePoints</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> codePointOffset)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; value.length) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Character.offsetByCodePointsImpl(value, <span class="number">0</span>, value.length,</span><br><span class="line">               index, codePointOffset);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从上我们可以发现：</p>
<ul>
<li>只有一个charAt()是针对字符而言的，就是寻找第index位置的字符是什么，在面试的算法中也很常会用到<br>剩下都是有关ASCII、Unicode，等我之后深入学习之后再来修改更新这部分内容</li>
<li>ChatAt是实现CharSequence 而重写的方法，是一个有序字符集的方法</li>
</ul>
<h4 id="6、getChar、getBytes类型函数"><a href="#6、getChar、getBytes类型函数" class="headerlink" title="6、getChar、getBytes类型函数"></a>6、getChar、getBytes类型函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个不对外的方法，是给String内部调用的，因为它是没有访问修饰符的，只允许同一包下的类访问</span></span><br><span class="line"><span class="comment">* 参数：dst[]是目标数组，dstBegin是目标数组的偏移量，既要复制过去的起始位置(从目标数组的什么位置覆盖)</span></span><br><span class="line"><span class="comment">* 作用就是将String的字符数组value整个复制到dst字符数组中，在dst数组的dstBegin位置开始拷贝</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">       System.arraycopy(value, <span class="number">0</span>, dst, dstBegin, value.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 得到char字符数组，原理是getChars() 方法将一个字符串的字符复制到目标字符数组中。 </span></span><br><span class="line"><span class="comment">* 参数:srcBegin是原始字符串的起始位置,srcEnd是原始字符串要复制的字符末尾的后一个位置(既复制区域不包括srcEnd)</span></span><br><span class="line"><span class="comment">* dst[]是目标字符数组,dstBegin是目标字符的复制偏移量,复制的字符从目标字符数组的dstBegin位置开始覆盖。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;           <span class="comment">//如果srcBegin小于，抛异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">       &#125;</span><br><span class="line">   *    <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;  <span class="comment">//如果srcEnd大于字符串的长度，抛异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;      <span class="comment">//如果原始字符串其实位置大于末尾位置，抛异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">       &#125;</span><br><span class="line">       System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/****去除被标记过时的方法****/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获得charsetName编码格式的bytes数组</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName)</span><br><span class="line">           <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">       <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">return</span> StringCoding.encode(charsetName, value, <span class="number">0</span>, value.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 与上个方法类似，但charsetName和charset的区别，我还没搞定，搞懂来再更新</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(Charset charset) &#123;</span><br><span class="line">       <span class="keyword">if</span> (charset == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">return</span> StringCoding.encode(charset, value, <span class="number">0</span>, value.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用平台默认的编码格式获得bytes数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes() &#123;</span><br><span class="line">       <span class="keyword">return</span> StringCoding.encode(value, <span class="number">0</span>, value.length);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从上面，我们可以看出：</p>
<ul>
<li>getChars是没有返回值的，原理是通过System.arraycopy方法来实现的，不需要返回值。所以被覆盖的字符数组是需要具体存在的</li>
<li>getBytes是有返回值的</li>
</ul>
<h4 id="7、equal类函数-是否相等"><a href="#7、equal类函数-是否相等" class="headerlink" title="7、equal类函数(是否相等)"></a>7、equal类函数(是否相等)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String的equals方法，重写了Object的equals方法（区分大小写）</span></span><br><span class="line"><span class="comment">* 比较的是两个字符串的值是否相等</span></span><br><span class="line"><span class="comment">* 参数是一个Object对象，而不是一个String对象。这是因为重写的是Object的equals方法，所以是Object</span></span><br><span class="line"><span class="comment">* 如果是String自己独有的方法，则可以传入String对象，不用多此一举</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 实例：str1.equals(str2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;   <span class="comment">//首先判断形参str2是否跟当前对象str1是同一个对象，既比较地址是否相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;          <span class="comment">//如果地址相等，那么自然值也相等，毕竟是同一个字符串对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123; <span class="comment">//判断str2对象是否是一个String类型，过滤掉非String类型的比较</span></span><br><span class="line">            String anotherString = (String)anObject; <span class="comment">//如果是String类型，转换为String类型</span></span><br><span class="line">            <span class="keyword">int</span> n = value.length;                    <span class="comment">//获得当前对象str1的长度</span></span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;   <span class="comment">//比较str1的长度和str2的长度是否相等</span></span><br><span class="line">                                                     <span class="comment">//如是进入核心算法</span></span><br><span class="line">                <span class="keyword">char</span> v1[] = value;                   <span class="comment">//v1为当前对象str1的值，v2为参数对象str2的值</span></span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;                           <span class="comment">//就类似于for的int i =0的作用，因为这里使用while</span></span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;                   <span class="comment">//每次循环长度-1,直到长度消耗完，循环结束 </span></span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])              <span class="comment">//同索引位置的字符元素逐一比较</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;                <span class="comment">//只要有一个不相等，则返回false</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;                         <span class="comment">//如比较期间没有问题，则说明相等，返回true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 这也是一个String的equals方法，与上一个方法不用，该方法(不区分大小写)，从名字也能看出来</span></span><br><span class="line"><span class="comment">	* 是对String的equals方法的补充。</span></span><br><span class="line"><span class="comment">	* 这里参数这是一个String对象，而不是Object了，因为这是String本身的方法，不是重写谁的方法</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == anotherString) ? <span class="keyword">true</span>                   <span class="comment">//一样，先判断是否为同一个对象</span></span><br><span class="line">                : (anotherString != <span class="keyword">null</span>) </span><br><span class="line">                &amp;&amp; (anotherString.value.length == value.length) <span class="comment">//再判断长度是否相等</span></span><br><span class="line">               &amp;&amp; regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, anotherString, <span class="number">0</span>, value.length);  <span class="comment">//再执行regionMatchs方法 </span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 这是一个公有的比较方法，参数是StringBuffer类型</span></span><br><span class="line"><span class="comment">	* 实际调用的是contentEquals(CharSequence cs)方法，可以说是StringBuffer的特供版</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(StringBuffer sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contentEquals((CharSequence)sb);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 这是一个私有方法，特供给比较StringBuffer和StringBuilder使用的。</span></span><br><span class="line"><span class="comment">	* 比如在contentEquals方法中使用，参数是AbstractStringBuilder抽象类的子类</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">nonSyncContentEquals</span><span class="params">(AbstractStringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> v1[] = value;               <span class="comment">//当前String对象的值</span></span><br><span class="line">        <span class="keyword">char</span> v2[] = sb.getValue();       <span class="comment">//AbstractStringBuilder子类对象的值</span></span><br><span class="line">        <span class="keyword">int</span> n = v1.length;               <span class="comment">//后面就不说了，其实跟equals方法是一样的，只是少了一些判断</span></span><br><span class="line">        <span class="keyword">if</span> (n != sb.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v1[i] != v2[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 这是一个常用于String对象跟StringBuffer和StringBuilder比较的方法</span></span><br><span class="line"><span class="comment">	* 参数是StringBuffer或StringBuilder或String或CharSequence</span></span><br><span class="line"><span class="comment">	* StringBuffer和StringBuilder和String都实现了CharSequence接口</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(CharSequence cs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Argument is a StringBuffer, StringBuilder</span></span><br><span class="line">        <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> AbstractStringBuilder) &#123;   <span class="comment">//如果是AbstractStringBuilder抽象类或其子类</span></span><br><span class="line">            <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> StringBuffer) &#123;        <span class="comment">//如果是StringBuffer类型，进入同步块</span></span><br><span class="line">                <span class="keyword">synchronized</span>(cs) &#123;</span><br><span class="line">                   <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                 <span class="comment">//如果是StringBuilder类型，则进入非同步块</span></span><br><span class="line">                <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/***下面就是String和CharSequence类型的比较算法*****/</span></span><br><span class="line">        <span class="comment">// Argument is a String</span></span><br><span class="line">        <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> String) &#123;                    </span><br><span class="line">            <span class="keyword">return</span> equals(cs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Argument is a generic CharSequence</span></span><br><span class="line">        <span class="keyword">char</span> v1[] = value;</span><br><span class="line">        <span class="keyword">int</span> n = v1.length;</span><br><span class="line">        <span class="keyword">if</span> (n != cs.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v1[i] != cs.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码重点说明：</p>
<ul>
<li>equals()方法作为常用的方法，很具有层次感和借鉴意义，首先判断是否为同一个对象，再判断是否为要比较的类型，再判断两个对象的长度是否相等，首先从广的角度过滤筛选不符合的对象，再符合条件的对象基础上再一个一个字符的比较。</li>
<li>equalsIgnoreCase()方法是对equals()方法补充，不区分大小写的判断</li>
<li>contentEquals()则是用于String对象与4种类型的判断，通常用于跟StringBuilder和StringBuffer的判断,也是对equals方法的一个补充</li>
</ul>
<h4 id="8、regionMatchs-方法"><a href="#8、regionMatchs-方法" class="headerlink" title="8、regionMatchs()方法"></a>8、regionMatchs()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个类似于equals的方法，比较的是字符串的片段，也即是部分区域的比较</span></span><br><span class="line"><span class="comment">* toffset是当前字符串的比较起始位置(偏移量),other是要比较的String对象参数，ooffset是要参数String的比较片段起始位置，len是两个字符串要比较的片段的长度大小</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 例子：String str1 = "0123456",Str2 = "0123456789"; </span></span><br><span class="line"><span class="comment">* str1.regionMatchs(0,str2,0,6);意思是str1从0位置开始于str2的0位置开始比较6个长度的字符串片段</span></span><br><span class="line"><span class="comment">* 相等则返回 true,不等返回false </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span> ta[] = value;  <span class="comment">//当前对象的值</span></span><br><span class="line">       <span class="keyword">int</span> to = toffset;   <span class="comment">//当前对象的比较片段的起始位置，既偏移量</span></span><br><span class="line">       <span class="keyword">char</span> pa[] = other.value;  <span class="comment">//参数，既比较字符串的值</span></span><br><span class="line">       <span class="keyword">int</span> po = ooffset;         <span class="comment">//比较字符串的起始位置</span></span><br><span class="line">       <span class="comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">       <span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)  <span class="comment">//起始位置不小于0或起始位置不大于字符串长度 - 片段长度，大于就截取不到这么长的片段了</span></span><br><span class="line">               || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">               || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;      <span class="comment">//惊讶脸，居然不是抛异常，而是返回false</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;               <span class="comment">//使用while循环，当然也可以使for循环</span></span><br><span class="line">           <span class="keyword">if</span> (ta[to++] != pa[po++]) &#123;   <span class="comment">//片段区域的字符元素逐个比较</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这个跟上面的方法一样，只不过多了一个参数，既ignoreCase,既是否为区分大小写。</span></span><br><span class="line"><span class="comment">* 是equalsIgnoreCase()方法的片段比较版本，实际上equalsIgnoreCase()也是调用regionMatches函数</span></span><br><span class="line"><span class="comment">*/</span>	</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset,</span></span></span><br><span class="line"><span class="function"><span class="params">           String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span> ta[] = value;</span><br><span class="line">       <span class="keyword">int</span> to = toffset;</span><br><span class="line">       <span class="keyword">char</span> pa[] = other.value;</span><br><span class="line">       <span class="keyword">int</span> po = ooffset;</span><br><span class="line">       <span class="comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">       <span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)</span><br><span class="line">               || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">               || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//上面的解释同上</span></span><br><span class="line">       <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">char</span> c1 = ta[to++];</span><br><span class="line">           <span class="keyword">char</span> c2 = pa[po++];</span><br><span class="line">           <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (ignoreCase) &#123;   <span class="comment">//当ignoreCase为true时，既忽视大小写时</span></span><br><span class="line">               <span class="comment">// If characters don't match but case may be ignored,</span></span><br><span class="line">               <span class="comment">// try converting both characters to uppercase.</span></span><br><span class="line">               <span class="comment">// If the results match, then the comparison scan should</span></span><br><span class="line">               <span class="comment">// continue.</span></span><br><span class="line">               <span class="keyword">char</span> u1 = Character.toUpperCase(c1);   <span class="comment">//片段中每个字符转换为大写</span></span><br><span class="line">               <span class="keyword">char</span> u2 = Character.toUpperCase(c2);</span><br><span class="line">               <span class="keyword">if</span> (u1 == u2) &#123; <span class="comment">//大写比较一次，如果相等则不执行下面的语句，进入下一个循环</span></span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Unfortunately, conversion to uppercase does not work properly</span></span><br><span class="line">               <span class="comment">// for the Georgian alphabet, which has strange rules about case</span></span><br><span class="line">               <span class="comment">// conversion.  So we need to make one last check before</span></span><br><span class="line">               <span class="comment">// exiting.</span></span><br><span class="line">               <span class="keyword">if</span> (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123;</span><br><span class="line">                <span class="comment">//每个字符换行成小写比较一次</span></span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>从上可以看出：</strong></p>
<ul>
<li>片段比较时针对String对象的。所以如果你要跟StringBuffer和StringBuilder比较，那么记得toString.</li>
<li>如果你要进行两个字符串之间的片段比较的话，就可以使用regionMatches，如果是完整的比较那么就equals吧</li>
</ul>
<h4 id="9、compareTo类函数和CaseInsensitiveComparator静态内部类"><a href="#9、compareTo类函数和CaseInsensitiveComparator静态内部类" class="headerlink" title="9、compareTo类函数和CaseInsensitiveComparator静态内部类"></a>9、compareTo类函数和CaseInsensitiveComparator静态内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个比较字符串中字符大小的函数，因为String实现了Comparable&lt;String&gt;接口,所以重写了compareTo方法</span></span><br><span class="line"><span class="comment">* Comparable是排序接口。若一个类实现了Comparable接口，就意味着该类支持排序。</span></span><br><span class="line"><span class="comment">* 实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。</span></span><br><span class="line"><span class="comment">* 参数是需要比较的另一个String对象</span></span><br><span class="line"><span class="comment">* 返回的int类型，正数为大，负数为小，是基于字符的ASSIC码比较的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len1 = value.length;                  <span class="comment">//当前对象的长度</span></span><br><span class="line">       <span class="keyword">int</span> len2 = anotherString.value.length;    <span class="comment">//比较对象的长度</span></span><br><span class="line">       <span class="keyword">int</span> lim = Math.min(len1, len2);           <span class="comment">//获得最小长度</span></span><br><span class="line">       <span class="keyword">char</span> v1[] = value;                        <span class="comment">//获得当前对象的值</span></span><br><span class="line">       <span class="keyword">char</span> v2[] = anotherString.value;          <span class="comment">//获得比较对象的值</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> k = <span class="number">0</span>;                                <span class="comment">//相当于for的int k = 0,就是为while循环的数组服务的</span></span><br><span class="line">       <span class="keyword">while</span> (k &lt; lim) &#123;        <span class="comment">//当当前索引小于两个字符串中较短字符串的长度时，循环继续</span></span><br><span class="line">           <span class="keyword">char</span> c1 = v1[k];          <span class="comment">//获得当前对象的字符</span></span><br><span class="line">           <span class="keyword">char</span> c2 = v2[k];          <span class="comment">//获得比较对象的字符</span></span><br><span class="line">           <span class="keyword">if</span> (c1 != c2) &#123;           <span class="comment">//从前向后遍历，只要其实一个不相等，返回字符ASSIC的差值,int类型</span></span><br><span class="line">               <span class="keyword">return</span> c1 - c2;</span><br><span class="line">           &#125;</span><br><span class="line">           k++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> len1 - len2;           <span class="comment">//如果两个字符串同样位置的索引都相等，返回长度差值，完全相等则为0</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  这时一个类似compareTo功能的方法，但是不是comparable接口的方法，是String本身的方法</span></span><br><span class="line"><span class="comment">*  使用途径，我目前只知道可以用来不区分大小写的比较大小，但是不知道如何让它被工具类Collections和Arrays运用</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> CASE_INSENSITIVE_ORDER.compare(<span class="keyword">this</span>, str);</span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这是一个饿汉单例模式，是String类型的一个不区分大小写的比较器</span></span><br><span class="line"><span class="comment">   * 提供给Collections和Arrays的sort方法使用</span></span><br><span class="line"><span class="comment">   * 例如：Arrays.sort(strs,String.CASE_INSENSITIVE_ORDER);</span></span><br><span class="line"><span class="comment">   * 效果就是会将strs字符串数组中的字符串对象进行忽视大小写的排序</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class="line">                                        = <span class="keyword">new</span> CaseInsensitiveComparator();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这一个私有的静态内部类，只允许String类本身调用</span></span><br><span class="line"><span class="comment">* 实现了序列化接口和比较器接口，comparable接口和comparator是有区别的</span></span><br><span class="line"><span class="comment">* 重写了compare方法，该静态内部类实际就是一个String类的比较器</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveComparator</span></span></span><br><span class="line"><span class="class">           <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">       <span class="comment">// use serialVersionUID from JDK 1.2.2 for interoperability</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8575799808933029326L</span>;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> n1 = s1.length();                 <span class="comment">//s1字符串的长度</span></span><br><span class="line">           <span class="keyword">int</span> n2 = s2.length();                 <span class="comment">//s2字符串的长度</span></span><br><span class="line">           <span class="keyword">int</span> min = Math.min(n1, n2);           <span class="comment">//获得最小长度 </span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">               <span class="keyword">char</span> c1 = s1.charAt(i);           <span class="comment">//逐一获得字符串i位置的字符</span></span><br><span class="line">               <span class="keyword">char</span> c2 = s2.charAt(i);</span><br><span class="line">               <span class="keyword">if</span> (c1 != c2) &#123;                   <span class="comment">//部分大小写比较一次</span></span><br><span class="line">                   c1 = Character.toUpperCase(c1);    <span class="comment">//转换大写比较一次</span></span><br><span class="line">                   c2 = Character.toUpperCase(c2);</span><br><span class="line">                   <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                       c1 = Character.toLowerCase(c1);  <span class="comment">//转换小写比较一次</span></span><br><span class="line">                       c2 = Character.toLowerCase(c2);</span><br><span class="line">                       <span class="keyword">if</span> (c1 != c2) &#123;                  <span class="comment">//返回字符差值</span></span><br><span class="line">                           <span class="comment">// No overflow because of numeric promotion</span></span><br><span class="line">                           <span class="keyword">return</span> c1 - c2;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> n1 - n2;  <span class="comment">//如果字符相等，但是长度不等，则返回长度差值，短的教小，所以小-大为负数</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/** Replaces the de-serialized object. */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> CASE_INSENSITIVE_ORDER; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码可以看出：</p>
<ul>
<li>以上的最大问题可以能就是为什么要有个静态内部类，为什么实现了compareTo又有compare，移步到下面，有解答</li>
<li>String实现了comparable接口，重写了compareTo方法，可以用于自己写类进行判断排序，也可以使用collections，Arrays工具类的sort进行排序。只有集合或数组中的元素实现了comparable接口，并重写了compareTo才能使用工具类排序。</li>
<li>CASE_INSENSITIVE_ORDER是一个单例，是String提供为外部的比较器，该比较器的作用是忽视大小写进行比较，我们可以通过Collections或Arrays的sort方法将CASE_INSENSITIVE_ORDER比较器作为参数传入，进行排序。</li>
</ul>
<h4 id="10、startWith、endWith类函数"><a href="#10、startWith、endWith类函数" class="headerlink" title="10、startWith、endWith类函数"></a>10、startWith、endWith类函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 作用就是当前对象[toffset,toffset + prefix.value.lenght]区间的字符串片段等于prefix</span></span><br><span class="line"><span class="comment">* 也可以说当前对象的toffset位置开始是否以prefix作为前缀</span></span><br><span class="line"><span class="comment">* prefix是需要判断的前缀字符串，toffset是当前对象的判断起始位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span> ta[] = value;     <span class="comment">//获得当前对象的值</span></span><br><span class="line">       <span class="keyword">int</span> to = toffset;      <span class="comment">//获得需要判断的起始位置，偏移量</span></span><br><span class="line">       <span class="keyword">char</span> pa[] = prefix.value; <span class="comment">//获得前缀字符串的值</span></span><br><span class="line">       <span class="keyword">int</span> po = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> pc = prefix.value.length;</span><br><span class="line">       <span class="comment">// Note: toffset might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">       <span class="keyword">if</span> ((toffset &lt; <span class="number">0</span>) || (toffset &gt; value.length - pc)) &#123;  <span class="comment">//偏移量不能小于0且能截取pc个长度</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//不能则返回false</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (--pc &gt;= <span class="number">0</span>) &#123;                  <span class="comment">//循环pc次，既prefix的长度</span></span><br><span class="line">           <span class="keyword">if</span> (ta[to++] != pa[po++]) &#123;      <span class="comment">//每次比较当前对象的字符串的字符是否跟prefix一样</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;                <span class="comment">//一样则pc--,to++,po++,有一个不同则返回false</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//没有不一样则返回true，当前对象是以prefix在toffset位置做为开头</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断当前字符串对象是否以字符串prefix起头</span></span><br><span class="line"><span class="comment">* 是返回true,否返回fasle</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> startsWith(prefix, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断当前字符串对象是否以字符串prefix结尾</span></span><br><span class="line"><span class="comment">* 是返回true,否返回fasle</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//suffix是需要判断是否为尾部的字符串。</span></span><br><span class="line">    <span class="comment">//value.length - suffix.value.length是suffix在当前对象的起始位置</span></span><br><span class="line">       <span class="keyword">return</span> startsWith(suffix, value.length - suffix.value.length); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>endsWith的实现也是startWith()，作用就是判断前后缀</li>
</ul>
<h4 id="11、hashCode-函数"><a href="#11、hashCode-函数" class="headerlink" title="11、hashCode()函数"></a>11、hashCode()函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是String字符串重写了Object类的hashCode方法。</span></span><br><span class="line"><span class="comment"> * 给由哈希表来实现的数据结构来使用，比如String对象要放入HashMap中。</span></span><br><span class="line"><span class="comment"> * 如果没有重写HashCode，或HaseCode质量很差则会导致严重的后果，既不靠谱的后果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> h = hash;  <span class="comment">//hash是属性字段，是成员变量，所以默认为0</span></span><br><span class="line">      <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123; <span class="comment">//如果hash为0，且字符串对象长度大于0，不为""</span></span><br><span class="line">          <span class="keyword">char</span> val[] = value;   <span class="comment">//获得当前对象的值</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//重点，String的哈希函数</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;  <span class="comment">//遍历len次</span></span><br><span class="line">              h = <span class="number">31</span> * h + val[i];         <span class="comment">//每次都是31 * 每次循环获得的h +第i个字符的ASSIC码</span></span><br><span class="line">          &#125;</span><br><span class="line">          hash = h;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> h;  <span class="comment">//由此可见""空字符对象的哈希值为0</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>所以我们可以知道：</p>
<ul>
<li>hashCode的重点就是哈希函数</li>
<li>String的哈希函数就是循环len次，每次循环体为 <code>31 * 每次循环获得的hash + 第i次循环的字符</code></li>
</ul>
<h4 id="12、indexOf、lastIndexOf类函数"><a href="#12、indexOf、lastIndexOf类函数" class="headerlink" title="12、indexOf、lastIndexOf类函数"></a>12、indexOf、lastIndexOf类函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回cn对应的字符在字符串中第一次出现的位置，从字符串的索引0位置开始遍历</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(ch, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * index方法就是返回ch字符第一次在字符串中出现的位置</span></span><br><span class="line"><span class="comment"> * 既从fromIndex位置开始查找，从头向尾遍历，ch整数对应的字符在字符串中第一次出现的位置</span></span><br><span class="line"><span class="comment"> * -1代表字符串没有这个字符，整数代表字符第一次出现在字符串的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> max = value.length; <span class="comment">//获得字符串对象的长度</span></span><br><span class="line">       <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;             <span class="comment">//如果偏移量小于0，则代表偏移量为0，校正偏移量</span></span><br><span class="line">           fromIndex = <span class="number">0</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromIndex &gt;= max) &#123;   <span class="comment">//如果偏移量大于最大长度，则返回-1，代表没有字符串没有ch对应的字符</span></span><br><span class="line">           <span class="comment">// Note: fromIndex might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; <span class="comment">//emmm,这个判断，不懂</span></span><br><span class="line">           <span class="comment">// handle most cases here (ch is a BMP code point or a</span></span><br><span class="line">           <span class="comment">// negative value (invalid code point))</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;             <span class="comment">//获得字符串值</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt; max; i++) &#123;      <span class="comment">//从fromIndex位置开始向后遍历</span></span><br><span class="line">               <span class="keyword">if</span> (value[i] == ch) &#123;                    <span class="comment">//只有字符串中的某个位置的元素等于ch</span></span><br><span class="line">                   <span class="keyword">return</span> i;                            <span class="comment">//返回对应的位置，函数结束，既第一次出现的位置</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//如果没有出现，则返回-1</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> indexOfSupplementary(ch, fromIndex);  <span class="comment">//emmm,紧紧接着没看懂的地方</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOfSupplementary</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Character.isValidCodePoint(ch)) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span> hi = Character.highSurrogate(ch);</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span> lo = Character.lowSurrogate(ch);</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> max = value.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt; max; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (value[i] == hi &amp;&amp; value[i + <span class="number">1</span>] == lo) &#123;</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从尾部向头部遍历，返回cn第一次出现的位置，value.length - 1就是起点 </span></span><br><span class="line"><span class="comment">* 为了理解，我们可以认为是返回cn对应的字符在字符串中最后出现的位置</span></span><br><span class="line"><span class="comment">*  </span></span><br><span class="line"><span class="comment">* ch是字符对应的整数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lastIndexOf(ch, value.length - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从尾部向头部遍历，从fromIndex开始作为起点，返回ch对应字符第一次在字符串出现的位置</span></span><br><span class="line"><span class="comment">* 既从头向尾遍历，返回cn对应字符在字符串中最后出现的一次位置，fromIndex为结束点</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123;  <span class="comment">//之后不解释了,emmmmmmm</span></span><br><span class="line">           <span class="comment">// handle most cases here (ch is a BMP code point or a</span></span><br><span class="line">           <span class="comment">// negative value (invalid code point))</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">           <span class="comment">//取最小值，作用就是校正，如果fromIndex传大了，就当时len - 1</span></span><br><span class="line">           <span class="keyword">int</span> i = Math.min(fromIndex, value.length - <span class="number">1</span>);   </span><br><span class="line">           <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;      <span class="comment">//算法中是从后向前遍历，直到i&lt;0,退出循环</span></span><br><span class="line">               <span class="keyword">if</span> (value[i] == ch) &#123;  <span class="comment">//只有有相等，返回对应的索引位置</span></span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;   <span class="comment">//没有找到则返回-1</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> lastIndexOfSupplementary(ch, fromIndex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lastIndexOfSupplementary</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Character.isValidCodePoint(ch)) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">           <span class="keyword">char</span> hi = Character.highSurrogate(ch);</span><br><span class="line">           <span class="keyword">char</span> lo = Character.lowSurrogate(ch);</span><br><span class="line">           <span class="keyword">int</span> i = Math.min(fromIndex, value.length - <span class="number">2</span>);</span><br><span class="line">           <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">               <span class="keyword">if</span> (value[i] == hi &amp;&amp; value[i + <span class="number">1</span>] == lo) &#123;</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回第一次出现的字符串的位置</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(str, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 从fromIndex开始遍历，返回第一次出现str字符串的位置</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(value, <span class="number">0</span>, value.length,</span><br><span class="line">               str.value, <span class="number">0</span>, str.value.length, fromIndex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个不对外公开的静态函数</span></span><br><span class="line"><span class="comment">* source就是原始字符串，sourceOffset就是原始字符串的偏移量，起始位置。</span></span><br><span class="line"><span class="comment">* sourceCount就是原始字符串的长度，target就是要查找的字符串。</span></span><br><span class="line"><span class="comment">* fromIndex就是从原始字符串的第fromIndex开始遍历</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           String target, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(source, sourceOffset, sourceCount,</span><br><span class="line">                      target.value, <span class="number">0</span>, target.value.length,</span><br><span class="line">                      fromIndex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 同是一个不对外公开的静态函数</span></span><br><span class="line"><span class="comment">* 比上更为强大。</span></span><br><span class="line"><span class="comment">* 多了一个targetOffset和targetCount，既代表别查找的字符串也可以被切割</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;   <span class="comment">//如果查找的起点大于当前对象的大小</span></span><br><span class="line">        <span class="comment">//如果目标字符串的长度为0，则代表目标字符串为""，""在任何字符串都会出现</span></span><br><span class="line">        <span class="comment">//配合fromIndex &gt;= sourceCount,所以校正第一次出现在最尾部，仅仅是校正作用</span></span><br><span class="line">           <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>); </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;  <span class="comment">//也是校正，如果起始点小于0，则返回0</span></span><br><span class="line">           fromIndex = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123; <span class="comment">//如果目标字符串长度为0，代表为""，则第一次出现在遍历起始点fromIndex</span></span><br><span class="line">           <span class="keyword">return</span> fromIndex;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">char</span> first = target[targetOffset];   <span class="comment">//目标字符串的第一个字符</span></span><br><span class="line">       <span class="keyword">int</span> max = sourceOffset + (sourceCount - targetCount); <span class="comment">//最大遍历次数</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">           <span class="comment">/* Look for first character. */</span></span><br><span class="line">           <span class="keyword">if</span> (source[i] != first) &#123;</span><br><span class="line">               <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Found first character, now look at the rest of v2 */</span></span><br><span class="line">           <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">               <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</span><br><span class="line">                       == target[k]; j++, k++);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                   <span class="comment">/* Found whole string. */</span></span><br><span class="line">                   <span class="keyword">return</span> i - sourceOffset;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查找字符串Str最后一次出现的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lastIndexOf(str, value.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lastIndexOf(value, <span class="number">0</span>, value.length,</span><br><span class="line">               str.value, <span class="number">0</span>, str.value.length, fromIndex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           String target, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lastIndexOf(source, sourceOffset, sourceCount,</span><br><span class="line">                      target.value, <span class="number">0</span>, target.value.length,</span><br><span class="line">                      fromIndex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Check arguments; return immediately where possible. For</span></span><br><span class="line"><span class="comment">        * consistency, don't check for null str.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">int</span> rightIndex = sourceCount - targetCount;</span><br><span class="line">       <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (fromIndex &gt; rightIndex) &#123;</span><br><span class="line">           fromIndex = rightIndex;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* Empty string always matches. */</span></span><br><span class="line">       <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> fromIndex;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> strLastIndex = targetOffset + targetCount - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">char</span> strLastChar = target[strLastIndex];</span><br><span class="line">       <span class="keyword">int</span> min = sourceOffset + targetCount - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> i = min + fromIndex;</span><br><span class="line">       </span><br><span class="line">   startSearchForLastChar:</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           <span class="keyword">while</span> (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123;</span><br><span class="line">               i--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (i &lt; min) &#123;</span><br><span class="line">               <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> start = j - (targetCount - <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">int</span> k = strLastIndex - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span> (j &gt; start) &#123;</span><br><span class="line">               <span class="keyword">if</span> (source[j--] != target[k--]) &#123;</span><br><span class="line">                   i--;</span><br><span class="line">                   <span class="keyword">continue</span> startSearchForLastChar;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> start - sourceOffset + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只对外提供了int整形，String字符串两种参数的重载方法(虽然是Int型，其实我们就当做是传char也无所谓，因为虚拟机会帮我们解决这个事情的)</li>
</ul>
<h4 id="13、substring-函数"><a href="#13、substring-函数" class="headerlink" title="13、substring()函数"></a>13、substring()函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  截取当前字符串对象的片段，组成一个新的字符串对象</span></span><br><span class="line"><span class="comment">*  beginIndex为截取的初始位置，默认截到len - 1位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;   <span class="comment">//小于0抛异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> subLen = value.length - beginIndex;  <span class="comment">//新字符串的长度</span></span><br><span class="line">       <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;       <span class="comment">//小于0抛异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果beginIndex是0，则不用截取，返回自己(非新对象)，否则截取0到subLen位置，不包括(subLen)</span></span><br><span class="line">       <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 截取一个区间范围</span></span><br><span class="line"><span class="comment">* [beginIndex,endIndex)，不包括endIndex</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line">       <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="keyword">this</span></span><br><span class="line">               : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.substring(beginIndex, endIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="14、concat-函数"><a href="#14、concat-函数" class="headerlink" title="14、concat()函数"></a>14、concat()函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String的拼接函数</span></span><br><span class="line"><span class="comment">* 例如:String  str = "abc"; str.concat("def")    output: "abcdef"</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> otherLen = str.length();<span class="comment">//获得参数字符串的长度</span></span><br><span class="line">       <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123; <span class="comment">//如果长度为0，则代表不需要拼接，因为str为""</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">/****重点****/</span></span><br><span class="line">       <span class="keyword">int</span> len = value.length;  <span class="comment">//获得当前对象的长度 </span></span><br><span class="line">       <span class="comment">//将数组扩容，将value数组拷贝到buf数组中，长度为len + str.lenght</span></span><br><span class="line">       <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen); </span><br><span class="line">       str.getChars(buf, len);<span class="comment">//然后将str字符串从buf字符数组的len位置开始覆盖,得到一个完整的buf字符数组</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);<span class="comment">//构建新的String对象，调用私有的String构造方法</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="15、replace、replaceAll类函数"><a href="#15、replace、replaceAll类函数" class="headerlink" title="15、replace、replaceAll类函数"></a>15、replace、replaceAll类函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换，将字符串中的oldChar字符全部替换成newChar</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (oldChar != newChar) &#123;    <span class="comment">//如果旧字符不等于新字符的情况下</span></span><br><span class="line">           <span class="keyword">int</span> len = value.length;  <span class="comment">//获得字符串长度</span></span><br><span class="line">           <span class="keyword">int</span> i = -<span class="number">1</span>;              <span class="comment">//flag</span></span><br><span class="line">           <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span> (++i &lt; len) &#123;      <span class="comment">//循环len次</span></span><br><span class="line">               <span class="keyword">if</span> (val[i] == oldChar) &#123; <span class="comment">//找到第一个旧字符，打断循环</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (i &lt; len) &#123;   <span class="comment">//如果第一个旧字符的位置小于len</span></span><br><span class="line">               <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len]; 新<span class="keyword">new</span>一个字符数组，len个长度</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                   buf[j] = val[j];        把旧字符的前面的字符都复制到新字符数组上</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">while</span> (i &lt; len) &#123;           <span class="comment">//从i位置开始遍历</span></span><br><span class="line">                   <span class="keyword">char</span> c = val[i];</span><br><span class="line">                   buf[i] = (c == oldChar) ? newChar : c; <span class="comment">//发生旧字符就替换，不想关的则直接复制</span></span><br><span class="line">                   i++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);  <span class="comment">//通过新字符数组buf重构一个新String对象</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;  <span class="comment">//如果old = new ，直接返回自己</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//替换第一个旧字符</span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceFirst(replacement);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//当不是正规表达式时，与replace效果一样，都是全体换。如果字符串的正则表达式，则规矩表达式全体替换</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceAll(replacement);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//可以用旧字符串去替换新字符串</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Pattern.compile(target.toString(), Pattern.LITERAL).matcher(</span><br><span class="line">               <span class="keyword">this</span>).replaceAll(Matcher.quoteReplacement(replacement.toString()));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>从replace的算法中，我们可以发现，它不是从头开始遍历替换的，而是首先找到第一个要替换的字符，从要替换的字符开始遍历，发现一个替换一个。但是我暂时没有弄清除这样子的好处是什么，节省时间？应该是吧</li>
<li>四种用法，字符全替换字符，表达式全体换字符，表达式只替换第一个字符，字符串替换字符串</li>
</ul>
<h4 id="16、matches-和contains-函数"><a href="#16、matches-和contains-函数" class="headerlink" title="16、matches()和contains()函数"></a>16、matches()和contains()函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* matches() 方法用于检测字符串是否匹配给定的正则表达式。</span></span><br><span class="line"><span class="comment">* regex -- 匹配字符串的正则表达式。</span></span><br><span class="line"><span class="comment">* 如：String Str = new String("www.snailmann.com");</span></span><br><span class="line"><span class="comment">* System.out.println(Str.matches("(.*)snailmann(.*)"));   output:true</span></span><br><span class="line"><span class="comment">* System.out.println(Str.matches("www(.*)"));             output:true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Pattern.matches(regex, <span class="keyword">this</span>);   <span class="comment">//实际使用的是Pattern.matches()方法</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否含有CharSequence这个子类元素，通常用于StrngBuffer,StringBuilder</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(s.toString()) &gt; -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="17、split-函数"><a href="#17、split-函数" class="headerlink" title="17、split()函数"></a>17、split()函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public String[] split(String regex, int limit) &#123;</span><br><span class="line">       /* fastpath if the regex is a</span><br><span class="line">        (1)one-char String and this character is not one of the</span><br><span class="line">           RegEx&apos;s meta characters &quot;.$|()[&#123;^?*+\\&quot;, or</span><br><span class="line">        (2)two-char String and the first char is the backslash and</span><br><span class="line">           the second is not the ascii digit or ascii letter.</span><br><span class="line">        */</span><br><span class="line">       char ch = 0;</span><br><span class="line">       if (((regex.value.length == 1 &amp;&amp;</span><br><span class="line">            &quot;.$|()[&#123;^?*+\\&quot;.indexOf(ch = regex.charAt(0)) == -1) ||</span><br><span class="line">            (regex.length() == 2 &amp;&amp;</span><br><span class="line">             regex.charAt(0) == &apos;\\&apos; &amp;&amp;</span><br><span class="line">             (((ch = regex.charAt(1))-&apos;0&apos;)|(&apos;9&apos;-ch)) &lt; 0 &amp;&amp;</span><br><span class="line">             ((ch-&apos;a&apos;)|(&apos;z&apos;-ch)) &lt; 0 &amp;&amp;</span><br><span class="line">             ((ch-&apos;A&apos;)|(&apos;Z&apos;-ch)) &lt; 0)) &amp;&amp;</span><br><span class="line">           (ch &lt; Character.MIN_HIGH_SURROGATE ||</span><br><span class="line">            ch &gt; Character.MAX_LOW_SURROGATE))</span><br><span class="line">       &#123;</span><br><span class="line">           int off = 0;</span><br><span class="line">           int next = 0;</span><br><span class="line">           boolean limited = limit &gt; 0;</span><br><span class="line">           ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">           while ((next = indexOf(ch, off)) != -1) &#123;</span><br><span class="line">               if (!limited || list.size() &lt; limit - 1) &#123;</span><br><span class="line">                   list.add(substring(off, next));</span><br><span class="line">                   off = next + 1;</span><br><span class="line">               &#125; else &#123;    // last one</span><br><span class="line">                   //assert (list.size() == limit - 1);</span><br><span class="line">                   list.add(substring(off, value.length));</span><br><span class="line">                   off = value.length;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           // If no match was found, return this</span><br><span class="line">           if (off == 0)</span><br><span class="line">               return new String[]&#123;this&#125;;</span><br><span class="line"></span><br><span class="line">           // Add remaining segment</span><br><span class="line">           if (!limited || list.size() &lt; limit)</span><br><span class="line">               list.add(substring(off, value.length));</span><br><span class="line"></span><br><span class="line">           // Construct result</span><br><span class="line">           int resultSize = list.size();</span><br><span class="line">           if (limit == 0) &#123;</span><br><span class="line">               while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) &#123;</span><br><span class="line">                   resultSize--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           String[] result = new String[resultSize];</span><br><span class="line">           return list.subList(0, resultSize).toArray(result);</span><br><span class="line">       &#125;</span><br><span class="line">       return Pattern.compile(regex).split(this, limit);</span><br><span class="line">   &#125;</span><br><span class="line">   public String[] split(String regex) &#123;</span><br><span class="line">       return split(regex, 0);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="18、join-函数"><a href="#18、join-函数" class="headerlink" title="18、join()函数"></a>18、join()函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * join方法是JDK1.8加入的新函数，静态方法</span></span><br><span class="line"><span class="comment">  * 这个方法就是跟split有些对立的函数,不过join是静态方法</span></span><br><span class="line"><span class="comment">  * delimiter就是分割符，后面就是要追加的可变参数，比如str1,str2,str3</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 例子：String.join(",",new String("a"),new String("b"),new String("c"))</span></span><br><span class="line"><span class="comment">  * output: "a,b,c"</span></span><br><span class="line"><span class="comment">  */</span>	</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">join</span><span class="params">(CharSequence delimiter, CharSequence... elements)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(delimiter);  <span class="comment">//就是检测是否为Null,是null,抛异常</span></span><br><span class="line">        Objects.requireNonNull(elements);   <span class="comment">//不是就返回自己，即nothing happen</span></span><br><span class="line">        <span class="comment">// Number of elements not likely worth Arrays.stream overhead.</span></span><br><span class="line">        StringJoiner joiner = <span class="keyword">new</span> StringJoiner(delimiter);  <span class="comment">//嗯，有兴趣自己看StringJoiner类源码啦</span></span><br><span class="line">        <span class="keyword">for</span> (CharSequence cs: elements) &#123;</span><br><span class="line">            joiner.add(cs);   <span class="comment">//既用分割符delimiter将所有可变参数的字符串分割，合并成一个字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> joiner.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 功能是一样的，不过传入的参数不同</span></span><br><span class="line"><span class="comment">   * 这里第二个参数一般就是装着CharSequence子类的集合</span></span><br><span class="line"><span class="comment">   * 比如String.join(",",lists)   </span></span><br><span class="line"><span class="comment">   * list可以是一个Collection接口实现类，所含元素的基类必须是CharSequence类型</span></span><br><span class="line"><span class="comment">   * 比如String,StringBuilder,StringBuffer等</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">join</span><span class="params">(CharSequence delimiter,</span></span></span><br><span class="line"><span class="function"><span class="params">            Iterable&lt;? extends CharSequence&gt; elements)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(delimiter);</span><br><span class="line">        Objects.requireNonNull(elements);</span><br><span class="line">        StringJoiner joiner = <span class="keyword">new</span> StringJoiner(delimiter);</span><br><span class="line">        <span class="keyword">for</span> (CharSequence cs: elements) &#123;</span><br><span class="line">            joiner.add(cs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> joiner.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Java 1.8加入的新功能，有点跟split对立的意思，是个静态方法</li>
<li>有两个重载方法，一个是直接传字符串数组，另个是传集合。传集合的方式是一个好功能，很方遍将集合的字符串元素拼接成一个字符串。(分割符为 <code>&quot;&quot;</code> ,well, It’s great!!)</li>
</ul>
<h4 id="19、trim-函数"><a href="#19、trim-函数" class="headerlink" title="19、trim()函数"></a>19、trim()函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 去除字符串首尾部分的空值，如,' ' or " ",非""</span></span><br><span class="line"><span class="comment">* 原理是通过substring去实现的，首尾各一个指针</span></span><br><span class="line"><span class="comment">* 头指针发现空值就++，尾指针发现空值就--</span></span><br><span class="line"><span class="comment">* ' '的Int值为32，其实不仅仅是去空的作用，应该是整数值小于等于32的去除掉</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = value.length; <span class="comment">//代表尾指针，实际是尾指针+1的大小</span></span><br><span class="line">	<span class="keyword">int</span> st = <span class="number">0</span>;             <span class="comment">//代表头指针</span></span><br><span class="line">       <span class="keyword">char</span>[] val = value;    <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//st&lt;len,且字符的整数值小于32则代表有空值，st++</span></span><br><span class="line">       <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="string">' '</span>)) &#123;   </span><br><span class="line">           st++;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//len - 1才是真正的尾指针，如果尾部元素的整数值&lt;=32,则代表有空值，len--</span></span><br><span class="line">       <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="number">1</span>] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">           len--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//截取st到len的字符串(不包括len位置)</span></span><br><span class="line">       <span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>常见去首尾的空值，实际是去除首尾凡是小于32的字符</li>
</ul>
<h4 id="20、toString-函数"><a href="#20、toString-函数" class="headerlink" title="20、toString()函数"></a>20、toString()函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//emmmmm,这个就不说了吧，就是返回自己</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="21、toCharArray-函数"><a href="#21、toCharArray-函数" class="headerlink" title="21、toCharArray()函数"></a>21、toCharArray()函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 就是将String转换为字符数组并返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray() &#123;</span><br><span class="line">       <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></span><br><span class="line">       <span class="keyword">char</span> result[] = <span class="keyword">new</span> <span class="keyword">char</span>[value.length];     <span class="comment">//定义一个要返回的空数组，长度为字符串长度</span></span><br><span class="line">       System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length); <span class="comment">//拷贝</span></span><br><span class="line">       <span class="keyword">return</span> result; <span class="comment">//返回</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="22、toLowerCase-、toUpperCase-函数"><a href="#22、toLowerCase-、toUpperCase-函数" class="headerlink" title="22、toLowerCase()、toUpperCase()函数"></a>22、toLowerCase()、toUpperCase()函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//en,好长,下次再更新吧，先用着吧</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (locale == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> firstUpper;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = value.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Now check if there are any characters that need to be changed. */</span></span><br><span class="line">        scan: &#123;</span><br><span class="line">            <span class="keyword">for</span> (firstUpper = <span class="number">0</span> ; firstUpper &lt; len; ) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = value[firstUpper];</span><br><span class="line">                <span class="keyword">if</span> ((c &gt;= Character.MIN_HIGH_SURROGATE)</span><br><span class="line">                        &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> supplChar = codePointAt(firstUpper);</span><br><span class="line">                    <span class="keyword">if</span> (supplChar != Character.toLowerCase(supplChar)) &#123;</span><br><span class="line">                        <span class="keyword">break</span> scan;</span><br><span class="line">                    &#125;</span><br><span class="line">                    firstUpper += Character.charCount(supplChar);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c != Character.toLowerCase(c)) &#123;</span><br><span class="line">                        <span class="keyword">break</span> scan;</span><br><span class="line">                    &#125;</span><br><span class="line">                    firstUpper++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">        <span class="keyword">int</span> resultOffset = <span class="number">0</span>;  <span class="comment">/* result may grow, so i+resultOffset</span></span><br><span class="line"><span class="comment">                                * is the write location in result */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Just copy the first few lowerCase characters. */</span></span><br><span class="line">        System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, firstUpper);</span><br><span class="line"></span><br><span class="line">        String lang = locale.getLanguage();</span><br><span class="line">        <span class="keyword">boolean</span> localeDependent =</span><br><span class="line">                (lang == <span class="string">"tr"</span> || lang == <span class="string">"az"</span> || lang == <span class="string">"lt"</span>);</span><br><span class="line">        <span class="keyword">char</span>[] lowerCharArray;</span><br><span class="line">        <span class="keyword">int</span> lowerChar;</span><br><span class="line">        <span class="keyword">int</span> srcChar;</span><br><span class="line">        <span class="keyword">int</span> srcCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = firstUpper; i &lt; len; i += srcCount) &#123;</span><br><span class="line">            srcChar = (<span class="keyword">int</span>)value[i];</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">char</span>)srcChar &gt;= Character.MIN_HIGH_SURROGATE</span><br><span class="line">                    &amp;&amp; (<span class="keyword">char</span>)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123;</span><br><span class="line">                srcChar = codePointAt(i);</span><br><span class="line">                srcCount = Character.charCount(srcChar);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                srcCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (localeDependent ||</span><br><span class="line">                srcChar == <span class="string">'\u03A3'</span> || <span class="comment">// GREEK CAPITAL LETTER SIGMA</span></span><br><span class="line">                srcChar == <span class="string">'\u0130'</span>) &#123; <span class="comment">// LATIN CAPITAL LETTER I WITH DOT ABOVE</span></span><br><span class="line">                lowerChar = ConditionalSpecialCasing.toLowerCaseEx(<span class="keyword">this</span>, i, locale);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lowerChar = Character.toLowerCase(srcChar);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((lowerChar == Character.ERROR)</span><br><span class="line">                    || (lowerChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lowerChar == Character.ERROR) &#123;</span><br><span class="line">                    lowerCharArray =</span><br><span class="line">                            ConditionalSpecialCasing.toLowerCaseCharArray(<span class="keyword">this</span>, i, locale);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcCount == <span class="number">2</span>) &#123;</span><br><span class="line">                    resultOffset += Character.toChars(lowerChar, result, i + resultOffset) - srcCount;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lowerCharArray = Character.toChars(lowerChar);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Grow result if needed */</span></span><br><span class="line">                <span class="keyword">int</span> mapLen = lowerCharArray.length;</span><br><span class="line">                <span class="keyword">if</span> (mapLen &gt; srcCount) &#123;</span><br><span class="line">                    <span class="keyword">char</span>[] result2 = <span class="keyword">new</span> <span class="keyword">char</span>[result.length + mapLen - srcCount];</span><br><span class="line">                    System.arraycopy(result, <span class="number">0</span>, result2, <span class="number">0</span>, i + resultOffset);</span><br><span class="line">                    result = result2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; mapLen; ++x) &#123;</span><br><span class="line">                    result[i + resultOffset + x] = lowerCharArray[x];</span><br><span class="line">                &#125;</span><br><span class="line">                resultOffset += (mapLen - srcCount);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[i + resultOffset] = (<span class="keyword">char</span>)lowerChar;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(result, <span class="number">0</span>, len + resultOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toLowerCase(Locale.getDefault());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (locale == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> firstLower;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = value.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Now check if there are any characters that need to be changed. */</span></span><br><span class="line">        scan: &#123;</span><br><span class="line">            <span class="keyword">for</span> (firstLower = <span class="number">0</span> ; firstLower &lt; len; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = (<span class="keyword">int</span>)value[firstLower];</span><br><span class="line">                <span class="keyword">int</span> srcCount;</span><br><span class="line">                <span class="keyword">if</span> ((c &gt;= Character.MIN_HIGH_SURROGATE)</span><br><span class="line">                        &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123;</span><br><span class="line">                    c = codePointAt(firstLower);</span><br><span class="line">                    srcCount = Character.charCount(c);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    srcCount = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> upperCaseChar = Character.toUpperCaseEx(c);</span><br><span class="line">                <span class="keyword">if</span> ((upperCaseChar == Character.ERROR)</span><br><span class="line">                        || (c != upperCaseChar)) &#123;</span><br><span class="line">                    <span class="keyword">break</span> scan;</span><br><span class="line">                &#125;</span><br><span class="line">                firstLower += srcCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* result may grow, so i+resultOffset is the write location in result */</span></span><br><span class="line">        <span class="keyword">int</span> resultOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[len]; <span class="comment">/* may grow */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Just copy the first few upperCase characters. */</span></span><br><span class="line">        System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, firstLower);</span><br><span class="line"></span><br><span class="line">        String lang = locale.getLanguage();</span><br><span class="line">        <span class="keyword">boolean</span> localeDependent =</span><br><span class="line">                (lang == <span class="string">"tr"</span> || lang == <span class="string">"az"</span> || lang == <span class="string">"lt"</span>);</span><br><span class="line">        <span class="keyword">char</span>[] upperCharArray;</span><br><span class="line">        <span class="keyword">int</span> upperChar;</span><br><span class="line">        <span class="keyword">int</span> srcChar;</span><br><span class="line">        <span class="keyword">int</span> srcCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = firstLower; i &lt; len; i += srcCount) &#123;</span><br><span class="line">            srcChar = (<span class="keyword">int</span>)value[i];</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">char</span>)srcChar &gt;= Character.MIN_HIGH_SURROGATE &amp;&amp;</span><br><span class="line">                (<span class="keyword">char</span>)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123;</span><br><span class="line">                srcChar = codePointAt(i);</span><br><span class="line">                srcCount = Character.charCount(srcChar);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                srcCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (localeDependent) &#123;</span><br><span class="line">                upperChar = ConditionalSpecialCasing.toUpperCaseEx(<span class="keyword">this</span>, i, locale);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                upperChar = Character.toUpperCaseEx(srcChar);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((upperChar == Character.ERROR)</span><br><span class="line">                    || (upperChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (upperChar == Character.ERROR) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (localeDependent) &#123;</span><br><span class="line">                        upperCharArray =</span><br><span class="line">                                ConditionalSpecialCasing.toUpperCaseCharArray(<span class="keyword">this</span>, i, locale);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        upperCharArray = Character.toUpperCaseCharArray(srcChar);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcCount == <span class="number">2</span>) &#123;</span><br><span class="line">                    resultOffset += Character.toChars(upperChar, result, i + resultOffset) - srcCount;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    upperCharArray = Character.toChars(upperChar);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Grow result if needed */</span></span><br><span class="line">                <span class="keyword">int</span> mapLen = upperCharArray.length;</span><br><span class="line">                <span class="keyword">if</span> (mapLen &gt; srcCount) &#123;</span><br><span class="line">                    <span class="keyword">char</span>[] result2 = <span class="keyword">new</span> <span class="keyword">char</span>[result.length + mapLen - srcCount];</span><br><span class="line">                    System.arraycopy(result, <span class="number">0</span>, result2, <span class="number">0</span>, i + resultOffset);</span><br><span class="line">                    result = result2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; mapLen; ++x) &#123;</span><br><span class="line">                    result[i + resultOffset + x] = upperCharArray[x];</span><br><span class="line">                &#125;</span><br><span class="line">                resultOffset += (mapLen - srcCount);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[i + resultOffset] = (<span class="keyword">char</span>)upperChar;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(result, <span class="number">0</span>, len + resultOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toUpperCase(Locale.getDefault());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="23、format-函数"><a href="#23、format-函数" class="headerlink" title="23、format()函数"></a>23、format()函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JAVA字符串格式化</span></span><br><span class="line"><span class="comment">//新字符串使用本地语言环境，制定字符串格式和参数生成格式化的新字符串。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Formatter().format(format, args).toString();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用指定的语言环境，制定字符串格式和参数生成格式化的字符串。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(Locale l, String format, Object... args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Formatter(l).format(format, args).toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="24、valueOf类函数"><a href="#24、valueOf类函数" class="headerlink" title="24、valueOf类函数"></a>24、valueOf类函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Object转换为String</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">"null"</span> : obj.toString();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将char数组转换为String</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[])</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(data);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符数组的子数组转换为String</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(data, offset, count);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//e...重复</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(data, offset, count);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//e...重复</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span> data[])</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(data);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将布尔值转换为String</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> b ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将单个字符转换为String</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span> data[] = &#123;c&#125;;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(data, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将int转换为String</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将long转换为String</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Long.toString(l);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//将float转换为String</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Float.toString(f);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将double转换为String</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Double.toString(d);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>copyValueOf和valueOf在Java8看来已经是完全没有区别的函数</li>
<li>所有的value的本质都是新new一个String对象</li>
</ul>
<h4 id="25、intern-函数"><a href="#25、intern-函数" class="headerlink" title="25、intern()函数"></a>25、intern()函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>String类中唯一的一条本地方法，既不是用Java语言实现的方法。<br>比如str.intern(),作用就是去字符串常量池中寻找str字符串，如果有则返回str在常量池中的引用，如果没有则在常量池中创建str对象</p>
<h4 id="26、相关问题"><a href="#26、相关问题" class="headerlink" title="26、相关问题"></a>26、相关问题</h4><p>String类和CharSequencee接口的关系<br>CharSequence是一个接口，它只包括length(), charAt(int index), subSequence(int start, int end)这几个API接口。继承了CharSequence代表着这是一个有序的字符集合。</p>
<p>String类为何为不可变类型?<br>从String的定义，我们可以知道,String类是被final修饰的，是一个不可被继承的类<br>同时我们从字段属性的private final char value[]可以看出，String的本质char数组也是一个不可变的数组对象，且是私有的，不对外公开。<br>另外String类也没有提供对value进行修改的方法，所以外部也没有途径对String对象的值进行修改<br>从其他的方法中，我们也可以看到，如果是对字符串进行修改，其本质是new了一个新的String的对象<br>注意：<br>String对象是真的无法修改吗？<br>答案是否定的，还是有途径修改的，那就是通过反射。<br>因为final的是字符数组，只代表这个value变量的引用不能改变，不代表value指向的对象不可以改变，String只是没有提供修改的途径，即使有也会是不对外公开。但数组中的元素是可以修改的，虽然没有途径，但还是反射就是一个逆天的存在，我们可以通过反射的途径去修改字符数组value的元素的值。</p>
<p>所以String的不可变性仅仅是正常情况下的不可变，但绝非完全的不可变。</p>
<p>String类length与codePointCount的区别<br>对于普通字符串，这两种方法得到的值是一样的，但对于UniCode编码来说，还是有一点区别。<br>区别：<br>length()方法返回的是使用的是UTF-16编码的字符代码单元数量，不一定是实际上我们认为的字符个数。codePointCount()方法返回的是代码点个数，是实际上的字符个数。</p>
<p>例如：<br>String str = “/uD835/uDD6B”，那么机器会识别它是2个代码单元代理的1个代码点”Z“，故而，length的结果是代码单元数量2，而codePointCount()的结果是代码点数量1.</p>
<p>为什么String已经有一个compareTo方法了，还需要一个静态内部类再实现compare?<br>这里有一个疑惑，在String中已经有了一个compareTo的方法，为什么还要有一个CaseInsensitiveComparator的内部静态类呢？网上的回答大多数都是说是为了代码复用，我觉得这是有道理的。</p>
<p>首先是一个代码复用的问题，因为String类的compareToIgnoreCase方法实际调用的也是静态内部的compare方法<br>其次这里采用了饿汉单例模式<br>个人想法：<br>我个人觉得，为什么要有个静态内部类呢，首先我们要区别comparable和comparator接口的区别。实现了comparable接口的类，我们就能够本类的内部重写compareTo方法实现大小比较，从而给Collections.sort或Arrays.sort进行排序。而如果一个类没有实现comparable接口也想该类可以排序怎么办，那么就可以创造一个外部比较器去实现comparator接口，重写compare方法。以达到可以给Collections和Arrays使用。<br>具体区别参考如下链接：<br>Comparator和Comparable接口的区别</p>
<p>因为String继承了comparable<string>接口，所以可以重写compareTo(String str)方法,注意参数是String类型的。里面实现的方式不忽略大小写的比较方式。如果我们还需要一个可以忽视大小写的比较方法怎么办？我们可能立马想到的就是重载一个compareTo方法，多对个参数？问题是不行的，工具类只认compareTo(String str)，那么我们此时要怎么办呢？所以只能求救于Comparetor接口。要用Comparetor接口必须创造一个比较器去实现Comparator接口，并重写compare方法。所以就有了String内部就有了实现Comparator接口的静态内部类,这个静态内部类就是一个比较器。(当然这个静态内部类也可以不放进String类里。可以单独作为一个类，可是没有必要，因为这个类也就在String内部使用，所以作为静态内部类即可。)</string></p>
<p>为什么在忽略大小写比较的时候，通常都会大小写都会比较一次？<br>也就是说，通常会同位置的字符会全部转为大写比较一次，又转为小写比较一次？这是为什么，不是转换为大写或小写比较一次既可吗？</p>
<p>同时比较了UpperCase和LowerCase，是为了兼容Georgian字符。<br><a href="https://www.cnblogs.com/yanyichao/p/4493039.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanyichao/p/4493039.html</a></p>
<p>String类的CopyValueOf 和ValueOf有什么不同吗？<br>目前Java8的源码来看，没有任何区别。</p>
<p>我觉得你最大的疑问应该在char数组上吧？比如<br>char[] test = new char[]{‘a’,‘b’,‘c’};<br>String a = String.valueOf(test);<br>String b = String.copyValueOf(test);<br>有什么区别？答案：没有任何区别！<br>首先你得知道，String的底层是由char[]实现的：通过一个char[]类型的value属性！早期的String构造器的实现呢，不会拷贝数组的，直接将参数的char[]数组作为String的value属性。然后<br>test[0] = ‘A’;<br>将导致字符串的变化。为了避免这个问题，提供了copyValueOf方法，每次都拷贝成新的字符数组来构造新的String对象。但是现在的String对象，在构造器中就通过拷贝新数组实现了，所以这两个方面在本质上已经没区别了。<br>请问String类的CopyValueOf 和ValueOf有什么不同吗？</p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/img/donate.png">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <br>
        <div id="comment-container" style="display:none;">
        </div>
        <div id="disqus_thread" style="display:none;"></div>

        <div id="lv-container" style="display:none;">
        </div>

    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        <li>
            <a target="_blank" href="https://twitter.com/z_alex">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-twitter"></i>
                            </span>
            </a>
        </li>
        
        
        <li>
            <a target="_blank" href="https://www.zhihu.com/people/z.alex">
                            <span class="fa-stack fa-lg">
                                 <i class="iconfont icon-zhihu"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank" href="http://weibo.com/江南E客">
                            <span class="fa-stack fa-lg">
                                  <i class="iconfont icon-weibo"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank" href="https://www.facebook.com/z_alex">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-facebook"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank" href="https://github.com/Alex0605">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank" href="https://www.linkedin.com/in/z_alex">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-linkedin"></i>
                            </span>
            </a>
        </li>
        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv" style="display:none">
            <span id="busuanzi_value_site_pv" style="display:none"></span>
        </span>
        <span id="busuanzi_container_site_uv" style="display:none">
            <span id="busuanzi_value_site_uv" style="display:none"></span>
        </span>
     </p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
