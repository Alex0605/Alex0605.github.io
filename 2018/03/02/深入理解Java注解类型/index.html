<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="江南E客的Blog">
    <meta name="keyword" content="腾讯">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        深入理解Java注解类型 - 江南E客的Blog | Z.Alex&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 你的努力要配的上你的野心 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.png" />
        </div>
        <div class="name">
            <i>Z.Alex</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、理解Java注解"><span class="toc-text">1、理解Java注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、基本语法"><span class="toc-text">2、基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1、声明注解与元注解"><span class="toc-text">2.1、声明注解与元注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2、注解元素及其数据类型"><span class="toc-text">2.2、注解元素及其数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-编译器对默认值的限制"><span class="toc-text">2.3.编译器对默认值的限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-注解不支持继承"><span class="toc-text">2.4.注解不支持继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-快捷方式"><span class="toc-text">2.5.快捷方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-Java内置注解与其它元注解"><span class="toc-text">2.6.Java内置注解与其它元注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-注解与反射机制"><span class="toc-text">3.注解与反射机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-运行时注解处理器"><span class="toc-text">4.运行时注解处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Java-8中注解增强"><span class="toc-text">5.Java 8中注解增强</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1、元注解-Repeatable"><span class="toc-text">5.1、元注解@Repeatable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2、新增的两种ElementType"><span class="toc-text">5.2、新增的两种ElementType</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 你的努力要配的上你的野心 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        深入理解Java注解类型
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2018-03-02 16:44:06</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#Java" title="Java">Java</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h3 id="1、理解Java注解"><a href="#1、理解Java注解" class="headerlink" title="1、理解Java注解"></a>1、理解Java注解</h3><p>Java注解与普通修饰符(public、static、void等)的使用方式并没有多大区别，下面的例子是常见的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//@Test注解修饰方法A</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//一个方法上可以拥有多个不同的注解</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"uncheck"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        通过在方法上使用@Test注解后，在运行该方法时，测试框架会自动识别该方法并单独调用，@Test实际上是一种标记注解，起标记作用，运行时告诉测试框架该方法为测试方法。而对于@Deprecated和@SuppressWarnings(“uncheck”)，则是Java本身内置的注解，在代码中，可以经常看见它们，但这并不是一件好事，毕竟当方法或是类上面有@Deprecated注解时，说明该方法或是类都已经过期不建议再用，@SuppressWarnings 则表示忽略指定警告，比如@SuppressWarnings(“uncheck”)，这就是注解的最简单的使用方式，那么下面我们就来看看注解定义的基本语法</p>
<h3 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h3><h4 id="2-1、声明注解与元注解"><a href="#2-1、声明注解与元注解" class="headerlink" title="2.1、声明注解与元注解"></a>2.1、声明注解与元注解</h4><p>我们先来看看前面的Test注解是如何声明的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明Test注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        我们使用了@interface声明了Test注解，并使用@Target注解传入ElementType.METHOD参数来标明@Test只能用于方法上，@Retention(RetentionPolicy.RUNTIME)则用来表示该注解生存期是运行时，从代码上看注解的定义很像接口的定义，确实如此，毕竟在编译后也会生成Test.class文件。对于@Target和@Retention是由Java提供的元注解，所谓元注解就是标记其他注解的注解，下面分别介绍</p>
<p>1).@Target 用来约束注解可以应用的地方（如方法、类或字段），其中ElementType是枚举类型，其定义如下，也代表可能的取值范围</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    <span class="comment">/**标明该注解可以用于类、接口（包括注解类型）或enum声明*/</span></span><br><span class="line">    TYPE,</span><br><span class="line">    <span class="comment">/** 标明该注解可以用于字段(域)声明，包括enum实例 */</span></span><br><span class="line">    FIELD,</span><br><span class="line">    <span class="comment">/** 标明该注解可以用于方法声明 */</span></span><br><span class="line">    METHOD,</span><br><span class="line">    <span class="comment">/** 标明该注解可以用于参数声明 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line">    <span class="comment">/** 标明注解可以用于构造函数声明 */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    <span class="comment">/** 标明注解可以用于局部变量声明 */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    <span class="comment">/** 标明注解可以用于注解声明(应用于另一个注解上)*/</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    <span class="comment">/** 标明注解可以用于包声明 */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标明注解可以用于类型参数声明（1.8新加入）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型使用声明（1.8新加入)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，当注解未指定Target值时，则此注解可以用于任何元素之上，多个值使用{}包含并用逗号隔开，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br></pre></td></tr></table></figure>
<p>2).@Retention用来约束注解的生命周期，分别有三个值，源码级别（source），类文件级别（class）或者运行时级别（runtime），其含有如下：</p>
<ul>
<li>SOURCE：注解将被编译器丢弃（该类型的注解信息只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件里）</li>
</ul>
<ul>
<li>CLASS：注解在class文件中可用，但会被VM丢弃（该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中），请注意，当注解未定义Retention值时，默认值是CLASS，如Java内置注解，@Override、@Deprecated、@SuppressWarnning等</li>
</ul>
<ul>
<li>RUNTIME：注解信息将在运行期(JVM)也保留，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息），如SpringMvc中的@Controller、@Autowired、@RequestMapping等。</li>
</ul>
<h4 id="2-2、注解元素及其数据类型"><a href="#2-2、注解元素及其数据类型" class="headerlink" title="2.2、注解元素及其数据类型"></a>2.2、注解元素及其数据类型</h4><p>通过上述对@Test注解的定义，我们了解了注解定义的过程，由于@Test内部没有定义其他元素，所以@Test也称为标记注解（marker annotation），但在自定义注解中，一般都会包含一些元素以表示某些值，方便处理器使用，这点在下面的例子将会看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对应数据表注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)<span class="comment">//只能应用于类上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//保存到运行时</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBTable &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述定义一个名为DBTable的注解，该用于主要用于数据库表与Bean类的映射（稍后会有完整案例分析），与前面Test注解不同的是，我们声明一个String类型的name元素，其默认值为空字符，但是必须注意到对应任何元素的声明应采用方法的声明方式，同时可选择使用default提供默认值，@DBTable使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类上使用该注解</span></span><br><span class="line"><span class="meta">@DBTable</span>(name = <span class="string">"MEMBER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于注解支持的元素数据类型除了上述的String，还支持如下数据类型</p>
<ul>
<li>所有基本类型（int,float,boolean,byte,double,char,long,short）</li>
<li>String</li>
<li>Class</li>
<li>enum</li>
<li>Annotation</li>
<li>上述类型的数组</li>
</ul>
<p>倘若使用了其他数据类型，编译器将会丢出一个编译错误，注意，声明注解元素时可以使用基本类型但不允许使用任何包装类型，同时还应该注意到注解也可以作为元素的类型，也就是嵌套注解，下面的代码演示了上述类型的使用过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.annotationdemo;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据类型使用Demo</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> Reference&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationElementDemo &#123;</span><br><span class="line">    <span class="comment">//枚举类型</span></span><br><span class="line">    <span class="keyword">enum</span> Status &#123;FIXED,NORMAL&#125;;</span><br><span class="line">    <span class="comment">//声明枚举</span></span><br><span class="line">    <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">default</span> Status.FIXED</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//布尔类型</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">showSupport</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String类型</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span><span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class类型</span></span><br><span class="line">    Class&lt;?&gt; testCase() <span class="keyword">default</span> Void.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注解嵌套</span></span><br><span class="line">    <span class="function">Reference <span class="title">reference</span><span class="params">()</span> <span class="keyword">default</span> @<span class="title">Reference</span><span class="params">(next=<span class="keyword">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组类型</span></span><br><span class="line">    <span class="keyword">long</span>[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-编译器对默认值的限制"><a href="#2-3-编译器对默认值的限制" class="headerlink" title="2.3.编译器对默认值的限制"></a>2.3.编译器对默认值的限制</h4><p>编译器对元素的默认值有些过分挑剔。首先，元素不能有不确定的值。也就是说，元素必须要么具有默认值，要么在使用注解时提供元素的值。其次，对于非基本类型的元素，无论是在源代码中声明，还是在注解接口中定义默认值，都不能以null作为值，这就是限制，没有什么利用可言，但造成一个元素的存在或缺失状态，因为每个注解的声明中，所有的元素都存在，并且都具有相应的值，为了绕开这个限制，只能定义一些特殊的值，例如空字符串或负数，表示某个元素不存在。</p>
<h4 id="2-4-注解不支持继承"><a href="#2-4-注解不支持继承" class="headerlink" title="2.4.注解不支持继承"></a>2.4.注解不支持继承</h4><p>注解是不支持继承的，因此不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口，这里我们反编译前面定义的DBTable注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.annotationdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="comment">//反编译后的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DBTable</span> <span class="keyword">extends</span> <span class="title">Annotation</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然反编译后发现DBTable注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。</p>
<h4 id="2-5-快捷方式"><a href="#2-5-快捷方式" class="headerlink" title="2.5.快捷方式"></a>2.5.快捷方式</h4><p>所谓的快捷方式就是注解中定义了名为value的元素，并且在使用该注解时，如果该元素是唯一需要赋值的一个元素，那么此时无需使用key=value的语法，而只需在括号内给出value元素所需的值即可。这可以应用于任何合法类型的元素，记住，这限制了元素名必须为value，简单案例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.annotationdemo;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="comment">//定义注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> IntegerVaule&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuicklyWay</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当只想给value赋值时,可以使用以下快捷方式</span></span><br><span class="line">    <span class="meta">@IntegerVaule</span>(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当name也需要赋值时必须采用key=value的方式赋值</span></span><br><span class="line">    <span class="meta">@IntegerVaule</span>(value = <span class="number">10000</span>,name = <span class="string">"MONEY"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> money;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-Java内置注解与其它元注解"><a href="#2-6-Java内置注解与其它元注解" class="headerlink" title="2.6.Java内置注解与其它元注解"></a>2.6.Java内置注解与其它元注解</h4><p>接着看看Java提供的内置注解，主要有3个，如下：</p>
<ul>
<li>@Override：用于标明此方法覆盖了父类的方法，源码如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@Deprecated：用于标明已经过时的方法或类，源码如下，关于@Documented稍后分析：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@SuppressWarnnings:用于有选择的关闭编译器对类、方法、成员变量、变量初始化的警告，其实现源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其内部有一个String数组，主要接收值如下：</p>
<p>deprecation：使用了不赞成使用的类或方法时的警告；<br>unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型;<br>fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;<br>path：在类路径、源文件路径等中有不存在的路径时的警告;<br>serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告;<br>finally：任何 finally 子句不能正常完成时的警告;<br>all：关于以上所有情况的警告。</p>
<p>这个三个注解比较简单，看个简单案例即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注明该类已过时，不建议使用</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="comment">//注明该方法已过时，不建议使用</span></span><br><span class="line">    <span class="meta">@Deprecated</span>()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//标明覆盖父类A的A方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.A();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去掉检测警告</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"uncheck"</span>,<span class="string">"deprecation"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">C</span><span class="params">()</span></span>&#123; &#125; </span><br><span class="line">    <span class="comment">//去掉检测警告</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"uncheck"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">D</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们分析了两种元注解，@Target和@Retention，除了这两种元注解，Java还提供了另外两种元注解，@Documented和@Inherited，下面分别介绍：</p>
<p>@Documented 被修饰的注解会生成到javadoc中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DocumentA &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有使用@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DocumentB &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用注解</span></span><br><span class="line"><span class="meta">@DocumentA</span></span><br><span class="line"><span class="meta">@DocumentB</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocumentDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用javadoc命令生成文档：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc DocumentDemo.java DocumentA.java DocumentB.java</span><br></pre></td></tr></table></figure>
<p>可以发现使用@Documented元注解定义的注解(@DocumentA)将会生成到javadoc中,而@DocumentB则没有在doc文档中出现，这就是元注解@Documented的作用。</p>
<p>可以发现使用@Documented元注解定义的注解(@DocumentA)将会生成到javadoc中,而@DocumentB则没有在doc文档中出现，这就是元注解@Documented的作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DocumentA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DocumentB &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DocumentA</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DocumentB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocumentDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">        A instanceA=<span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(<span class="string">"已使用的@Inherited注解:"</span>+Arrays.toString(instanceA.getClass().getAnnotations()));</span><br><span class="line"></span><br><span class="line">        C instanceC = <span class="keyword">new</span> D();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"没有使用的@Inherited注解:"</span>+Arrays.toString(instanceC.getClass().getAnnotations()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行结果:</span></span><br><span class="line"><span class="comment">     已使用的<span class="doctag">@Inherited</span>注解:[<span class="doctag">@com</span>.zejian.annotationdemo.DocumentA()]</span></span><br><span class="line"><span class="comment">     没有使用的<span class="doctag">@Inherited</span>注解:[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-注解与反射机制"><a href="#3-注解与反射机制" class="headerlink" title="3.注解与反射机制"></a>3.注解与反射机制</h3><p>前面经过反编译后，我们知道Java所有注解都继承了Annotation接口，也就是说　Java使用Annotation接口代表注解元素，该接口是所有Annotation类型的父接口。同时为了运行时能准确获取到注解的相关信息，Java在java.lang.reflect 反射包下新增了AnnotatedElement接口，它主要用于表示目前正在 VM 中运行的程序中已使用注解的元素，通过该接口提供的方法可以利用反射技术地读取注解的信息，如反射包的Constructor类、Field类、Method类、Package类和Class类都实现了AnnotatedElement接口，它简要含义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class：类的Class对象定义 　 </span><br><span class="line">Constructor：代表类的构造器定义 　 </span><br><span class="line">Field：代表类的成员变量定义 </span><br><span class="line">Method：代表类的方法定义 　 </span><br><span class="line">Package：代表类的包定义</span><br></pre></td></tr></table></figure>
<p>下面是AnnotatedElement中相关的API方法，以上5个类都实现以下的方法</p>
<p>返回值    方法名称    说明</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a extends annotation></a></td>
<td>getAnnotation(Class<a> annotationClass)</a></td>
<td>该元素如果存在指定类型的注解，则返回这些注解，否则返回 null。</td>
</tr>
<tr>
<td>Annotation[]</td>
<td>getAnnotations()</td>
<td>返回此元素上存在的所有注解，包括从父类继承的</td>
</tr>
<tr>
<td>boolean</td>
<td>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td>
<td>如果指定类型的注解存在于此元素上，则返回 true，否则返回 false。</td>
</tr>
<tr>
<td>Annotation[]</td>
<td>getDeclaredAnnotations()</td>
<td>返回直接存在于此元素上的所有注解，注意，不包括父类的注解，调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响，没有则返回长度为0的数组</td>
</tr>
</tbody>
</table>
<p>简单案例演示如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.annotationdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="meta">@DocumentA</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了A类</span></span><br><span class="line"><span class="meta">@DocumentB</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocumentDemo</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = DocumentDemo.class;</span><br><span class="line">        <span class="comment">//根据指定注解类型获取该注解</span></span><br><span class="line">        DocumentA documentA=clazz.getAnnotation(DocumentA.class);</span><br><span class="line">        System.out.println(<span class="string">"A:"</span>+documentA);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取该元素上的所有注解，包含从父类继承</span></span><br><span class="line">        Annotation[] an= clazz.getAnnotations();</span><br><span class="line">        System.out.println(<span class="string">"an:"</span>+ Arrays.toString(an));</span><br><span class="line">        <span class="comment">//获取该元素上的所有注解，但不包含继承！</span></span><br><span class="line">        Annotation[] an2=clazz.getDeclaredAnnotations();</span><br><span class="line">        System.out.println(<span class="string">"an2:"</span>+ Arrays.toString(an2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断注解DocumentA是否在该元素上</span></span><br><span class="line">        <span class="keyword">boolean</span> b=clazz.isAnnotationPresent(DocumentA.class);</span><br><span class="line">        System.out.println(<span class="string">"b:"</span>+b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行结果:</span></span><br><span class="line"><span class="comment">         A:<span class="doctag">@com</span>.zejian.annotationdemo.DocumentA()</span></span><br><span class="line"><span class="comment">         an:[<span class="doctag">@com</span>.zejian.annotationdemo.DocumentA(), <span class="doctag">@com</span>.zejian.annotationdemo.DocumentB()]</span></span><br><span class="line"><span class="comment">         an2:<span class="doctag">@com</span>.zejian.annotationdemo.DocumentB()</span></span><br><span class="line"><span class="comment">         b:true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-运行时注解处理器"><a href="#4-运行时注解处理器" class="headerlink" title="4.运行时注解处理器"></a>4.运行时注解处理器</h3><p>了解完注解与反射的相关API后，现在通过一个实例（该例子是博主改编自《Tinking in Java》）来演示利用运行时注解来组装数据库SQL的构建语句的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)<span class="comment">//只能应用于类上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//保存到运行时</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBTable &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解Integer类型的字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLInteger &#123;</span><br><span class="line">    <span class="comment">//该字段对应数据库表列名</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//嵌套注解</span></span><br><span class="line">    <span class="function">Constraints <span class="title">constraint</span><span class="params">()</span> <span class="keyword">default</span> @Constraints</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解String类型的字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLString &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应数据库表的列名</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//列类型分配的长度，如varchar(30)的30</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Constraints <span class="title">constraint</span><span class="params">()</span> <span class="keyword">default</span> @Constraints</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约束注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)<span class="comment">//只能应用在字段上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Constraints &#123;</span><br><span class="line">    <span class="comment">//判断是否作为主键约束</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">primaryKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="comment">//判断是否允许为null</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">allowNull</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="comment">//判断是否唯一</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库表Member对应实例类bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DBTable</span>(name = <span class="string">"MEMBER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主键ID</span></span><br><span class="line">    <span class="meta">@SQLString</span>(name = <span class="string">"ID"</span>,value = <span class="number">50</span>, constraint = <span class="meta">@Constraints</span>(primaryKey = <span class="keyword">true</span>))</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SQLString</span>(name = <span class="string">"NAME"</span> , value = <span class="number">30</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SQLInteger</span>(name = <span class="string">"AGE"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SQLString</span>(name = <span class="string">"DESCRIPTION"</span> ,value = <span class="number">150</span> , constraint = <span class="meta">@Constraints</span>(allowNull = <span class="keyword">true</span>))</span><br><span class="line">    <span class="keyword">private</span> String description;<span class="comment">//个人描述</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//省略set get.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述定义4个注解，分别是@DBTable(用于类上)、@Constraints(用于字段上)、 @SQLString(用于字段上)、@SQLString(用于字段上)并在Member类中使用这些注解，这些注解的作用的是用于帮助注解处理器生成创建数据库表MEMBER的构建语句，在这里有点需要注意的是，我们使用了嵌套注解@Constraints，该注解主要用于判断字段是否为null或者字段是否唯一。必须清楚认识到上述提供的注解生命周期必须为@Retention(RetentionPolicy.RUNTIME)，即运行时，这样才可以使用反射机制获取其信息。有了上述注解和使用，剩余的就是编写上述的注解处理器了，前面我们聊了很多注解，其处理器要么是Java自身已提供、要么是框架已提供的，我们自己都没有涉及到注解处理器的编写，但上述定义处理SQL的注解，其处理器必须由我们自己编写了，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.annotationdemo;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行时注解处理器，构造表创建语句</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createTableSql</span><span class="params">(String className)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl = Class.forName(className);</span><br><span class="line">    DBTable dbTable = cl.getAnnotation(DBTable.class);</span><br><span class="line">    <span class="comment">//如果没有表注解，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(dbTable == <span class="keyword">null</span>) &#123;</span><br><span class="line">      System.out.println(</span><br><span class="line">              <span class="string">"No DBTable annotations in class "</span> + className);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String tableName = dbTable.name();</span><br><span class="line">    <span class="comment">// If the name is empty, use the Class name:</span></span><br><span class="line">    <span class="keyword">if</span>(tableName.length() &lt; <span class="number">1</span>)</span><br><span class="line">      tableName = cl.getName().toUpperCase();</span><br><span class="line">    List&lt;String&gt; columnDefs = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">//通过Class类API获取到所有成员字段</span></span><br><span class="line">    <span class="keyword">for</span>(Field field : cl.getDeclaredFields()) &#123;</span><br><span class="line">      String columnName = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//获取字段上的注解</span></span><br><span class="line">      Annotation[] anns = field.getDeclaredAnnotations();</span><br><span class="line">      <span class="keyword">if</span>(anns.length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// Not a db table column</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//判断注解类型</span></span><br><span class="line">      <span class="keyword">if</span>(anns[<span class="number">0</span>] <span class="keyword">instanceof</span> SQLInteger) &#123;</span><br><span class="line">        SQLInteger sInt = (SQLInteger) anns[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//获取字段对应列名称，如果没有就是使用字段名称替代</span></span><br><span class="line">        <span class="keyword">if</span>(sInt.name().length() &lt; <span class="number">1</span>)</span><br><span class="line">          columnName = field.getName().toUpperCase();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          columnName = sInt.name();</span><br><span class="line">        <span class="comment">//构建语句</span></span><br><span class="line">        columnDefs.add(columnName + <span class="string">" INT"</span> +</span><br><span class="line">                getConstraints(sInt.constraint()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//判断String类型</span></span><br><span class="line">      <span class="keyword">if</span>(anns[<span class="number">0</span>] <span class="keyword">instanceof</span> SQLString) &#123;</span><br><span class="line">        SQLString sString = (SQLString) anns[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// Use field name if name not specified.</span></span><br><span class="line">        <span class="keyword">if</span>(sString.name().length() &lt; <span class="number">1</span>)</span><br><span class="line">          columnName = field.getName().toUpperCase();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          columnName = sString.name();</span><br><span class="line">        columnDefs.add(columnName + <span class="string">" VARCHAR("</span> +</span><br><span class="line">                sString.value() + <span class="string">")"</span> +</span><br><span class="line">                getConstraints(sString.constraint()));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据库表构建语句</span></span><br><span class="line">    StringBuilder createCommand = <span class="keyword">new</span> StringBuilder(</span><br><span class="line">            <span class="string">"CREATE TABLE "</span> + tableName + <span class="string">"("</span>);</span><br><span class="line">    <span class="keyword">for</span>(String columnDef : columnDefs)</span><br><span class="line">      createCommand.append(<span class="string">"\n    "</span> + columnDef + <span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove trailing comma</span></span><br><span class="line">    String tableCreate = createCommand.substring(</span><br><span class="line">            <span class="number">0</span>, createCommand.length() - <span class="number">1</span>) + <span class="string">");"</span>;</span><br><span class="line">    <span class="keyword">return</span> tableCreate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断该字段是否有其他约束</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> con</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getConstraints</span><span class="params">(Constraints con)</span> </span>&#123;</span><br><span class="line">    String constraints = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span>(!con.allowNull())</span><br><span class="line">      constraints += <span class="string">" NOT NULL"</span>;</span><br><span class="line">    <span class="keyword">if</span>(con.primaryKey())</span><br><span class="line">      constraints += <span class="string">" PRIMARY KEY"</span>;</span><br><span class="line">    <span class="keyword">if</span>(con.unique())</span><br><span class="line">      constraints += <span class="string">" UNIQUE"</span>;</span><br><span class="line">    <span class="keyword">return</span> constraints;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String[] arg=&#123;<span class="string">"com.zejian.annotationdemo.Member"</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(String className : arg) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Table Creation SQL for "</span> +</span><br><span class="line">              className + <span class="string">" is :\n"</span> + createTableSql(className));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果：</span></span><br><span class="line"><span class="comment">     Table Creation SQL for com.zejian.annotationdemo.Member is :</span></span><br><span class="line"><span class="comment">     CREATE TABLE MEMBER(</span></span><br><span class="line"><span class="comment">     ID VARCHAR(50) NOT NULL PRIMARY KEY,</span></span><br><span class="line"><span class="comment">     NAME VARCHAR(30) NOT NULL,</span></span><br><span class="line"><span class="comment">     AGE INT NOT NULL,</span></span><br><span class="line"><span class="comment">     DESCRIPTION VARCHAR(150)</span></span><br><span class="line"><span class="comment">     );</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对反射比较熟悉的同学，上述代码就相对简单了，我们通过传递Member的全路径后通过Class.forName()方法获取到Member的class对象，然后利用Class对象中的方法获取所有成员字段Field，最后利用field.getDeclaredAnnotations()遍历每个Field上的注解再通过注解的类型判断来构建建表的SQL语句。这便是利用注解结合反射来构建SQL语句的简单的处理器模型，是否已回想起Hibernate？</p>
<h3 id="5-Java-8中注解增强"><a href="#5-Java-8中注解增强" class="headerlink" title="5.Java 8中注解增强"></a>5.Java 8中注解增强</h3><h4 id="5-1、元注解-Repeatable"><a href="#5-1、元注解-Repeatable" class="headerlink" title="5.1、元注解@Repeatable"></a>5.1、元注解@Repeatable</h4><p>元注解@Repeatable是JDK1.8新加入的，它表示在同一个位置重复相同的注解。在没有该注解前，一般是无法在同一个类型上使用相同的注解的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java8前无法这样使用</span></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/update"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/add"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Java8前如果是想实现类似的功能，我们需要在定义@FilterPath注解时定义一个数组元素接收多个值如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FilterPath &#123;</span><br><span class="line">    String [] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="meta">@FilterPath</span>(&#123;<span class="string">"/update"</span>,<span class="string">"/add"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>但在Java8新增了@Repeatable注解后就可以采用如下的方式定义并使用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.annotationdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Java8新增@Repeatable原注解</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Repeatable</span>(FilterPaths.class)<span class="comment">//参数指明接收的注解class</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FilterPath &#123;</span><br><span class="line">    <span class="function">String  <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> FilterPaths &#123;</span><br><span class="line">    FilterPath[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用案例</span></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/update"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/add"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/delete"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以简单理解为通过使用@Repeatable后，将使用@FilterPaths注解作为接收同一个类型上重复注解的容器，而每个@FilterPath则负责保存指定的路径串。为了处理上述的新增注解，Java8还在AnnotatedElement接口新增了getDeclaredAnnotationsByType() 和 getAnnotationsByType()两个方法并在接口给出了默认实现，在指定@Repeatable的注解时，可以通过这两个方法获取到注解相关信息。但请注意，旧版API中的getDeclaredAnnotation()和 getAnnotation()是不对@Repeatable注解的处理的(除非该注解没有在同一个声明上重复出现)。注意getDeclaredAnnotationsByType方法获取到的注解不包括父类，其实当 getAnnotationsByType()方法调用时，其内部先执行了getDeclaredAnnotationsByType方法，只有当前类不存在指定注解时，getAnnotationsByType()才会继续从其父类寻找，但请注意如果@FilterPath和@FilterPaths没有使用了@Inherited的话，仍然无法获取。下面通过代码来演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zejian on 2017/5/20.</span></span><br><span class="line"><span class="comment"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用Java8新增@Repeatable原注解</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Repeatable</span>(FilterPaths.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FilterPath &#123;</span><br><span class="line">    <span class="function">String  <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> FilterPaths &#123;</span><br><span class="line">    FilterPath[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/list"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用案例</span></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/update"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/add"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/delete"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> <span class="keyword">extends</span> <span class="title">CC</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = AA.class;</span><br><span class="line">        <span class="comment">//通过getAnnotationsByType方法获取所有重复注解</span></span><br><span class="line">        FilterPath[] annotationsByType = clazz.getAnnotationsByType(FilterPath.class);</span><br><span class="line">        FilterPath[] annotationsByType2 = clazz.getDeclaredAnnotationsByType(FilterPath.class);</span><br><span class="line">        <span class="keyword">if</span> (annotationsByType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FilterPath filter : annotationsByType) &#123;</span><br><span class="line">                System.out.println(<span class="string">"1:"</span>+filter.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (annotationsByType2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FilterPath filter : annotationsByType2) &#123;</span><br><span class="line">                System.out.println(<span class="string">"2:"</span>+filter.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"使用getAnnotation的结果:"</span>+clazz.getAnnotation(FilterPath.class));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行结果(当前类拥有该注解FilterPath,则不会从CC父类寻找)</span></span><br><span class="line"><span class="comment">         1:/web/update</span></span><br><span class="line"><span class="comment">         1:/web/add</span></span><br><span class="line"><span class="comment">         1:/web/delete</span></span><br><span class="line"><span class="comment">         -----------------</span></span><br><span class="line"><span class="comment">         2:/web/update</span></span><br><span class="line"><span class="comment">         2:/web/add</span></span><br><span class="line"><span class="comment">         2:/web/delete</span></span><br><span class="line"><span class="comment">         使用getAnnotation的结果:null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从执行结果来看如果当前类拥有该注解@FilterPath,则getAnnotationsByType方法不会从CC父类寻找，下面看看另外一种情况，即AA类上没有@FilterPath注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Java8新增@Repeatable原注解</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">//添加可继承元注解</span></span><br><span class="line"><span class="meta">@Repeatable</span>(FilterPaths.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FilterPath &#123;</span><br><span class="line">    <span class="function">String  <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">//添加可继承元注解</span></span><br><span class="line"><span class="meta">@interface</span> FilterPaths &#123;</span><br><span class="line">    FilterPath[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/list"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/getList"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AA上不使用@FilterPath注解,getAnnotationsByType将会从父类查询</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> <span class="keyword">extends</span> <span class="title">CC</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = AA.class;</span><br><span class="line">        <span class="comment">//通过getAnnotationsByType方法获取所有重复注解</span></span><br><span class="line">        FilterPath[] annotationsByType = clazz.getAnnotationsByType(FilterPath.class);</span><br><span class="line">        FilterPath[] annotationsByType2 = clazz.getDeclaredAnnotationsByType(FilterPath.class);</span><br><span class="line">        <span class="keyword">if</span> (annotationsByType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FilterPath filter : annotationsByType) &#123;</span><br><span class="line">                System.out.println(<span class="string">"1:"</span>+filter.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (annotationsByType2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FilterPath filter : annotationsByType2) &#123;</span><br><span class="line">                System.out.println(<span class="string">"2:"</span>+filter.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"使用getAnnotation的结果:"</span>+clazz.getAnnotation(FilterPath.class));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行结果(当前类没有<span class="doctag">@FilterPath</span>,getAnnotationsByType方法从CC父类寻找)</span></span><br><span class="line"><span class="comment">         1:/web/list</span></span><br><span class="line"><span class="comment">         1:/web/getList</span></span><br><span class="line"><span class="comment">         -----------------</span></span><br><span class="line"><span class="comment">         使用getAnnotation的结果:null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意定义@FilterPath和@FilterPath时必须指明@Inherited，getAnnotationsByType方法否则依旧无法从父类获取@FilterPath注解，这是为什么呢，不妨看看getAnnotationsByType方法的实现源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口默认实现方法</span></span><br><span class="line"><span class="keyword">default</span> &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) &#123;</span><br><span class="line"><span class="comment">//先调用getDeclaredAnnotationsByType方法</span></span><br><span class="line">T[] result = getDeclaredAnnotationsByType(annotationClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前类获取到的注解数组是否为0</span></span><br><span class="line"><span class="keyword">if</span> (result.length == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span> <span class="keyword">instanceof</span> Class &amp;&amp; </span><br><span class="line"><span class="comment">//判断定义注解上是否使用了@Inherited元注解 </span></span><br><span class="line"> AnnotationType.getInstance(annotationClass).isInherited()) &#123; <span class="comment">// Inheritable</span></span><br><span class="line">        <span class="comment">//从父类获取</span></span><br><span class="line">       Class&lt;?&gt; superClass = ((Class&lt;?&gt;) <span class="keyword">this</span>).getSuperclass();</span><br><span class="line">   <span class="keyword">if</span> (superClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = superClass.getAnnotationsByType(annotationClass);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2、新增的两种ElementType"><a href="#5-2、新增的两种ElementType" class="headerlink" title="5.2、新增的两种ElementType"></a>5.2、新增的两种ElementType</h4><p>在Java8中 ElementType 新增两个枚举成员，TYPE_PARAMETER 和 TYPE_USE ，在Java8前注解只能标注在一个声明(如字段、类、方法)上，Java8后，新增的TYPE_PARAMETER可以用于标注类型参数，而TYPE_USE则可以用于标注任意类型(不包括class)。如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TYPE_PARAMETER 标注在类型参数上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&lt;@<span class="title">Parameter</span> <span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TYPE_USE则可以用于标注任意类型(不包括class)</span></span><br><span class="line"><span class="comment">//用于父类或者接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> <span class="keyword">implements</span> @<span class="title">Rectangular</span> <span class="title">Shape</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于构造函数</span></span><br><span class="line"><span class="keyword">new</span> <span class="meta">@Path</span> String(<span class="string">"/usr/bin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于强制转换和instanceof检查,注意这些注解中用于外部工具，它们不会对类型转换或者instanceof的检查行为带来任何影响。</span></span><br><span class="line">String path=(<span class="meta">@Path</span> String)input;</span><br><span class="line"><span class="keyword">if</span>(input <span class="keyword">instanceof</span> <span class="meta">@Path</span> String)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于指定异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> @Localized IOException.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//用于通配符绑定</span></span></span><br><span class="line"><span class="function">List&lt;@ReadOnly ? extends Person&gt;</span></span><br><span class="line"><span class="function">List&lt;? extends @ReadOnly Person&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">@NotNull String.class <span class="comment">//非法，不能标注class</span></span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.lang.@NotNull String <span class="comment">//非法，不能标注import</span></span></span><br></pre></td></tr></table></figure>
<p>这里主要说明一下TYPE_USE，类型注解用来支持在Java的程序中做强类型检查，配合第三方插件工具（如Checker Framework），可以在编译期检测出runtime error（如UnsupportedOperationException、NullPointerException异常），避免异常延续到运行期才发现，从而提高代码质量，这就是类型注解的主要作用。总之Java 8 新增加了两个注解的元素类型ElementType.TYPE_USE 和ElementType.TYPE_PARAMETER ，通过它们，我们可以把注解应用到各种新场合中。</p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/img/donate.png">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <br />
        <div id="comment-container" style="display:none;">
        </div>
        <div id="disqus_thread" style="display:none;"></div>

        <div id="lv-container" style="display:none;">
        </div>

    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        <li>
            <a target="_blank" href="https://twitter.com/z_alex">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-twitter"></i>
                            </span>
            </a>
        </li>
        
        
        <li>
            <a target="_blank" href="https://www.zhihu.com/people/z.alex">
                            <span class="fa-stack fa-lg">
                                 <i class="iconfont icon-zhihu"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank" href="http://weibo.com/江南E客">
                            <span class="fa-stack fa-lg">
                                  <i class="iconfont icon-weibo"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank" href="https://www.facebook.com/z_alex">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-facebook"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank"  href="https://github.com/Alex0605">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank"  href="https://www.linkedin.com/in/z_alex">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-linkedin"></i>
                            </span>
            </a>
        </li>
        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv" style="display:none">
            <span id="busuanzi_value_site_pv" style="display:none"></span>
        </span>
        <span id="busuanzi_container_site_uv" style="display:none">
            <span id="busuanzi_value_site_uv" style="display:none"></span>
        </span>
     </p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
